# Copyright (C) 2019-2022, Sebastian Ehlert
# This file is distributed under the same license as the toml-f package.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: toml-f 0.2.3\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-17 15:06+0200\n"
"PO-Revision-Date: 2022-04-10 18:03+0200\n"
"Last-Translator: Sebastian Ehlert\n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.2\n"

#: ../doc/how-to/index.rst:4
msgid "How-to guides"
msgstr ""

#: ../doc/how-to/index.rst:6
msgid ""
"This section contains practical guides for working with TOML Fortran. "
"Each recipe is tailored for a specific problem and use case it is trying "
"to solve."
msgstr ""
"Dieser Abschnitt enthält praktische Anleitungen für die Arbeit mit TOML "
"Fortran. Jede Rezepte ist für eine bestimmte Problem- und Nutzungs-"
"Szenarien angepasst."

#: ../doc/how-to/index.rst:9
msgid "Contributions are welcome!"
msgstr "Beiträge sind willkommen!"

#: ../doc/how-to/index.rst:12
msgid ""
"If you have written on TOML Fortran and want to contribute to the "
"documentation, feel free to fork the repository and submit a pull "
"request."
msgstr ""
"Wenn Du über TOML Fortran geschrieben hast und zur Dokumentation "
"beigetreten möchtest, dann kannst Du das Repository forken und eine Pull "
"Request öffnen."

#: ../doc/how-to/installation.rst:4
msgid "Installing TOML Fortran"
msgstr "Installieren von TOML Fortran"

#: ../doc/how-to/installation.rst:6
msgid ""
"This guide will walk you through installing the latest version of TOML "
"Fortran. If you know your way around fpm, CMake or meson, checkout the "
":ref:`integration guide <integration>` to allow on-demand compilation of "
"TOML Fortran as well as discovery of installed libraries."
msgstr ""
"Diese Anleitung führt Dich durch die Installation der neuesten Version "
"von TOML Fortran. Falls Du FPM, CMake oder meson verwendest, schaue Dir "
"die :ref:`Integrationsanleitung <integration>` an, um TOML Fortran "
"automatisch in mitzukompilieren oder bereits installierte Bibliotheken zu"
" finden."

#: ../doc/how-to/installation.rst:11
msgid ":fab:`apple` :fab:`linux` :fab:`windows` Installing from conda-forge"
msgstr ":fab:`apple` :fab:`linux` :fab:`windows` Installation von conda-forge"

msgid "Conda"
msgstr "Conda"

#: ../doc/how-to/installation.rst:22
msgid ""
"This project is packaged for the *mamba* package manager and available on"
" the *conda-forge* channel. To install the *mamba* package manager we "
"recommend the `mambaforge <https://github.com/conda-"
"forge/miniforge/releases>`_ installer. If the *conda-forge* channel is "
"not yet enabled, add it to your channels with"
msgstr ""
"Dieses Projekt ist für den *mamba*-Paketmanager verfügbar und wird auf "
"dem *conda-forge*-Kanal zur Verfügung gestellt. Um den "
"*mamba*-Paketmanager zu installieren, empfehlen wir den `mambaforge "
"<https://github.com/conda-forge/miniforge/releases>`_-Installer. Falls "
"der *conda-forge*-Kanal noch nicht aktiviert ist, füge ihn zu Deinen "
"Kanälen hinzu mit"

#: ../doc/how-to/installation.rst:31
msgid ""
"Once the *conda-forge* channel has been enabled, TOML Fortran can be "
"installed with *mamba*:"
msgstr ""
"Wenn der *conda-forge*-Kanal aktiviert ist, kann TOML Fortran mit *mamba*"
" installiert werden:"

#: ../doc/how-to/installation.rst:37
msgid ""
"It is possible to list all of the versions of TOML Fortran available on "
"your platform with *mamba*:"
msgstr ""
"Es ist möglich, alle verfügbaren Versionen von TOML Fortran für Dein "
"System mit *mamba* aufzulisten:"

#: ../doc/how-to/installation.rst:45
msgid ":fab:`freebsd` FreeBSD ports"
msgstr ":fab:`freebsd` FreeBSD Ports"

msgid "FreeBSD"
msgstr "FreeBSD"

#: ../doc/how-to/installation.rst:51
msgid "A port for FreeBSD is available"
msgstr "Ein FreeBSD-Port ist verfügbar"

#: ../doc/how-to/installation.rst:57
msgid "In case no package is available build the port using"
msgstr "Falls kein Paket verfügbar ist, kann der Port folgendermaßen gebaut werden"

#: ../doc/how-to/installation.rst:64
msgid ""
"For more information see the `toml-f port details "
"<https://www.freshports.org/textproc/toml-f/>`_."
msgstr ""
"Für weitere Informationen schau Dir die `toml-f Port-Details "
"<https://www.freshports.org/textproc/toml-f/>`_ an."

#: ../doc/how-to/installation.rst:68
msgid ":fab:`linux` Using EasyBuild"
msgstr ":fab:`linux` Mit EasyBuild"

#: ../doc/how-to/installation.rst:70
msgid ""
"TOML Fortran is available with `EasyBuild "
"<https://docs.easybuild.io/en/latest/index.html>`_. You can check the "
"available configurations using the search option"
msgstr ""

#: ../doc/how-to/installation.rst:80
msgid "Select one matching configuration and build TOML Fortran using"
msgstr ""

#: ../doc/how-to/installation.rst:94
msgid ""
"TOML Fortran should now be available via an environment module. For more "
"details checkout the `EasyBuild`_ documentation."
msgstr ""

#: ../doc/how-to/installation.rst:99
msgid ":fab:`apple` Using Homebrew"
msgstr ":fab:`apple` Mit Homebrew"

#: ../doc/how-to/installation.rst:101
msgid ""
"TOML Fortran is available in a custom tap at `grimme-lab/homebrew-qc "
"<https://github.com/grimme-lab/homebrew-qc>`__ for the `brew "
"<https://brew.sh>`_ package manager. You can include the tap by using"
msgstr ""
"TOML Fortran ist in einem eigenen Tap unter `grimme-lab/homebrew-qc "
"<https://github.com/grimme-lab/homebrew-qc>`__ für den `brew "
"<https://brew.sh>`_-Paketmanager verfügbar. Du kannst den Tap mit dem "
"`tap`-Kommando einbinden."

#: ../doc/how-to/installation.rst:109
msgid ""
"To build with a custom Fortran compiler you can set the ``FC`` "
"environment variable and force to ignore preexisting binary distributions"
" from the tap"
msgstr ""
"Um mit einem eigenen Fortran-Compiler zu kompilieren, kannst Du die "
"``FC``-Umgebungsvariable setzen und die vorhandenen "
"Binärdistributionsdateien vom Tap ignorieren"

#: ../doc/how-to/installation.rst:118
msgid ""
"TOML Fortran has not yet been submitted to `homebrew-core "
"<https://github.com/homebrew/homebrew-core>`_."
msgstr ""
"TOML Fortran wurde noch nicht zu `homebrew-core "
"<https://github.com/homebrew/homebrew-core>`_ hinzugefügt."

#: ../doc/how-to/installation.rst:122
msgid "Building from source"
msgstr "Vom Quellcode bauen"

#: ../doc/how-to/installation.rst:124
msgid ""
"To build this project from the source code in this repository you need to"
" have"
msgstr ""
"Um dieses Projekt aus dem Quellcode in diesem Repository zu bauen, "
"benötigst Du"

#: ../doc/how-to/installation.rst:126
msgid "a Fortran compiler supporting Fortran 2008"
msgstr "einen Fortran-Compiler, der Fortran 2008 unterstützt"

#: ../doc/how-to/installation.rst:128
msgid "GFortran 5 or newer"
msgstr "GFortran 5 oder neuer"

#: ../doc/how-to/installation.rst:129
msgid "Intel Fortran 18 or newer"
msgstr "Intel Fortran 18 oder neuer"

#: ../doc/how-to/installation.rst:130
msgid "NAG 7 or newer"
msgstr "NAG 7 oder neuer"

#: ../doc/how-to/installation.rst:132
msgid "One of the supported build systems"
msgstr "Eines der unterstützten Buildsysteme"

#: ../doc/how-to/installation.rst:134
msgid "`meson <https://mesonbuild.com>`_ version 0.55 or newer"
msgstr "`meson <https://mesonbuild.com>`_ Version 0.55 oder neuer"

#: ../doc/how-to/installation.rst:135
msgid "`CMake <https://cmake.org/>`_ version 3.9 or newer"
msgstr "`CMake <https://cmake.org/>`_ Version 3.9 oder neuer"

#: ../doc/how-to/installation.rst:137
msgid "First, get the source by cloning the repository"
msgstr "Erst, hol Dir den Quellcode per Clone des Repositories"

#: ../doc/how-to/installation.rst:146
msgid "Using Meson"
msgstr "Mit Meson"

#: ../doc/how-to/installation.rst:148
msgid ""
"To build this project with meson a build-system backend is required, "
"*i.e.* `ninja <https://ninja-build.org>`_ version 1.7 or newer. Setup a "
"build with"
msgstr ""
"Um dieses Projekt mit meson zu bauen, benötigst Du ein Build-System, wie "
"`ninja <https://ninja-build.org>`_ Version 1.7 oder neuer. "

#: ../doc/how-to/installation.rst:155
msgid ""
"You can select the Fortran compiler by the ``FC`` environment variable. "
"To compile the project run"
msgstr ""
"Du kannst den Fortran-Compiler durch die Umgebungsvariable ``FC`` "
"auswählen. Um das Projekt zu kompilieren, rufe den folgenden Befehl auf"

#: ../doc/how-to/installation.rst:162
msgid ""
"We employ a `validator suite <https://github.com/BurntSushi/toml-test>`_ "
"to test the standard compliance of this implementation. To use this "
"testing a *go* installation is required. The installation of the "
"validator suite will be handled by meson automatically without installing"
" into the users *go* workspace. Run the tests with"
msgstr ""
"Wir arbeiten mit einer `Validator-Suite <https://github.com/BurntSushi"
"/toml-test>`_ um die Standardkonformität dieser Implementierung zu "
"testen. Um diese Test zu durchführen, benötigst Du eine "
"*go*-Installation. Die Installation der Validator-Suite wird automatisch "
"von meson in den *go*-Arbeitsbereich eingebunden. Die Tests werden "
"folgendermaßen aufgerufen"

#: ../doc/how-to/installation.rst:171
msgid ""
"To run the full decoder test add the benchmark argument. This test will "
"currently fail, due to the implementation not yet supporting Unicode "
"escape sequences."
msgstr ""
"Um den kompletten Decoder-Test auszuführen, füge den Benchmark-Parameter "
"hinzu. Dieser Test wird zur Zeit fehlschlagen, da die Implementierung "
"noch Unicode-Escape-Sequenzen nicht unterstützt."

#: ../doc/how-to/installation.rst:178
msgid ""
"The binary used for transcribing the TOML documents to the testing format"
" is ``_build/test/toml2json`` and can be used to check on per test basis."
" Finally, you can install TOML Fortran with"
msgstr ""
"Das Programm zum Transkribieren von TOML-Dokumenten in das Testformat ist"
" ``_build/test/toml2json`` und kann zur Prüfung auf Basis der Tests "
"verwendet werden. Zum Abschluss kann TOML Fortran wie folgt installiert "
"werden"

#: ../doc/how-to/installation.rst:187
msgid "Using CMake"
msgstr "Mit CMake"

#: ../doc/how-to/installation.rst:189
msgid ""
"While meson is the preferred way to build this project it also offers "
"CMake support. Configure the CMake build with"
msgstr ""
"Während meson die bevorzugte Bauweise für dieses Projekt ist, bietet es "
"auch CMake-Unterstützung. Konfiguriere den CMake-Build mit"

#: ../doc/how-to/installation.rst:196
msgid ""
"Similar to meson the compiler can be selected with the ``FC`` environment"
" variable. You can build the project using"
msgstr ""
"Ähnlich wie meson kann der Compiler durch die Umgebungsvariable ``FC`` "
"ausgewählt werden. Du kannst das Projekt wie folgt bauen"

#: ../doc/how-to/installation.rst:203
msgid ""
"To include *toml-f* in your CMake project, check the [example integration"
" with CMake](https://github.com/toml-f/tf-cmake-example). The validation "
"suite is currently not supported as unit test for CMake builds and "
"requires a manual setup instead using the *toml2json* binary. Finally, "
"you can install TOML Fortran with"
msgstr ""

#: ../doc/how-to/installation.rst:213
msgid "Supported compilers"
msgstr "Unterstützte Compiler"

#: ../doc/how-to/installation.rst:215
msgid ""
"This is a non-comprehensive list of tested compilers for TOML Fortran. "
"Compilers with the label *latest* are tested with continuous integration "
"for each commit."
msgstr ""
"Dies ist eine nicht-komplettierte Liste von getesteten Compilern für TOML"
" Fortran. Compiler mit dem Label *latest* werden getestet mit den "
"kontinuierlichen Integrationen für jeden Commit."

#: ../doc/how-to/installation.rst:219 ../doc/how-to/installation.rst:238
msgid "Compiler"
msgstr "Compiler"

#: ../doc/how-to/installation.rst:219 ../doc/how-to/installation.rst:238
msgid "Version"
msgstr "Version"

#: ../doc/how-to/installation.rst:219 ../doc/how-to/installation.rst:238
msgid "Platform"
msgstr "Plattform"

#: ../doc/how-to/installation.rst:219 ../doc/how-to/installation.rst:238
msgid "Architecture"
msgstr "Architektur"

#: ../doc/how-to/installation.rst:219
msgid "version"
msgstr "Version"

#: ../doc/how-to/installation.rst:221 ../doc/how-to/installation.rst:222
#: ../doc/how-to/installation.rst:223 ../doc/how-to/installation.rst:224
#: ../doc/how-to/installation.rst:225
msgid "GCC"
msgstr ""

#: ../doc/how-to/installation.rst:221
msgid "11.1, 10.3, 9.4, 8.5, 7.5"
msgstr ""

#: ../doc/how-to/installation.rst:221 ../doc/how-to/installation.rst:228
#: ../doc/how-to/installation.rst:240
msgid "Ubuntu 20.04"
msgstr ""

#: ../doc/how-to/installation.rst:221 ../doc/how-to/installation.rst:222
#: ../doc/how-to/installation.rst:226 ../doc/how-to/installation.rst:227
#: ../doc/how-to/installation.rst:228 ../doc/how-to/installation.rst:229
#: ../doc/how-to/installation.rst:230 ../doc/how-to/installation.rst:240
#: ../doc/how-to/installation.rst:241
msgid "x86_64"
msgstr ""

#: ../doc/how-to/installation.rst:221 ../doc/how-to/installation.rst:222
#: ../doc/how-to/installation.rst:226 ../doc/how-to/installation.rst:228
msgid "0.2.3, latest"
msgstr ""

#: ../doc/how-to/installation.rst:222
msgid "9.4, 6.5"
msgstr ""

#: ../doc/how-to/installation.rst:222
msgid "MacOS 10.15.7"
msgstr ""

#: ../doc/how-to/installation.rst:223
msgid "11.0"
msgstr ""

#: ../doc/how-to/installation.rst:223
msgid "MacOS 11.0"
msgstr ""

#: ../doc/how-to/installation.rst:223
msgid "arm64"
msgstr ""

#: ../doc/how-to/installation.rst:223 ../doc/how-to/installation.rst:224
#: ../doc/how-to/installation.rst:225 ../doc/how-to/installation.rst:227
#: ../doc/how-to/installation.rst:229 ../doc/how-to/installation.rst:230
msgid "0.2.3"
msgstr ""

#: ../doc/how-to/installation.rst:224 ../doc/how-to/installation.rst:225
msgid "9.4"
msgstr ""

#: ../doc/how-to/installation.rst:224 ../doc/how-to/installation.rst:225
msgid "CentOS 7"
msgstr ""

#: ../doc/how-to/installation.rst:224
msgid "ppc64le"
msgstr ""

#: ../doc/how-to/installation.rst:225
msgid "aarch64"
msgstr ""

#: ../doc/how-to/installation.rst:226 ../doc/how-to/installation.rst:227
msgid "GCC/MinGW"
msgstr ""

#: ../doc/how-to/installation.rst:226
msgid "8.1"
msgstr ""

#: ../doc/how-to/installation.rst:226 ../doc/how-to/installation.rst:227
msgid "Window Server 2019"
msgstr ""

#: ../doc/how-to/installation.rst:227
msgid "5.3"
msgstr ""

#: ../doc/how-to/installation.rst:228 ../doc/how-to/installation.rst:229
msgid "Intel"
msgstr ""

#: ../doc/how-to/installation.rst:228
msgid "2022.0"
msgstr ""

#: ../doc/how-to/installation.rst:229
msgid "19"
msgstr ""

#: ../doc/how-to/installation.rst:229
msgid "OpenSUSE"
msgstr ""

#: ../doc/how-to/installation.rst:230
msgid "NAG"
msgstr ""

#: ../doc/how-to/installation.rst:230
msgid "7.1"
msgstr ""

#: ../doc/how-to/installation.rst:230
msgid "RHEL"
msgstr ""

#: ../doc/how-to/installation.rst:233
msgid ""
"Compiler known to fail are documented here, together with the last commit"
" where this behaviour was encountered. If available an issue in on the "
"projects issue tracker or the issue tracker of the dependencies is "
"linked. Usually, it safe to assume that older versions of the same "
"compiler will fail to compile as well and this failure is consistent over"
" platforms and/or architectures."
msgstr ""
"Compiler die aktuell fehlschlagen sind hier dokumentiert, zusammen mit "
"dem letzten Commit, an dem dieses Verhalten aufgetreten ist. Wenn "
"verfügbar ist ein Problem im Issue-Tracker des Projekts oder der Issue-"
"Tracker der Abhängigkeiten verlinkt. Normalerweise ist es sicher, dass "
"ältere Versionen desselben Compilers auch fehlschlagen und dieses "
"Verhalten ist über Platformen und/oder Architekturen konsistent."

#: ../doc/how-to/installation.rst:238
msgid "Reference"
msgstr "Referenz"

#: ../doc/how-to/installation.rst:240
msgid "Flang"
msgstr ""

#: ../doc/how-to/installation.rst:240
msgid "20190329"
msgstr ""

#: ../doc/how-to/installation.rst:240
msgid "`f066ec6`_, `toml-f#28`_"
msgstr ""

#: ../doc/how-to/installation.rst:241
msgid "NVHPC"
msgstr ""

#: ../doc/how-to/installation.rst:241
msgid "20.9"
msgstr ""

#: ../doc/how-to/installation.rst:241
msgid "Manjaro Linux"
msgstr ""

#: ../doc/how-to/installation.rst:241
msgid "`f066ec6`_, `toml-f#27`_"
msgstr ""

#: ../doc/how-to/integration.rst:4
msgid "Using TOML Fortran"
msgstr "TOML Fortran verwenden"

#: ../doc/how-to/integration.rst:6
msgid ""
"This tutorial shows how to integrate the TOML Fortran library with your "
"build system and use it easily in your project."
msgstr ""
"Dieses Tutorial zeigt, wie sich die TOML Fortran-Bibliothek mit Deinem "
"Build-System integrieren kannst und sie einfach in Dein Projekt "
"verwendest."

#: ../doc/how-to/integration.rst:10
msgid "Using the Fortran package manager"
msgstr "Mit dem Fortran-Paket-Manager verwenden"

#: ../doc/how-to/integration.rst:12
msgid ""
"The Fortran package manager (`fpm <https://fpm.fortran-lang.org>`_) is a "
"tool for building Fortran projects and managing dependencies on Fortran "
"libraries. To enable TOML Fortran in your fpm project add the following "
"entry to your package manifest:"
msgstr ""
"Der Fortran-Paket-Manager (`fpm <https://fpm.fortran-lang.org/de>`_) ist "
"ein Werkzeug zum Erstellen von Fortran-Projekten und Verwaltung von "
"Abhängigkeiten von Fortran-Bibliotheken. Um TOML Fortran in Deinem fpm-"
"Projekt zu aktivieren, füge folgenden Eintrag in Deinen Paket-Manifest "
"ein:"

#: ../doc/how-to/integration.rst:15
msgid "fpm.toml"
msgstr ""

#: ../doc/how-to/integration.rst:21
msgid ""
"When building your project fpm will automatically fetch TOML Fortran for "
"you and build it as part of your project. The TOML Fortran modules become"
" useable in your project."
msgstr ""
"Wenn Du Dein Projekt baust, wird fpm automatisch TOML Fortran für Dich "
"herunterladen und als Teil Deines Projekts kompilieren. Die TOML Fortran-"
"Module werden in Deinem Projekt dann verfügbar gemacht."

#: ../doc/how-to/integration.rst:26
msgid "Integrate with meson"
msgstr "Mit meson integrieren"

#: ../doc/how-to/integration.rst:28
msgid ""
"To allow meson to use TOML Fortran it is easiest to include it as "
"subproject using a git wrap file placed in the ``subprojects`` directory."
msgstr ""
"Um TOML Fortran in meson zu verwenden, ist es am einfachsten, wenn Du es "
"als Unterprojekt mit einer git-Wrap-Datei im ``subprojects``-Verzeichnis "
"einbindest."

#: ../doc/how-to/integration.rst:30
msgid "subprojects/toml-f.wrap"
msgstr ""

#: ../doc/how-to/integration.rst:38
msgid ""
"The revision can be adjusted to pin a specific release tag of TOML "
"Fortran for additional stability. In the projects meson buid file the "
"dependency method can be used to access TOML Fortran using the wrap file "
"to define a fallback which is built on-demand."
msgstr ""
"Die Revision kann angepasst werden, um eine bestimmte Release-Tag von "
"TOML Fortran festzulegen und die Stabilität zu erhöhen. In den Meson "
"Build-Dateien kannst Du dann TOML Fortran als Abhängigkeit verwenden, "
"dank der Wrap-Datei, wird eine Fallback-Version definiert und TOML "
"Fortran kann bei Bedarf mitzukompiliert werden."

#: ../doc/how-to/integration.rst:41
msgid "meson.build"
msgstr ""

#: ../doc/how-to/integration.rst:52
msgid ""
"Finally, you can add ``tomlf_dep`` as dependency to any of your targets "
"and are done."
msgstr ""
"Damit kannst Du ``tomlf_dep`` als Abhängigkeit zu einem beliebigen Ziel "
"hinzufügen und bist fertig."

#: ../doc/how-to/integration.rst:56
msgid "Integrate with CMake"
msgstr "Mit CMake integrieren"

#: ../doc/how-to/integration.rst:58
msgid ""
"To use TOML Fortran in CMake based projects it is useful to define your "
"own find-module, to allow on-demand compilation of TOML Fortran as well "
"as discovery of installed packages from both meson and CMake based "
"builds."
msgstr ""
"Um TOML Fortran in CMake-basierten Projekten zu verwenden, ist es "
"nützlich, ein eigenes find-Modul zu definieren, um TOML Fortran entweder "
"bei Bedarf mitzukompiliert oder auch die Installation von installierten "
"Paketen von sowohl meson als auch CMake-basierten Builds zu ermöglichen."

#: ../doc/how-to/integration.rst:68
msgid ""
"In your main CMake build file you have to include the custom find-module "
"in your ``CMAKE_MODULE_PATH``, afterwards you can just use "
"``find_package`` to obtain the ``toml-f::toml-f`` target and link against"
" it."
msgstr ""
"In Deiner primären CMake-Build Datei musst Du das eigene find-Modul in "
"Deinem ``CMAKE_MODULE_PATH`` einbinden, danach kannst Du ``find_package``"
" verwenden, um das ``toml-f::toml-f``-Ziel zu erhalten und dagegen zu "
"verlinken."

#: ../doc/how-to/integration.rst:70
msgid "CMakeLists.txt"
msgstr ""

#: ../doc/how-to/integration.rst:111
msgid ""
"Note that we also install the find-modules, this is important if you want"
" to make your CMake projects reusable in the same way TOML Fortran can be"
" used in your project. Finally we need some boilerplate to define the "
"custom find-module is documented below."
msgstr ""
"Beachte, dass wir auch die find-Module installieren, das ist wichtig, "
"wenn Du Deine CMake-Projekte in der gleichen Weise wie TOML Fortran in "
"anderen Projekt verwenden kannst. Zuletzt brauchst Du ein paar Zeilen "
"Code, um das eigene find-Modul zu definieren, siehe unten."

#: ../doc/how-to/integration.rst:115
msgid "Imported Targets"
msgstr "Importierte Ziele"

#: ../doc/how-to/integration.rst:117
msgid "This module provides the following imported target, if found:"
msgstr ""
"Dieses Modul stellt folgende importierte Ziele bereit, falls es gefunden "
"wurde:"

#: ../doc/how-to/integration.rst:121
msgid "``toml-f::toml-f``"
msgstr ""

#: ../doc/how-to/integration.rst:120
msgid "The toml-f library"
msgstr "Die toml-f Bibliothek"

#: ../doc/how-to/integration.rst:124
msgid "Result Variables"
msgstr "Ergebnisvariablen"

#: ../doc/how-to/integration.rst:126
msgid "This module will define the following variables:"
msgstr "Dieses Modul definiert folgende Variablen:"

#: ../doc/how-to/integration.rst:129
msgid "``TOML_FORTRAN_FOUND``"
msgstr ""

#: ../doc/how-to/integration.rst:129
msgid "True if the toml-f library is available"
msgstr "Wahr wenn die toml-f Bibliothek verfügbar ist"

#: ../doc/how-to/integration.rst:133
msgid "``TOML_FORTRAN_SOURCE_DIR``"
msgstr ""

#: ../doc/how-to/integration.rst:132
msgid ""
"Path to the source directory of the toml-f project, only set if the "
"project is included as source."
msgstr ""
"Pfad zum Quellverzeichnis des toml-f Projekts, nur gesetzt, wenn das "
"Projekt als Quellcode eingebunden wird."

#: ../doc/how-to/integration.rst:137
msgid "``TOML_FORTRAN_BINARY_DIR``"
msgstr ""

#: ../doc/how-to/integration.rst:136
msgid ""
"Path to the binary directory of the toml-f project, only set if the "
"project is included as source."
msgstr ""
"Pfad zum Buildverzeichnis des toml-f Projekts, nur gesetzt, wenn das "
"Projekt als Quellcode eingebunden wird."

#: ../doc/how-to/integration.rst:140
msgid "Cache variables"
msgstr "Cachevariablen"

#: ../doc/how-to/integration.rst:142
msgid ""
"The following cache variables may be set to influence the library "
"detection:"
msgstr ""
"Die folgenden Cachevariablen können gesetzt werden um die Einbindung der "
"Bibliothek zu beeinflussen:"

#: ../doc/how-to/integration.rst:150
msgid "``TOML_FORTRAN_FIND_METHOD``"
msgstr ""

#: ../doc/how-to/integration.rst:145
msgid "Methods to find or make the project available. Available methods are"
msgstr "Möglichkeiten zum Finden oder zum Erstellen des Projekts. Verfügbar sind "

#: ../doc/how-to/integration.rst:147
msgid "``cmake``: Try to find via CMake config file"
msgstr "``cmake``: Versuche via CMake Konfigurationsdatei zu finden"

#: ../doc/how-to/integration.rst:148
msgid "``pkgconf``: Try to find via pkg-config file"
msgstr "``pkgconf``: Versuche via pkg-config Datei zu finden"

#: ../doc/how-to/integration.rst:149
msgid "``subproject``: Use source in subprojects directory"
msgstr "``subproject``: Verwende Quellcode in Unterprojektverzeichnis"

#: ../doc/how-to/integration.rst:150
msgid "``fetch``: Fetch the source from upstream"
msgstr "``fetch``: Hole den Quellcode vom Upstream Repository"

#: ../doc/how-to/integration.rst:153
msgid "``TOML_FORTRAN_DIR``"
msgstr ""

#: ../doc/how-to/integration.rst:153
msgid "Used for searching the CMake config file"
msgstr "Wird für die Suche der CMake Konfigurationsdatei verwendet"

#: ../doc/how-to/integration.rst:156
msgid "``TOML_FORTRAN_SUBPROJECT``"
msgstr ""

#: ../doc/how-to/integration.rst:156
msgid "Directory to find the toml-f subproject, relative to the project root"
msgstr ""
"Verzeichnis zum Finden des toml-f Unterprojekts, relativ zum Projekt "
"Wurzelverzeichnis"

#: ../doc/how-to/integration.rst:158
msgid "cmake/Findtoml-f.cmake"
msgstr ""

#: ../doc/how-to/integration.rst:280
msgid "Other build systems"
msgstr "Andere Buildsysteme"

#: ../doc/how-to/integration.rst:282
msgid ""
"Other build systems must discover a precompiled TOML Fortran library from"
" the system. For this purpose the ``pkg-config`` tool is used. After "
"installing TOML Fortran with either meson or CMake a pc-file is generated"
" which can be discovered by ``pkg-config`` and describes how to compile "
"against the installed module files as well as link against the TOML "
"Fortran library. First check if the ``pkg-config`` tool is available and "
"can discover TOML Fortran"
msgstr ""
"Andere Buildsysteme müssen eine vorkompilierte TOML Fortran Bibliothek "
"auf dem System finden und nutzen. Dazu wird das ``pkg-config`` Tool "
"verwendet. Nach der Installation von TOML Fortran mit Meson oder CMake "
"wird eine pc-Datei erzeugt, die von ``pkg-config`` gefunden werden kann "
"und beschreibt, wie gegen die installierten Moduldateien kompiliert "
"werden kann und wie sich die TOML Fortran Bibliothek verlinken "
"lässt.Zunächst prüfe, ob das ``pkg-config`` Tool verfügbar ist und TOML "
"Fortran gefunden werden kann."

#: ../doc/how-to/integration.rst:291
msgid ""
"Make sure to adjust the ``PKG_CONFIG_PATH`` environment variable to point"
" to the correct installation directory. Using the ``--libs`` and "
"``--cflags`` options the libraries to link against as well as the include"
" directories can be obtained:"
msgstr ""
"Stelle sicher, dass die Umgebungsvariable ``PKG_CONFIG_PATH`` auf das "
"richtige Installationsverzeichnis zeigt. Mit den ``--libs`` und "
"``--cflags`` Optionen können die Bibliotheken, die verlinkt werden "
"sollen, und die Include-Verzeichnisse erhalten werden:"

#: ../doc/how-to/integration.rst:299
msgid "In a handwritten Makefile those can be included by"
msgstr "In einem handgeschriebenen Makefile können diese wie folgt genutzt werden"

#: ../doc/how-to/serde.rst:2
msgid "Serializable base class"
msgstr "Serialisierbare Basisklasse"

#: ../doc/how-to/serde.rst:4
msgid ""
"This recipe shows how to create a serializable class based on TOML "
"Fortran. Currently, TOML Fortran does not define such a base class "
"itself, therefore we define a loader and dumper interface for turning a "
"file or connected unit into a data structure. The abstract base class "
"will implement the processing of the file or unit to a TOML data "
"structure and pass it to a deferred procedure which the implementing "
"class uses to define its mapping from and back to the TOML data "
"structure. This way an easily round-tripable data structure can be "
"created and used in a variety of contexts."
msgstr ""
"Dieses Rezept zeigt, wie eine serialisierbare Klasse auf TOML Fortran "
"basierend konstruiert werden kann. Momentan ist TOML Fortran selbst keine"
" Klasse als Basis für eine serialisierbare Klasse, daher werden wir eine "
"Loader- und Dumper-Schnittstelle definieren, um eine Datei oder eine "
"verbundene Unit in eine Datenstruktur zu konvertieren. Die abstrakte "
"Basisklasse implementiert die Verarbeitung der Datei oder der Unit in "
"eine TOML Datenstruktur und leitet diese an eine deferred Prozedur "
"weiter, die in der Klasse implementiert wird um, ein Mapping von der TOML"
" Datenstruktur and zurück zu definieren. Diese Art von Datenstruktur kann"
" in verschiedenen Kontexten genutzt werden and einfach in TOML und zurück"
" transferiert werden."

#: ../doc/how-to/serde.rst:11
msgid ""
"TOML Fortran might provide such abstract base class in the future "
"natively."
msgstr ""
"TOML Fortran könnte in Zukunft selbst eine solche abstrakte Basisklasse "
"bereitstellen."

#: ../doc/how-to/serde.rst:13
msgid "The base class can be defined as"
msgstr "Die Basisklasse kann wie folgt definiert werden"

#: ../doc/how-to/serde.rst:15
msgid "src/serde_class.f90"
msgstr ""

#: ../doc/how-to/serde.rst:19
msgid ""
"We also define a convenience error handler which holds the error message "
"and signals its error status by its allocation state."
msgstr ""
"Wir definieren auch einen Fehler-Handler, der die Fehlermeldung speichert"
" und den Fehlerstatus durch seinen Allokationstatus signalisiert."

#: ../doc/how-to/serde.rst:21
msgid "src/serde_error.f90"
msgstr ""

#: ../doc/how-to/serde.rst:25
msgid ""
"An example for a serializable class based on the above base class is "
"given below."
msgstr ""
"Ein Beispiel für eine serialisierbare Klasse basierend auf der oben "
"gegebenen Basisklasse ist unten aufgeführt."

#: ../doc/how-to/serde.rst:27
msgid "src/demo.f90"
msgstr ""

#: ../doc/how-to/serde.rst:31
msgid ""
"The defined data class can in an application easily be loaded from a "
"file, while the actual implementation does not have to deal with getting "
"the TOML data structure from the file but can assume that if the "
"configuration file was valid TOML it will be provided with a data "
"structure to read from."
msgstr ""
"Die definierte Datenklasse kann in einer Anwendung einfach aus einer "
"Datei geladen werden, während die tatsächliche Implementierung sich nicht"
" um das Lesen der TOML Datenstruktur kümmert, sondern kann sich auch "
"darauf verlassen, dass wenn die Konfigurationsdatei gültiges TOML war, "
"eine Datenstruktur zum Lesen bereitsteht."

#: ../doc/how-to/table.rst:2
msgid "Working with tables"
msgstr "Mit Tabellen zu arbeiten"

#: ../doc/how-to/table.rst:4
msgid ""
"The central data structure in TOML are tables, they contain a map from a "
"key (string) to any supported data type in TOML. This recipes describe "
"common scenarios for retrieving data from tables using the TOML Fortran "
"library."
msgstr ""
"Die zentrale Datenstruktur in TOML sind Tabellen, sie enthalten eine "
"Zuordnung von Einträgen (String) zu allen unterstützten Datentypen in "
"TOML. Dieses Rezept beschreibt die allgemeinen Szenarien für das Abfragen"
" von Daten aus Tabellen mit der TOML Fortran-Bibliothek."

#: ../doc/how-to/table.rst:9
msgid "Accessing nested tables"
msgstr "Geschachtelte Tabellen abfragen"

#: ../doc/how-to/table.rst:11
msgid ""
"Using nested tables provides the possibility to better group "
"configuration data. Since the TOML format always requires the full "
"qualified path in each table header, it is easy for the user to identify "
"where the current settings belong to. On the other hand deeply nested "
"tables with long table paths or path components make it more difficult to"
" use and a good balance of short and expressive table names and "
"meaningful subtables is required."
msgstr ""
"Geschachtelte Tabellen ermöglichen es, Konfigurationsdaten besser zu "
"gruppieren. Da das TOML-Format immer den vollständigen Pfad in jeder "
"Tabellenkopfangabe erfordert, ist es einfach für den Benutzer zu "
"erkennen, wo die aktuellen Einstellungen zu finden sind. Aber schwieriger"
" wird es wenn tief geschachtelte Tabellen mit langen Tabellenpfaden oder "
"Pfadkomponenten verwendet werden. Eine gute Balance zwischen kurzen und "
"aussagekräftigen Tabellennamen und Untereinträge ist erforderlich."

#: ../doc/how-to/table.rst:15
msgid ""
"An example for an electronic structure code implementing different "
"Hamiltonians is give below."
msgstr ""
"Ein Beispiel für einen elektronischen Strukturcode, der "
"unterschiedlicheHamiltonians implementiert, ist unten aufgeführt."

#: ../doc/how-to/table.rst:26
msgid ""
"The deepest nested subtable with entries in this example is the "
"*hamiltonian.dftb.skf* path."
msgstr ""
"Die tiefste geschachtelte Untertabelle in diesem Beispiel ist der "
"*hamiltonian.dftb.skf* Pfad."

#: ../doc/how-to/table.rst:28
msgid ""
"Such layout in the configuration file will usually be mirrored in the "
"actual implementation, with every table corresponding to a derived type "
"describing the input. For the example above in total six derived types "
"for the individual tables are defined as"
msgstr ""
"Dieser Aufbau in der Konfigurationsdatei wird in der tatsächlichen "
"Implementierung korrespondierend wiedergeben, wobei jede Tabelle "
"entsprechend einen abgeleiteten Typ beschreibt, der der Eingabe "
"entspricht. Für das Beispiel oben sind insgesamt sechs abgeleitete Typen "
"für die einzelnen Tabellen definiert."

#: ../doc/how-to/table.rst:31 ../doc/how-to/table.rst:51
#: ../doc/how-to/table.rst:58 ../doc/how-to/table.rst:67
#: ../doc/how-to/table.rst:84
msgid "src/input.f90"
msgstr ""

#: ../doc/how-to/table.rst:38
#, python-format
msgid ""
"The representation in Fortran derived types looks lengthy compared to the"
" actual TOML input. Consider that the 40 lines of Fortran code contain "
"50% comments describing the data types briefly for (future) developers. "
"Of course, the user documentation of the input format will be much more "
"extensive, containing descriptions for every table and every entry, "
"including input ranges and unit conventions. The final input file "
"provided by the user can be brief and expressive."
msgstr ""
"Die Darstellung in abgeleiteten Typen ist in Fortran länger als die TOML-"
"Eingabe. Dabei sollte beachten werden, dass die 40 Zeilen von Fortran "
"Code 50% Kommentare enthalten, die die Datentypen für (zukünftige) "
"Entwickler beschreiben. Zudem ist die Benutzerdokumentation des "
"Eingabeformats ähnlich ausführlich, mit Beschreibungen für alle Tabellen "
"und Einträge, inklusive Eingabebereichs und Einheiten. Die Eingabedatei "
"kann dann kurz und aussagekräftig sein."

#: ../doc/how-to/table.rst:43
msgid ""
"Staring with the root of the table which is read in the "
"*simulation_input* there are two ways to obtain access to a subtable, "
"first we get the *hamiltonian* subtable, which we defined as mandatory, "
"using the ``get_value`` interface. In case it is present a reference will"
" be returned in the *child* pointer. If no table is available in the "
"input TOML Fortran will insert it into the root table and return the "
"reference to the newly created table. The *child* pointer can still be "
"unassigned in case invalid input is provided, which will result in "
"raising an error in the implementation shown below."
msgstr ""
"Mit dem Wurzelknoten der Tabelle, der in den Datentypen "
"*simulation_input* gelesen wird, gibt es zwei Wege, eine Untertabelle "
"abzufragen, zunächst wird die *hamiltonian* Untertabelle abgefragt, die "
"als benötigt definiert ist und mit der ``get_value``-Schnittstelle "
"abgefragt wird. In Fällen, wenn diese Tabelle vorhanden ist, wird eine "
"Referenz mit dem *child* Zeiger zurückgegeben. Falls keine Tabelle "
"vorhanden ist, wird sie in den Wurzelknoten eingefügt und eine Referenz "
"zurückgegeben. Der *child* Zeiger kann in Fällen von unzulässigen "
"Eingaben nicht zugewiesen werden, was mit einer Fehlermeldung in der "
"Implementierung abgefangen wird."

#: ../doc/how-to/table.rst:48
msgid ""
"The alternative is to explicitly mark the subtable as optional, like for "
"the *analysis* table, if no table is available or the entry is invalid "
"the *child* pointer will not be assigned. To differentiate those cases we"
" can request the status information, check whether the operation was "
"successful, and cleanly handle the error case."
msgstr ""
"Alternativ kann die Untertabelle als optional markiert werden, wie für "
"die *analysis* Tabelle, wenn keine Tabelle vorhanden ist oder der Eintrag"
" ungültig ist, bleibt der *child* Zeiger unzugewiesen. Um diese Fälle zu "
"unterscheiden, kann der Statusinformationen abgefragt werden, um zu "
"prüfen, ob die Operation erfolgreich war, und im Fall eines "
"Eingabefehlers eine Fehlermeldung ausgegeben wird."

#: ../doc/how-to/table.rst:56
msgid ""
"The same happens for reading the *hamiltonian_input* and *dftb_input* "
"entry."
msgstr "Das gleiche gilt für die *hamiltonian_input* und *dftb_input* Einträge."

#: ../doc/how-to/table.rst:63
msgid ""
"Finally, we can implement reading the terminal subtables into the "
"*scc_input*, *skf_input*, and *analysis_input*, where we retrieve the "
"actual values using the ``get_value`` interface. Note that we can "
"conveniently define default values using the ``get_value`` interface. For"
" proper error handling we can retrieve add the optional *stat* argument "
"as well."
msgstr ""
"Zuletzt können die terminalen Untertabellen in *scc_input*, *skf_input*, "
"und *analysis_input* gelesen werden, wo die Werte mit ``get_value`` "
"abgefragt werden. Zusätzlich kann ein Standardwert mit ``get_value`` "
"definiert werden. Für einen korrekten Fehlerbehandlung kann auch der "
"optionalen *stat*-Parameter abgefragt werden."

#: ../doc/how-to/table.rst:72
msgid ""
"For the small incomplete input as shown here the fine grained "
"substructure seems like overengineered, and could be fully defined in the"
" reading routine for the document root as well. However, for larger "
"program inputs such structure can help to ensure that input readers are "
"properly modular and reusable."
msgstr ""
"F[r das minimale Eingabebeispiel hier ist die Struktur scheinbar zu fein "
"eingeteilt und könnte direkt beim Lesen der Dokumentenwurzel definiert "
"werden. Allerdings bietet diese Struktur für große Programme einen "
"wesentlichen Vorteil, da sie die Einlese-Routinen modular und "
"wiederverwendbar gestaltet sind."

#: ../doc/how-to/table.rst:77
msgid ""
"The allocation status of a component of derived can used instead of a "
"separate boolean flag to indicate whether a feature should be activated. "
"This avoids requiring conditional code inside a reader routine for "
"conditionally handling entries depending on a boolean flag, instead they "
"can be collected in a subtable."
msgstr ""
"Der Allokationsstatus der Teilkomponenten in den Datentypen kann statt "
"eines separated logischen Option verwendet werden, um eine aktive "
"Funktionalität zu signalisieren. Dies ermöglicht es auf zusätzliche Logik"
" zu verzichten um abhängige Einträge zu lesen, diese sind stattdessen in "
"einer Untertabelle gesammelt."

#: ../doc/how-to/table.rst
msgid "Full source code"
msgstr "Vollständiger Quellcode"

#: ../doc/how-to/table.rst:82
msgid "The full module implementing the *simulation_input* reading"
msgstr "Die vollständige Modul-Implementierung des *simulation_input* "

#: ../doc/how-to/table.rst:88 ../doc/how-to/table.rst:161
msgid "The auxilary module providing the error handler"
msgstr "Hilfsmodul um Fehlerbehandlung zu ermöglichen"

#: ../doc/how-to/table.rst:90 ../doc/how-to/table.rst:163
msgid "src/error.f90"
msgstr ""

#: ../doc/how-to/table.rst:96
msgid "Iterating over keys"
msgstr "Iterieren über Einträge"

#: ../doc/how-to/table.rst:98
msgid ""
"An expressive way to organize data is by providing a table where the keys"
" of each entry describe the object that should be initialized. For "
"example in a package manager the keys represent the dependency, where "
"each dependency is declared in a subtable. Furthermore, a convenience "
"feature might be the possibility to just provide a string, which is "
"interpreted as a version subentry."
msgstr ""
"Eine klare Art Daten zu organisieren ist durch die Verwendung einer "
"Tabelle in der die Einträge die Initialisierung der Objekte beschreiben. "
"Zum Beispiel in einem Paketmanager beschreiben die Einträge die "
"Abhängigkeiten, in der jede davon in einer Untertabelle deklariert "
"wird. Zusätzlich kann der einfachheitshalber ein String angeben werden, "
"der als Versions-Einschränkung für die Untertabelle interpretiert wird."

#: ../doc/how-to/table.rst:102
msgid ""
"The final usage of this in a *requirements* table could look like the "
"snippet shown below."
msgstr ""
"Die Implementierung in einer *requirements* Tabelle könnte wie folgt "
"aussehen:"

#: ../doc/how-to/table.rst:114
msgid ""
"The first three entries provide a string value, while the forth entry "
"provides a subtable implicitly by using dotted key-value pairs and the "
"last entry uses an inline table."
msgstr ""
"In den ersten drei Einträgen wird ein String Wert verwendet, während "
"der vierte Eintrag eine implizite Untertabelle über ein Punktgetrenntes "
"Werte-Paar nutzt und der letzte Eintrag eine Inline-Tabelle ist."

#: ../doc/how-to/table.rst:116
msgid ""
"Here we want to focus on the iteration and the default initialization, "
"the internal structure of the *requirement_type* is secondary for this "
"example. We provide the minimal definition only holding the name of the "
"dependency for demonstration purposes."
msgstr ""
"Wir wollen uns hier auf die Iteration und die Standardinitialisierung "
"konzentrieren. Die internen Struktur des *requirement_type* Datentype ist "
"nebensächlich für dieses Beispiel. Daher geben wir für dieses Beispiel "
"nur die minimale Definition an, die ausschließlich den Namen der "
"Abhängigkeiten enthält."

#: ../doc/how-to/table.rst:119 ../doc/how-to/table.rst:129
#: ../doc/how-to/table.rst:144 ../doc/how-to/table.rst:157
msgid "src/requirements.f90"
msgstr ""

#: ../doc/how-to/table.rst:124
msgid ""
"For the actual implementation of reading all entries from the table we "
"will use an one-dimensional array of *requirement_type* values. Using the"
" ``get_keys`` method of the table we can obtain a list of all keys for "
"the current table, the method will always allocate the ``list`` variable "
"and we can safely allocate the *requirement_type* using the number of "
"keys. To obtain the subtable, the ``get_value`` interface can be used, it"
" will return a pointer to the subtable, either created implicitly by "
"using a dotted key-value pair or by an inline table as shown in the "
"snippet above. Finally, we can call the actual constructor of the "
"*requirement_type* using the subtable references with the ``child`` "
"pointer."
msgstr ""
"Für die Implementierung der Leseoperationen wird ein eindimensionales "
"Feld von *requirement_type* Datentypen verwendet. Durch die ``get_keys`` "
"Methode der Tabelle können alle Schlüssel der aktuellen Tabelle ermittelt "
"werden. Die Methode wird immer eine allozierte ``list`` Variable zurückgeben "
"und kann damit das *requirement_type* Feld auf die Anzahl der Schlüssel "
"allozieren. Die ``get_value`` Methode kann verwendet werden, um auf die "
"Untertabelle zuzugreifen. Sie wird einen Zeiger auf die Untertabelle "
"zurückgeben, die entweder durch ein Punktgetrenntes Wert-Paar oder eine "
"Inline-Tabelle erstellt wurde. Anschließend kann der Konstruktor des "
"*requirement_type* Datentyps auf die Untertabelle-Referenzen mit dem "
"``child`` Zeiger aufgerufen werden."

#: ../doc/how-to/table.rst:134
msgid ""
"The other scenario we want to support is the presence of a string rather "
"than a subtable. In this case the ``get_value`` interface will fail, "
"while it provides an optional status argument to check for successful "
"operation, we can more conveniently and idomatically verify the success "
"by checking the state of the ``child`` pointer. If there is no subtable "
"to reference, *i.e.* because it is a key-value pair with a string entry, "
"the ``child`` pointer will not be associated, which can be easily "
"checked. For this case we will again use the ``get_value`` interface, but"
" this time to retrieve the entry into a deferred length character. Again "
"we can idomatically check the status of the operation using the "
"allocation state of the variable and create the appropriate error message"
" if needed. Eventually, we have to provide the constructor of the "
"requirements with a table, for this purpose we create a dummy table and "
"set the entry at the version key to the just retrieved string. The newly "
"created dummy table can be associated with the ``child`` pointer and "
"passed to the actual constructor."
msgstr ""
"Der zweite Scenario, das wir unterstützen, ist die Nutzung eines "
"Strings anstatt einer Untertabelle. In diesem Fall wird die "
"``get_value`` Methode fehlschlagen, während ein optionaler "
"Status-Parameter zurückgeben werden kann, um den Erfolg zu prüfen, "
"können wir einfacher und idomatisch den Erfolg am Zuweisungs-Status "
"des ``child`` Zeigers prüfen. Wenn es keine Untertabelle zu "
"referenzieren gibt, weil es ein Wert-Paar mit einem String-Eintrag "
"ist, wird der ``child`` Zeiger nicht zugewiesen. Dies kann einfach "
"geprüft werden. Für diesen Fall werden wir die ``get_value`` Methode "
"noch einmal verwenden, um den Eintrag in einen dynamischen String "
"zu speichern. Auch hier können wir den Erfolg am Zuweisungs-Status "
"prüfen und wenn ein Fehler aufgetreten ist, wird eine Fehlermeldung "
"erzeugt. Anschließend können wir den Konstruktor des "
"*requirement_type* Datentyps mit einer Dummy Tabelle aufrufen auf "
"die wir mit dem ``child`` Zeiger referenziert haben."

#: ../doc/how-to/table.rst:142
msgid ""
"The actual constructor for our example is very minimalistic and only "
"recovers the name of the dependency which is passed as a separate "
"argument."
msgstr ""
"Der eigentliche Konstruktor für dieses Beispiel ist sehr minimalistisch "
"und spezifiziert nur den Namen der Abhängigkeit, welcher als separates "
"Argument übergeben wird."

#: ../doc/how-to/table.rst:151
msgid ""
"While we provide an error handler in the example, we also ensure that the"
" allocation status of the *requirement_type* values communicates the "
"status of the operation as well."
msgstr ""
"Wir bieten einen Fehlerbehandlungs-Prozess in diesem Beispiel, "
"zusätzlich stellen wir sicher, dass der Zuweisungs-Status des "
"*requirement_type* Feldes die Status-Informationen der Operation "
"ebenfalls kommuniziert."

#: ../doc/how-to/table.rst:155
msgid "The full module implementing the *requirement_type* reading"
msgstr "Das vollständige Modul zum Einlesen des *requirement_type*"

#: ../doc/how-to/table.rst:169
msgid "Array of tables"
msgstr "Feld von Tabellen"

#: ../doc/how-to/table.rst:171
msgid ""
"A special construct in TOML is the array of tables syntax, it provides a "
"more verbose form to declare several tables in an array, which are "
"usually provided using inline tables as shown below."
msgstr ""
"Ein spezielles Konstrukt in TOML ist ein Feld von Tabellen, das eine "
"ausführlichere Form zum Deklarieren von mehreren Tabellen in einem "
"Feld anbietet. Normalerweise wird dies durch Inline-Tabellen angegeben "
"wie unten gezeigt."

#: ../doc/how-to/table.rst:182
msgid ""
"Comparing the above example to the snippet below using an array of tables"
" for the *tasks* array, the more verbose form becomes preferable in case "
"further subtables are needed. Except for the subtables *config* the same "
"data is provided."
msgstr ""
"Vergleichen wir das obige Beispiel mit dem unten gezeigten Beispiel "
"für das *tasks* Feld, dann ist die ausführlichere Form bevorzugt, wenn "
"wir weitere Untertabelle benötigen. In beiden Beispielen werden bis "
"auf die *config* Untertabelle die gleichen Daten angegeben."

#: ../doc/how-to/table.rst:210
msgid ""
"To represent this data we can use a single *task_config* derived type "
"with a polymorphic *driver_config* member identifying the actual task. "
"For this example we will have two implementations of such task such as "
"LBFGS and Velocity Verlet, which are defined in the following snippets."
msgstr ""
"Um diese Daten zu repräsentieren können wir einen eigenen "
"*task_config* Datentyp verwenden, welcher einen polymorphen "
"*driver_config* Eintrag enthält, der die tatsächliche Aufgabe "
"identifiziert. Für dieses Beispiel werden zwei Implementierungen "
"wie LBFGS und Velocity Verlet definiert, welche in den folgenden "
"Codeblöcken angegeben sind."

#: ../doc/how-to/table.rst:213 ../doc/how-to/table.rst:222
#: ../doc/how-to/table.rst:236 ../doc/how-to/table.rst:244
#: ../doc/how-to/table.rst:255
msgid "src/task.f90"
msgstr ""

#: ../doc/how-to/table.rst:218
msgid ""
"To read the array of tables we start from the root document and fetch the"
" *tasks* entry as array using the ``get_value`` interface. The length of "
"the whole arrays is known and we can use it to allocate the list of "
"*task_config* values before reading the individual entries. The "
"individual tables inside the array can addressed using the ``get_value`` "
"interface by passing the (one-based) index."
msgstr ""
"Um das Feld von Tabellen zu einlesen starten wir vom Wurzeldokument "
"und holen das *tasks* Eintrag als Feld mit der ``get_value`` Routine."
"Die Länge des gesamten Feldes ist bekannt und wir können diese "
"Information benutzen, um eine Liste von *task_config* Einträgen "
"zu allokieren. Die Tabellen in dem Feld können mit der "
"``get_value`` Routine anhand der (1-basierten) Indexposition "
"abgefragt werden."

#: ../doc/how-to/table.rst:229
msgid ""
"In the setup above, if the *tasks* entry is not present it will be "
"implicitly created as an empty array. The allocation and the loop over "
"the entries will work, however the consuming code should check whether no"
" tasks are meaningful or should produce and error."
msgstr ""
"Im obigen Setup wird das *tasks* Eintrag implizit erzeugt, wenn dieser "
"nicht vorhanden ist. Die Allokation und der Schleifendurchlauf "
"funktionieren ohne Probleme, allerdings müssen die folgenden Routinen "
"prüfen, ob eine Simulation ohne Aufgaben Sinn hat oder einen Fehler erzeugen."

#: ../doc/how-to/table.rst:232
msgid ""
"To read the individual tasks we define a separate procedure to make it "
"easily reusable and hide the fact that we are working with a subtable. To"
" make the task *name* optional we make it default to the driver name, for"
" *allocatable* or *pointer* variables the exit status of ``get_value`` "
"can be easily checked by the allocation or association status of the "
"respective variable, alternatively an integer variable can be passed to "
"the optional *stat* argument. Finally, the configuration reader is called"
" depending on the value of *driver* for ease of usage we use a block "
"construct to allocate the specific type and than transfer it using "
"*move_alloc* into the *task_config*."
msgstr ""
"Für die einzelnen Aufgaben definieren wir eine separate Routine, um das "
"Auslesen von Untertabellen zu vereinfachen und die Logik zu verstecken, "
"dass wir mit einer Untertabelle arbeiten. Für den *name* Eintrag ist "
"der Defaultwert der Name des Treibers. Für *allocatable* oder *pointer* "
"Variablen kann der Exit-Status der ``get_value`` Routine direkt "
"überprüft werden. Alternativ kann ein Integerwert als optionales *stat* "
"Argument übergeben werden. Anschließend wird eine weitere Lese-Routine "
"abhängig von dem *driver* Eintrag aufgerufen. Dabei nutzen wir einen "
"Block, um die spezifischen Typen zu allokieren und diese mit "
"*move_alloc* in die *task_config* Instanz zu transferieren."

#: ../doc/how-to/table.rst:241
msgid ""
"For reading the actual driver configuration we use the ``get_value`` "
"interface to obtain the settings. We use the same defaulting mechanism as"
" for the *name* entry here."
msgstr ""
"Für die eigentliche Treiber-Konfiguration nutzen wir die ``get_value`` "
"Routine, um die Einstellungen zu lesen. Wir nutzen dieselbe Defaultwert "
"Mechanismus wie für den *name* Eintrag hier."

#: ../doc/how-to/table.rst:249
msgid ""
"Note that this example does not propagate back errors but directly calls "
"*error stop*, for a more robust error reporting this can be changed by a "
"small error handle or a context type."
msgstr ""
"Dieses Beispiel gibt keine Fehler zurück, sondern ruft direkt "
"*error stop* auf, um eine robustere Fehlerbehandlung zu ermöglichen, "
"kann dies durch einen kleineren Fehlerbehandlungs-Typ oder einen "
"Kontexttyp implementiert werden."

#: ../doc/how-to/table.rst:253
msgid "The full module implementing the *task_config* reading"
msgstr "Die vollständige Modul-Implementierung um *task_config* zu lesen"
