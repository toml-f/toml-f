var tipuesearch = {"pages":[{"title":" TOML-Fortran ","text":"TOML-Fortran TOML parser for Fortran projects A TOML parser implementation for data serialization and deserialization in Fortran. the TOML standard currently supported TOML v1.0.0 specification TOML Fortran documentation Installation The TOML Fortran library is available via various distribution channels.\nIf your channel is not found here, please checkout the instructions for building from source .\nYou can also find these instructions in the user documentation at Installing TOML Fortran . Conda package This project is packaged for the mamba package manager and available on the conda-forge channel.\nTo install the mamba package manager we recommend the mambaforge installer.\nIf the conda-forge channel is not yet enabled, add it to your channels with mamba config --add channels conda-forge\nmamba config --set channel_priority strict Once the conda-forge channel has been enabled, TOML Fortran can be installed with mamba : mamba install toml-f It is possible to list all of the versions of TOML Fortran available on your platform with mamba : mamba repoquery search toml-f --channel conda-forge FreeBSD port A port for FreeBSD is available and can be installed using pkg install textproc/toml-f In case no package is available build the port using cd /usr/ports/textproc/toml-f\nmake install clean For more information see the toml-f port details . Alternative distributions Please let us know if you are packaging TOML Fortran.\nOther available distributions of TOML Fortran currently include Homebrew tap at grimme-lab/homebrew-qc Easy-build config at easybuilders/easybuild-easyconfigs spack package in develop An overview of the availability of TOML Fortran in distributions tracked by Repology is provided here: Building from source To build this project from the source code in this repository you need to have a Fortran compiler supporting Fortran 2008 GFortran 5 or newer Intel Fortran 18 or newer NAG 7 or newer One of the supported build systems meson version 0.55 or newer CMake version 3.9 or newer Fortran package manager (fpm) version 0.2.0 or newer Get the source by cloning the repository git clone https://github.com/toml-f/toml-f\ncd toml-f Building with meson To integrate TOML Fortran in your meson project checkout the Integrate with meson recipe. To build this project with meson a build-system backend is required, i.e. ninja version 1.7 or newer.\nSetup a build with meson setup _build --prefix=/path/to/install You can select the Fortran compiler by the FC environment variable.\nTo compile the project run meson compile -C _build We employ a validator suite to test the standard compliance of this implementation.\nTo use this testing a go installation is required.\nThe installation of the validator suite will be handled by meson automatically without installing into the users go workspace.\nRun the tests with meson test -C _build --print-errorlogs The binary used for transcribing the TOML documents to the testing format is _build/test/toml2json and can be used to check on per test basis. Finally, you can install TOML Fortran using meson install -C _build Building with CMake To integrate TOML Fortran in your CMake project checkout the Integrate with CMake recipe. While meson is the preferred way to build this project it also offers CMake support.\nConfigure the CMake build with cmake -B _build -G Ninja -DCMAKE_INSTALL_PREFIX=/path/to/install Similar to meson the compiler can be selected with the FC environment variable.\nYou can build the project using cmake --build _build You can run basic unit tests using ctest --test-dir _build The validation suite is currently not supported as unit test for CMake builds and requires a manual setup instead using the toml2json binary. Finally, you can install TOML Fortran using cmake --install _build Building with fpm To integrate TOML Fortran in your fpm project checkout the Using the Fortran package manager recipe. The Fortran package manager ( fpm ) supports the addition of TOML Fortran as a dependency.\nIn the package manifest, fpm.toml , you can add TOML Fortran dependency via: [dependencies] toml-f . git = \"https://github.com/toml-f/toml-f\" Then build and test normally. fpm build\nfpm test A more detailed example is described in example 1 . Documentation The user documentation is available at readthedocs .\nAdditionally, the FORD generated API documentation is available here . To build the user documentation locally we use sphinx, install the dependencies you can use the mamba package manager mamba create -n sphinx --file doc/requirements.txt\nmamba activate sphinx The documentation is build with sphinx-build doc _doc You can inspect the generated documentation by starting a webserver python3 -m http.server -d _doc And open the down URL in a browser. Translating the documentation The documentation of TOML Fortran can be fully translated.\nBefore adding a translation, reach out to the repository maintainers by creating and issue or starting a discussion thread. To start a new translation you need the sphinx-intl package which can be installed with mamba mamba install -n sphinx sphinx-intl To add a new language to the translation extract the text with sphinx-build and create the respective locales with sphinx-intl using the commands shown below. sphinx-build -b gettext doc _gettext\nsphinx-intl update -l en -p _gettext -d doc/locales Replace the argument to the language flag -l with your target language, the language keys are listed here .\nThe same workflow can be used for updating existing locales.\nThe translation files are available in doc/locales and can be translated using a translation-editor, like gtranslator or poedit . After a new translation is merged, a maintainer will create a new translation for the readthedocs to ensure it shows up at the pages. Generating the API docs The API documentation is generated with FORD .\nWe are looking for a better tool to automatically extract the documentation, suggestions and help with this effort are welcome. The required programs can be installed with mamba mamba create -n ford ford\nmamba activate ford To generate the pages use ford docs.md -o _ford You can inspect the generated documentation by starting a webserver python3 -m http.server -d _ford Usage To make use this library use the tomlf module in your projects.\nYou can access the individual modules but those are not considered part of the public API and might change between versions. An example program to load and dump a TOML file would look like this: use tomlf implicit none character ( len =* ), parameter :: nl = new_line ( \"a\" ) type ( toml_table ), allocatable :: table character ( kind = tfc , len = :), allocatable :: input_string type ( toml_serializer ) :: ser input_string = & & '# This is a TOML document.' // nl // & & 'title = \"TOML Example\"' // nl // & & '[owner]' // nl // & & 'name = \"Tom Preston-Werner\"' // nl // & & 'dob = 1979-05-27T07:32:00-08:00 # First class dates' // nl // & & '[database]' // nl // & & 'server = \"192.168.1.1\"' // nl // & & 'ports = [ 8001, 8001, 8002 ]' // nl // & & 'connection_max = 5000' // nl // & & 'enabled = true' // nl // & & '[servers]' // nl // & & '  # Indentation (tabs and/or spaces) is allowed but not required' // nl // & & '  [servers.alpha]' // nl // & & '  ip = \"10.0.0.1\"' // nl // & & '  dc = \"eqdc10\"' // nl // & & '  [servers.beta]' // nl // & & '  ip = \"10.0.0.2\"' // nl // & & '  dc = \"eqdc10\"' // nl // & & '[clients]' // nl // & & 'data = [ [\"gamma\", \"delta\"], [1, 2] ]' // nl // & & '# Line breaks are OK when inside arrays' // nl // & & 'hosts = [' // nl // & & '  \"alpha\",' // nl // & & '  \"omega\"' // nl // & & ']' call toml_loads ( table , input_string ) if ( allocated ( table )) then call table % accept ( ser ) call table % destroy ! not necessary end if end Here the TOML document is provided as string, notice that you have to add a newline character by using the intrinsic function new_line(\"a\") to get the lines correctly. Alternatively, a file can be loaded from any connected, formatted unit using the same overloaded function.\nFor the standard input the intrinsic input_unit should be passed.\nIf the TOML file is successfully parsed the table will be allocated and can be written to the standard output by passing the toml_serializer as visitor to the table. For more details checkout the documentation pages .\nIf you find an error in the documentation or a part is incomplete, please open an issue or start a discussion thread . Contributing This is a volunteer open source projects and contributions are always welcome.\nPlease, take a moment to read the contributing guidelines on how to get involved in TOML-Fortran. License TOML-Fortran is free software: you can redistribute it and/or modify it under the terms of the Apache License, Version 2.0 or MIT license at your opinion. Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an as is basis, without warranties or conditions of any kind, either express or implied. See the License for the specific language governing permissions and limitations under the License. Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in TOML-Fortran by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions. Developer Info Sebastian Ehlert","tags":"home","url":"index.html"},{"title":"toml_key – TOML-Fortran ","text":"type, public :: toml_key Thin wrapper around the deferred-size character intrinisc Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value Source Code type :: toml_key !> Raw representation of the key to the TOML value character ( kind = tfc , len = :), allocatable :: key !> Original source of the value integer :: origin = 0 end type toml_key","tags":"","url":"type/toml_key.html"},{"title":"toml_value – TOML-Fortran ","text":"type, public, abstract :: toml_value Abstract base value for TOML data types Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure private recursive subroutine accept(self, visitor) Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value class( toml_visitor ), intent(inout) :: visitor Visitor for this value procedure(destroy), public, deferred :: destroy Release allocation hold by TOML value subroutine destroy(self) Prototype Deconstructor to cleanup allocations (optional) Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value procedure, public :: get_key Get escaped key to TOML value private  subroutine get_key(self, key) Get escaped key to TOML value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc, len=:), allocatable :: key Contains valid TOML key on exit procedure, public :: match_key Compare raw key of TOML value to input key private pure function match_key(self, key) result(match) Compare raw key of TOML value to input key Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc, len=*), intent(in) :: key TOML raw key to compare to Return Value logical Source Code type , abstract :: toml_value !> Raw representation of the key to the TOML value character ( kind = tfc , len = :), allocatable :: key !> Original source of the value integer :: origin = 0 contains !> Accept a visitor to transverse the data structure procedure :: accept !> Get escaped key to TOML value procedure :: get_key !> Compare raw key of TOML value to input key procedure :: match_key !> Release allocation hold by TOML value procedure ( destroy ), deferred :: destroy end type toml_value","tags":"","url":"type/toml_value.html"},{"title":"toml_visitor – TOML-Fortran ","text":"type, public, abstract :: toml_visitor Abstract visitor for TOML values Type-Bound Procedures procedure(visit), public, deferred :: visit Visitor visiting a TOML value recursive subroutine visit(self, val) Prototype Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_visitor ), intent(inout) :: self Instance of the visitor class( toml_value ), intent(inout) :: val Value to visit Source Code type , abstract :: toml_visitor contains !> Visitor visiting a TOML value procedure ( visit ), deferred :: visit end type toml_visitor","tags":"","url":"type/toml_visitor.html"},{"title":"toml_date – TOML-Fortran ","text":"type, public :: toml_date TOML date value (YYYY-MM-DD) Components Type Visibility Attributes Name Initial integer, public :: day = -1 integer, public :: month = -1 integer, public :: year = -1","tags":"","url":"type/toml_date.html"},{"title":"toml_datetime – TOML-Fortran ","text":"type, public :: toml_datetime TOML datatime value type Components Type Visibility Attributes Name Initial type( toml_date ), public :: date type( toml_time ), public :: time Constructor public        interface toml_datetime Create a new TOML datetime value private pure function new_datetime(year, month, day, hour, minute, second, msecond, zone) result(datetime) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: msecond character(len=*), intent(in), optional :: zone Return Value type( toml_datetime ) private pure function new_datetime_from_string(string) result(datetime) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( toml_datetime )","tags":"","url":"type/toml_datetime.html"},{"title":"toml_time – TOML-Fortran ","text":"type, public :: toml_time TOML time value (HH:MM:SS.sssssZ…) Components Type Visibility Attributes Name Initial integer, public :: hour = -1 integer, public :: minute = -1 integer, public :: msec = -1 integer, public :: second = -1 character(len=:), public, allocatable :: zone Constructor public        interface toml_time private elemental function new_toml_time(hour, minute, second, msec, zone) result(self) Constructor for toml_time type, necessary due to PGI bug in NVHPC 20.7 and 20.9 Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: msec character(len=*), intent(in), optional :: zone Return Value type( toml_time )","tags":"","url":"type/toml_time.html"},{"title":"toml_error – TOML-Fortran ","text":"type, public :: toml_error Error message produced by TOML-Fortran Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: message Payload of the error integer, public :: stat = toml_stat%fatal Error code Source Code type :: toml_error !> Error code integer :: stat = toml_stat % fatal !> Payload of the error character ( kind = tfc , len = :), allocatable :: message end type toml_error","tags":"","url":"type/toml_error.html"},{"title":"toml_array – TOML-Fortran ","text":"type, public, extends( toml_value ) :: toml_array TOML array Components Type Visibility Attributes Name Initial logical, public :: inline = .true. Is an inline array rather than an array of tables character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value Constructor public        interface toml_array Create standard constructor private  function new_array_func() result(self) Default constructor for TOML array type Arguments None Return Value type( toml_array ) Instance of the TOML array Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure private recursive subroutine accept(self, visitor) Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value class( toml_visitor ), intent(inout) :: visitor Visitor for this value procedure, public :: destroy Release allocation hold by TOML array private  subroutine destroy(self) Deconstructor to cleanup allocations (optional) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array procedure, public :: get Get the TOML value at a given index private  subroutine get(self, idx, ptr) Get the TOML value at the respective index Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array integer, intent(in) :: idx Index to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the TOML value procedure, public :: get_key Get escaped key to TOML value private  subroutine get_key(self, key) Get escaped key to TOML value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc, len=:), allocatable :: key Contains valid TOML key on exit procedure, public :: match_key Compare raw key of TOML value to input key private pure function match_key(self, key) result(match) Compare raw key of TOML value to input key Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc, len=*), intent(in) :: key TOML raw key to compare to Return Value logical procedure, public :: pop Remove the last element from the array private  subroutine pop(self, val) Remove the last element from the data structure Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved procedure, public :: push_back Append value to array private  subroutine push_back(self, val, stat) Push back a TOML value to the array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array class( toml_value ), intent(inout), allocatable :: val TOML value to append to array integer, intent(out) :: stat Status of operation procedure, public :: shift Remove the first element from the array private  subroutine shift(self, val) Remove the first element from the data structure Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: self Instance of the TOML array class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved Source Code type , extends ( toml_value ) :: toml_array !> Is an inline array rather than an array of tables logical :: inline = . true . !> Storage unit for TOML values of this array class ( toml_list_structure ), allocatable , private :: list contains !> Get the TOML value at a given index procedure :: get !> Append value to array procedure :: push_back !> Remove the first element from the array procedure :: shift !> Remove the last element from the array procedure :: pop !> Release allocation hold by TOML array procedure :: destroy end type toml_array","tags":"","url":"type/toml_array.html"},{"title":"toml_merge_config – TOML-Fortran ","text":"type, public :: toml_merge_config Configuration for merging data structures Components Type Visibility Attributes Name Initial integer, public :: array = merge_policy%preserve Policy for merging arrays integer, public :: keyval = merge_policy%preserve Policy for merging values integer, public :: table = merge_policy%append Policy for merging tables Constructor public        interface toml_merge_config Constructor for merge configuration private pure function new_merge_config(table, array, keyval) result(config) Create a new merge configuration Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: table Policy for merging tables character(len=*), intent(in), optional :: array Policy for merging arrays character(len=*), intent(in), optional :: keyval Policy for merging values Return Value type( toml_merge_config ) Merge policy Source Code type :: toml_merge_config !> Policy for merging tables integer :: table = merge_policy % append !> Policy for merging arrays integer :: array = merge_policy % preserve !> Policy for merging values integer :: keyval = merge_policy % preserve end type toml_merge_config","tags":"","url":"type/toml_merge_config.html"},{"title":"toml_token – TOML-Fortran ","text":"type, public :: toml_token Token containing Components Type Visibility Attributes Name Initial integer, public :: chunk = 0 Identifier for the chunk index in case of buffered reading integer, public :: first = 0 Starting position of the token in character stream integer, public :: kind = token_kind%newline Kind of token integer, public :: last = 0 Last position of the token in character stream Source Code type :: toml_token !> Kind of token integer :: kind = token_kind % newline !> Starting position of the token in character stream integer :: first = 0 !> Last position of the token in character stream integer :: last = 0 !> Identifier for the chunk index in case of buffered reading integer :: chunk = 0 end type toml_token","tags":"","url":"type/toml_token.html"},{"title":"toml_map_structure – TOML-Fortran ","text":"type, public, abstract :: toml_map_structure Abstract data structure Type-Bound Procedures procedure(delete), public, deferred :: delete Delete TOML value at a given key subroutine delete(self, key) Prototype Delete TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_map_structure ), intent(inout), target :: self Instance of the structure character(kind=tfc, len=*), intent(in) :: key Key to the TOML value procedure(destroy), public, deferred :: destroy Destroy the data structure subroutine destroy(self) Prototype Deconstructor for data structure Arguments Type Intent Optional Attributes Name class( toml_map_structure ), intent(inout), target :: self Instance of the structure procedure(get), public, deferred :: get Get TOML value at a given key subroutine get(self, key, ptr) Prototype Get TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_map_structure ), intent(inout), target :: self Instance of the structure character(kind=tfc, len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given key procedure(get_keys), public, deferred :: get_keys Get list of all keys in the structure subroutine get_keys(self, list) Prototype Get list of all keys in the structure Arguments Type Intent Optional Attributes Name class( toml_map_structure ), intent(inout), target :: self Instance of the structure type( toml_key ), intent(out), allocatable :: list (:) List of all keys procedure(pop), public, deferred :: pop Remove TOML value at a given key and return it subroutine pop(self, key, val) Prototype Remove TOML value at a given key and return it Arguments Type Intent Optional Attributes Name class( toml_map_structure ), intent(inout), target :: self Instance of the structure character(kind=tfc, len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), allocatable :: val Removed TOML value procedure(push_back), public, deferred :: push_back Push back a TOML value to the structure subroutine push_back(self, val) Prototype Push back a TOML value to the structure Arguments Type Intent Optional Attributes Name class( toml_map_structure ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(inout), allocatable :: val TOML value to be stored Source Code type , abstract :: toml_map_structure contains !> Get TOML value at a given key procedure ( get ), deferred :: get !> Push back a TOML value to the structure procedure ( push_back ), deferred :: push_back !> Get list of all keys in the structure procedure ( get_keys ), deferred :: get_keys !> Remove TOML value at a given key and return it procedure ( pop ), deferred :: pop !> Delete TOML value at a given key procedure ( delete ), deferred :: delete !> Destroy the data structure procedure ( destroy ), deferred :: destroy end type toml_map_structure","tags":"","url":"type/toml_map_structure.html"},{"title":"toml_node – TOML-Fortran ","text":"type, public :: toml_node Wrapped TOML value to generate pointer list Components Type Visibility Attributes Name Initial class( toml_value ), public, allocatable :: val TOML value payload Source Code type :: toml_node !> TOML value payload class ( toml_value ), allocatable :: val end type toml_node","tags":"","url":"type/toml_node.html"},{"title":"toml_lexer – TOML-Fortran ","text":"type, public, extends( abstract_lexer ) :: toml_lexer Tokenizer for TOML documents. Components Type Visibility Attributes Name Initial integer, public :: buffer = 0 Index in the buffer queue character(kind=tfc, len=:), public, allocatable :: chunk Current source chunk, for convenience stored as character array rather than string type( toml_context ), public :: context Douple-ended queue for buffering tokens character(len=:), public, allocatable :: filename Name of the source file, used for error reporting integer, public :: pos = 0 Current internal position in the source chunk type(stack_item), public, allocatable :: stack (:) Stack of scopes, used to identify the current state of the lexer integer, public :: top = 0 Last scope of the lexer Type-Bound Procedures generic, public :: extract => extract_string , extract_integer , extract_float , extract_bool , extract_datetime private  subroutine extract_string(lexer, token, string) Extract string value of token, works for keypath, string, multiline string, literal,\nand mulitline literal tokens. Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract string value from character(len=:), intent(out), allocatable :: string String value of token private  subroutine extract_integer(lexer, token, val) Extract integer value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract integer value from integer(kind=tfi), intent(out) :: val Integer value of token private  subroutine extract_float(lexer, token, val) Extract floating point value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract floating point value from real(kind=tfr), intent(out) :: val Floating point value of token private  subroutine extract_bool(lexer, token, val) Extract boolean value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract boolean value from logical, intent(out) :: val Boolean value of token private  subroutine extract_datetime(lexer, token, val) Extract datetime value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract datetime value from type( toml_datetime ), intent(out) :: val Datetime value of token procedure, public :: extract_bool Extract a boolean from a token private  subroutine extract_bool(lexer, token, val) Extract boolean value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract boolean value from logical, intent(out) :: val Boolean value of token procedure, public :: extract_datetime Extract a timestamp from a token private  subroutine extract_datetime(lexer, token, val) Extract datetime value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract datetime value from type( toml_datetime ), intent(out) :: val Datetime value of token procedure, public :: extract_float Extract a float from a token private  subroutine extract_float(lexer, token, val) Extract floating point value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract floating point value from real(kind=tfr), intent(out) :: val Floating point value of token procedure, public :: extract_integer Extract an integer from a token private  subroutine extract_integer(lexer, token, val) Extract integer value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract integer value from integer(kind=tfi), intent(out) :: val Integer value of token procedure, public :: extract_string Extract a string from a token private  subroutine extract_string(lexer, token, string) Extract string value of token, works for keypath, string, multiline string, literal,\nand mulitline literal tokens. Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract string value from character(len=:), intent(out), allocatable :: string String value of token procedure, public :: get_info Get information about source private  subroutine get_info(lexer, meta, output) Extract information about the source Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer character(kind=tfc, len=*), intent(in) :: meta Query about the source character(kind=tfc, len=:), intent(out), allocatable :: output Metadata about the source procedure, public :: next Obtain the next token private  subroutine next(lexer, token) Advance the lexer to the next token. Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(inout) :: lexer Instance of the lexer type( toml_token ), intent(inout) :: token Current lexeme Source Code type , extends ( abstract_lexer ) :: toml_lexer !> Name of the source file, used for error reporting character ( len = :), allocatable :: filename !> Current internal position in the source chunk integer :: pos = 0 !> Current source chunk, for convenience stored as character array rather than string character (:, tfc ), allocatable :: chunk !> Last scope of the lexer integer :: top = 0 !> Stack of scopes, used to identify the current state of the lexer type ( stack_item ), allocatable :: stack (:) !> Index in the buffer queue integer :: buffer = 0 !> Douple-ended queue for buffering tokens type ( toml_context ) :: context contains !> Obtain the next token procedure :: next !> Extract a string from a token procedure :: extract_string !> Extract an integer from a token procedure :: extract_integer !> Extract a float from a token procedure :: extract_float !> Extract a boolean from a token procedure :: extract_bool !> Extract a timestamp from a token procedure :: extract_datetime !> Get information about source procedure :: get_info end type toml_lexer","tags":"","url":"type/toml_lexer.html"},{"title":"toml_diagnostic – TOML-Fortran ","text":"type, public :: toml_diagnostic Definition of diagnostic message Components Type Visibility Attributes Name Initial type( toml_label ), public, allocatable :: label (:) Messages associated with this diagnostic integer, public :: level Level of message character(len=:), public, allocatable :: message Primary message character(len=:), public, allocatable :: source Context of the diagnostic source Constructor public        interface toml_diagnostic private pure function new_diagnostic(level, message, source, label) result(new) Create new diagnostic message Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Level of message character(len=*), intent(in), optional :: message Primary message character(len=*), intent(in), optional :: source Context of the diagnostic source type( toml_label ), intent(in), optional :: label (:) Messages associated with this diagnostic Return Value type( toml_diagnostic ) Source Code type :: toml_diagnostic !> Level of message integer :: level !> Primary message character ( len = :), allocatable :: message !> Context of the diagnostic source character ( len = :), allocatable :: source !> Messages associated with this diagnostic type ( toml_label ), allocatable :: label (:) end type toml_diagnostic","tags":"","url":"type/toml_diagnostic.html"},{"title":"toml_label – TOML-Fortran ","text":"type, public :: toml_label Components Type Visibility Attributes Name Initial integer, public :: first First and last character of message integer, public :: last First and last character of message integer, public :: level Level of message logical, public :: primary Primary message character(len=:), public, allocatable :: source Identifier of context character(len=:), public, allocatable :: text Message text Constructor public        interface toml_label private pure function new_label(level, first, last, text, primary) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level integer, intent(in) :: first integer, intent(in) :: last character(len=*), intent(in), optional :: text logical, intent(in), optional :: primary Return Value type( toml_label ) Source Code type toml_label !> Level of message integer :: level !> Primary message logical :: primary !> First and last character of message integer :: first , last !> Message text character ( len = :), allocatable :: text !> Identifier of context character ( len = :), allocatable :: source end type toml_label","tags":"","url":"type/toml_label.html"},{"title":"toml_array_list – TOML-Fortran ","text":"type, public, extends( toml_list_structure ) :: toml_array_list Stores TOML values in a list of pointers Components Type Visibility Attributes Name Initial type( toml_node ), public, allocatable :: lst (:) List of TOML values integer, public :: n = 0 Current number of stored TOML values Type-Bound Procedures procedure, public :: destroy Destroy the data structure private  subroutine destroy(self) Deconstructor for data structure Arguments Type Intent Optional Attributes Name class( toml_array_list ), intent(inout), target :: self Instance of the structure procedure, public :: get Get TOML value at a given index private  subroutine get(self, idx, ptr) Get TOML value at a given index Arguments Type Intent Optional Attributes Name class( toml_array_list ), intent(inout), target :: self Instance of the structure integer, intent(in) :: idx Position in the ordered structure class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given index procedure, public :: get_len Get number of TOML values in the structure private pure function get_len(self) result(length) Get number of TOML values in the structure Arguments Type Intent Optional Attributes Name class( toml_array_list ), intent(in), target :: self Instance of the structure Return Value integer Current length of the ordered structure procedure, public :: pop Remove the last element from the structure private  subroutine pop(self, val) Remove the last element from the data structure Arguments Type Intent Optional Attributes Name class( toml_array_list ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved procedure, public :: push_back Push back a TOML value to the structure private  subroutine push_back(self, val) Push back a TOML value to the structure Arguments Type Intent Optional Attributes Name class( toml_array_list ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(inout), allocatable :: val TOML value to be stored procedure, public :: shift Remove the first element from the structure private  subroutine shift(self, val) Remove the first element from the data structure Arguments Type Intent Optional Attributes Name class( toml_array_list ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved Source Code type , extends ( toml_list_structure ) :: toml_array_list !> Current number of stored TOML values integer :: n = 0 !> List of TOML values type ( toml_node ), allocatable :: lst (:) contains !> Get number of TOML values in the structure procedure :: get_len !> Get TOML value at a given index procedure :: get !> Push back a TOML value to the structure procedure :: push_back !> Remove the first element from the structure procedure :: shift !> Remove the last element from the structure procedure :: pop !> Destroy the data structure procedure :: destroy end type toml_array_list","tags":"","url":"type/toml_array_list.html"},{"title":"toml_path – TOML-Fortran ","text":"type, public :: toml_path Wrapper for storing key paths Components Type Visibility Attributes Name Initial type( toml_key ), public, allocatable :: path (:) Path components Constructor public        interface toml_path Convenience constructors for building key paths from strings instead of keys private pure function new_path2(key1, key2) result(path) Create a new path with two components Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key1 First key to retrieve character(len=*), intent(in) :: key2 Second key to retrieve Return Value type( toml_path ) New path private pure function new_path3(key1, key2, key3) result(path) Create a new path with three components Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: key1 First key to retrieve character(kind=tfc, len=*), intent(in) :: key2 Second key to retrieve character(kind=tfc, len=*), intent(in) :: key3 Third key to retrieve Return Value type( toml_path ) New path private pure function new_path4(key1, key2, key3, key4) result(path) Create a new path with three components Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: key1 First key to retrieve character(kind=tfc, len=*), intent(in) :: key2 Second key to retrieve character(kind=tfc, len=*), intent(in) :: key3 Third key to retrieve character(kind=tfc, len=*), intent(in) :: key4 Forth key to retrieve Return Value type( toml_path ) New path Source Code type :: toml_path !> Path components type ( toml_key ), allocatable :: path (:) end type toml_path","tags":"","url":"type/toml_path.html"},{"title":"toml_table – TOML-Fortran ","text":"type, public, extends( toml_value ) :: toml_table TOML table Components Type Visibility Attributes Name Initial logical, public :: implicit = .false. Table was implictly created logical, public :: inline = .false. Is an inline table and is therefore non-extendable character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value Constructor public        interface toml_table Create standard constructor private  function new_table_func() result(self) Default constructor for TOML table type Arguments None Return Value type( toml_table ) Instance of the TOML table Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure private recursive subroutine accept(self, visitor) Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value class( toml_visitor ), intent(inout) :: visitor Visitor for this value procedure, public :: delete Delete TOML value at a given key private  subroutine delete(self, key) Delete TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key to the TOML value procedure, public :: destroy Release allocation hold by TOML table private  subroutine destroy(self) Deconstructor to cleanup allocations (optional) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table procedure, public :: get Get the TOML value associated with the respective key private  subroutine get(self, key, ptr) Get the TOML value associated with the respective key Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the TOML value procedure, public :: get_key Get escaped key to TOML value private  subroutine get_key(self, key) Get escaped key to TOML value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc, len=:), allocatable :: key Contains valid TOML key on exit procedure, public :: get_keys Get list of all keys in this table private  subroutine get_keys(self, list) Get list of all keys in this table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table type( toml_key ), intent(out), allocatable :: list (:) List of all keys procedure, public :: has_key Check if key is already present in this table instance private  function has_key(self, key) result(found) Check if a key is present in the table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key to the TOML value Return Value logical TOML value is present in table procedure, public :: match_key Compare raw key of TOML value to input key private pure function match_key(self, key) result(match) Compare raw key of TOML value to input key Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc, len=*), intent(in) :: key TOML raw key to compare to Return Value logical procedure, public :: pop Remove TOML value at a given key and return it private  subroutine pop(self, key, val) Remove TOML value at a given key and return it Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), allocatable :: val Removed TOML value to return procedure, public :: push_back Append value to table (checks automatically for key) private  subroutine push_back(self, val, stat) Push back a TOML value to the table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: self Instance of the TOML table class( toml_value ), intent(inout), allocatable :: val TOML value to append to table integer, intent(out) :: stat Status of operation Source Code type , extends ( toml_value ) :: toml_table !> Table was implictly created logical :: implicit = . false . !> Is an inline table and is therefore non-extendable logical :: inline = . false . !> Storage unit for TOML values of this table class ( toml_map_structure ), allocatable , private :: map contains !> Get the TOML value associated with the respective key procedure :: get !> Get list of all keys in this table procedure :: get_keys !> Check if key is already present in this table instance procedure :: has_key !> Append value to table (checks automatically for key) procedure :: push_back !> Remove TOML value at a given key and return it procedure :: pop !> Delete TOML value at a given key procedure :: delete !> Release allocation hold by TOML table procedure :: destroy end type toml_table","tags":"","url":"type/toml_table.html"},{"title":"ansi_code – TOML-Fortran ","text":"type, public :: ansi_code Container for terminal escape code","tags":"","url":"type/ansi_code.html"},{"title":"toml_terminal – TOML-Fortran ","text":"type, public :: toml_terminal Terminal wrapper to handle color escape sequences, must be initialized with\ncolor support to provide colorful output. Default and uninitialized instances\nwill remain usable but provide only stubs and do not produce colorful output.\nThis behavior is useful for creating applications which can toggle color support. Components Type Visibility Attributes Name Initial type( ansi_code ), public :: bg_black = ansi_code() type( ansi_code ), public :: bg_blue = ansi_code() type( ansi_code ), public :: bg_bright_blue = ansi_code() type( ansi_code ), public :: bg_bright_cyan = ansi_code() type( ansi_code ), public :: bg_bright_green = ansi_code() type( ansi_code ), public :: bg_bright_magenta = ansi_code() type( ansi_code ), public :: bg_bright_red = ansi_code() type( ansi_code ), public :: bg_bright_white = ansi_code() type( ansi_code ), public :: bg_bright_yellow = ansi_code() type( ansi_code ), public :: bg_cyan = ansi_code() type( ansi_code ), public :: bg_gray = ansi_code() type( ansi_code ), public :: bg_green = ansi_code() type( ansi_code ), public :: bg_magenta = ansi_code() type( ansi_code ), public :: bg_red = ansi_code() type( ansi_code ), public :: bg_white = ansi_code() type( ansi_code ), public :: bg_yellow = ansi_code() type( ansi_code ), public :: black = ansi_code() type( ansi_code ), public :: blink = ansi_code() type( ansi_code ), public :: blink_rapid = ansi_code() type( ansi_code ), public :: blue = ansi_code() type( ansi_code ), public :: bold = ansi_code() type( ansi_code ), public :: bright_blue = ansi_code() type( ansi_code ), public :: bright_cyan = ansi_code() type( ansi_code ), public :: bright_green = ansi_code() type( ansi_code ), public :: bright_magenta = ansi_code() type( ansi_code ), public :: bright_red = ansi_code() type( ansi_code ), public :: bright_white = ansi_code() type( ansi_code ), public :: bright_yellow = ansi_code() type( ansi_code ), public :: crossed = ansi_code() type( ansi_code ), public :: cyan = ansi_code() type( ansi_code ), public :: dim = ansi_code() type( ansi_code ), public :: gray = ansi_code() type( ansi_code ), public :: green = ansi_code() type( ansi_code ), public :: hidden = ansi_code() type( ansi_code ), public :: italic = ansi_code() type( ansi_code ), public :: magenta = ansi_code() type( ansi_code ), public :: red = ansi_code() type( ansi_code ), public :: reset = ansi_code() type( ansi_code ), public :: reverse = ansi_code() type( ansi_code ), public :: underline = ansi_code() type( ansi_code ), public :: white = ansi_code() type( ansi_code ), public :: yellow = ansi_code() Constructor public        interface toml_terminal Constructor to create new terminal private pure function new_terminal(use_color) result(new) Create new terminal Arguments Type Intent Optional Attributes Name logical, intent(in) :: use_color Enable color support in terminal Return Value type( toml_terminal ) New terminal instance Source Code type :: toml_terminal type ( ansi_code ) :: & reset = ansi_code (), & bold = ansi_code (), & dim = ansi_code (), & italic = ansi_code (), & underline = ansi_code (), & blink = ansi_code (), & blink_rapid = ansi_code (), & reverse = ansi_code (), & hidden = ansi_code (), & crossed = ansi_code () type ( ansi_code ) :: & black = ansi_code (), & red = ansi_code (), & green = ansi_code (), & yellow = ansi_code (), & blue = ansi_code (), & magenta = ansi_code (), & cyan = ansi_code (), & white = ansi_code (), & gray = ansi_code (), & bright_red = ansi_code (), & bright_green = ansi_code (), & bright_yellow = ansi_code (), & bright_blue = ansi_code (), & bright_magenta = ansi_code (), & bright_cyan = ansi_code (), & bright_white = ansi_code () type ( ansi_code ) :: & bg_black = ansi_code (), & bg_red = ansi_code (), & bg_green = ansi_code (), & bg_yellow = ansi_code (), & bg_blue = ansi_code (), & bg_magenta = ansi_code (), & bg_cyan = ansi_code (), & bg_white = ansi_code (), & bg_gray = ansi_code (), & bg_bright_red = ansi_code (), & bg_bright_green = ansi_code (), & bg_bright_yellow = ansi_code (), & bg_bright_blue = ansi_code (), & bg_bright_magenta = ansi_code (), & bg_bright_cyan = ansi_code (), & bg_bright_white = ansi_code () end type toml_terminal","tags":"","url":"type/toml_terminal.html"},{"title":"toml_ordered_map – TOML-Fortran ","text":"type, public, extends( toml_map_structure ) :: toml_ordered_map Stores TOML values in a list of pointers Components Type Visibility Attributes Name Initial type( toml_node ), public, allocatable :: lst (:) List of TOML values integer, public :: n = 0 Current number of stored TOML values Type-Bound Procedures procedure, public :: delete Delete TOML value at a given key private  subroutine delete(self, key) Delete TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_ordered_map ), intent(inout), target :: self Instance of the structure character(kind=tfc, len=*), intent(in) :: key Key to the TOML value procedure, public :: destroy Destroy the data structure private  subroutine destroy(self) Deconstructor for data structure Arguments Type Intent Optional Attributes Name class( toml_ordered_map ), intent(inout), target :: self Instance of the structure procedure, public :: get Get TOML value at a given key private  subroutine get(self, key, ptr) Get TOML value at a given key Arguments Type Intent Optional Attributes Name class( toml_ordered_map ), intent(inout), target :: self Instance of the structure character(kind=tfc, len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given key procedure, public :: get_keys Get list of all keys in the structure private  subroutine get_keys(self, list) Get list of all keys in the structure Arguments Type Intent Optional Attributes Name class( toml_ordered_map ), intent(inout), target :: self Instance of the structure type( toml_key ), intent(out), allocatable :: list (:) List of all keys procedure, public :: pop Remove TOML value at a given key and return it private  subroutine pop(self, key, val) Remove TOML value at a given key and return it Arguments Type Intent Optional Attributes Name class( toml_ordered_map ), intent(inout), target :: self Instance of the structure character(kind=tfc, len=*), intent(in) :: key Key to the TOML value class( toml_value ), intent(out), allocatable :: val Removed TOML value procedure, public :: push_back Push back a TOML value to the structure private  subroutine push_back(self, val) Push back a TOML value to the structure Arguments Type Intent Optional Attributes Name class( toml_ordered_map ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(inout), allocatable :: val TOML value to be stored Source Code type , extends ( toml_map_structure ) :: toml_ordered_map !> Current number of stored TOML values integer :: n = 0 !> List of TOML values type ( toml_node ), allocatable :: lst (:) contains !> Get TOML value at a given key procedure :: get !> Push back a TOML value to the structure procedure :: push_back !> Remove TOML value at a given key and return it procedure :: pop !> Get list of all keys in the structure procedure :: get_keys !> Delete TOML value at a given key procedure :: delete !> Destroy the data structure procedure :: destroy end type toml_ordered_map","tags":"","url":"type/toml_ordered_map.html"},{"title":"toml_keyval – TOML-Fortran ","text":"type, public, extends( toml_value ) :: toml_keyval TOML key-value pair Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value integer, public :: origin_value = 0 Origin of value class(generic_value), public, allocatable :: val Actual TOML value Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure private recursive subroutine accept(self, visitor) Accept a visitor to transverse the data structure Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: self Instance of the TOML value class( toml_visitor ), intent(inout) :: visitor Visitor for this value procedure, public :: destroy Release allocation hold by TOML key-value pair private  subroutine destroy(self) Deconstructor to cleanup allocations (optional) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair generic, public :: get => get_float , get_integer , get_boolean , get_datetime , get_string Get the value stored in the key-value pair private  subroutine get_float(self, val) Obtain real value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair real(kind=tfr), intent(out), pointer :: val Value to be assigned private  subroutine get_integer(self, val) Obtain integer value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair integer(kind=tfi), intent(out), pointer :: val Value to be assigned private  subroutine get_boolean(self, val) Obtain boolean value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair logical, intent(out), pointer :: val Value to be assigned private  subroutine get_datetime(self, val) Obtain datetime value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair type( toml_datetime ), intent(out), pointer :: val Value to be assigned private  subroutine get_string(self, val) Obtain datetime value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair character(kind=tfc, len=:), intent(out), pointer :: val Value to be assigned procedure, public :: get_boolean private  subroutine get_boolean(self, val) Obtain boolean value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair logical, intent(out), pointer :: val Value to be assigned procedure, public :: get_datetime private  subroutine get_datetime(self, val) Obtain datetime value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair type( toml_datetime ), intent(out), pointer :: val Value to be assigned procedure, public :: get_float private  subroutine get_float(self, val) Obtain real value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair real(kind=tfr), intent(out), pointer :: val Value to be assigned procedure, public :: get_integer private  subroutine get_integer(self, val) Obtain integer value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair integer(kind=tfi), intent(out), pointer :: val Value to be assigned procedure, public :: get_key Get escaped key to TOML value private  subroutine get_key(self, key) Get escaped key to TOML value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc, len=:), allocatable :: key Contains valid TOML key on exit procedure, public :: get_string private  subroutine get_string(self, val) Obtain datetime value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair character(kind=tfc, len=:), intent(out), pointer :: val Value to be assigned procedure, public :: get_type Get the type of the value stored in the key-value pair private pure function get_type(self) result(value_type) Get the type of the value stored in the key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the TOML key-value pair Return Value integer Value type procedure, public :: match_key Compare raw key of TOML value to input key private pure function match_key(self, key) result(match) Compare raw key of TOML value to input key Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in) :: self TOML value instance. character(kind=tfc, len=*), intent(in) :: key TOML raw key to compare to Return Value logical generic, public :: set => set_float , set_integer , set_boolean , set_datetime , set_string Set the value for the key-value pair private  subroutine set_float(self, val) Obtain real value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair real(kind=tfr), intent(in) :: val Value to be assigned private  subroutine set_integer(self, val) Obtain integer value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair integer(kind=tfi), intent(in) :: val Value to be assigned private  subroutine set_boolean(self, val) Obtain boolean value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair logical, intent(in) :: val Value to be assigned private  subroutine set_datetime(self, val) Obtain datetime value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair type( toml_datetime ), intent(in) :: val Value to be assigned private  subroutine set_string(self, val) Obtain datetime value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair character(kind=tfc, len=*), intent(in) :: val Value to be assigned procedure, public :: set_boolean private  subroutine set_boolean(self, val) Obtain boolean value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair logical, intent(in) :: val Value to be assigned procedure, public :: set_datetime private  subroutine set_datetime(self, val) Obtain datetime value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair type( toml_datetime ), intent(in) :: val Value to be assigned procedure, public :: set_float private  subroutine set_float(self, val) Obtain real value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair real(kind=tfr), intent(in) :: val Value to be assigned procedure, public :: set_integer private  subroutine set_integer(self, val) Obtain integer value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair integer(kind=tfi), intent(in) :: val Value to be assigned procedure, public :: set_string private  subroutine set_string(self, val) Obtain datetime value from TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the TOML key-value pair character(kind=tfc, len=*), intent(in) :: val Value to be assigned Source Code type , extends ( toml_value ) :: toml_keyval !> Actual TOML value class ( generic_value ), allocatable :: val !> Origin of value integer :: origin_value = 0 contains !> Get the value stored in the key-value pair generic :: get => get_float , get_integer , get_boolean , get_datetime , get_string procedure :: get_float procedure :: get_integer procedure :: get_boolean procedure :: get_datetime procedure :: get_string !> Set the value for the key-value pair generic :: set => set_float , set_integer , set_boolean , set_datetime , set_string procedure :: set_float procedure :: set_integer procedure :: set_boolean procedure :: set_datetime procedure :: set_string !> Get the type of the value stored in the key-value pair procedure :: get_type !> Release allocation hold by TOML key-value pair procedure :: destroy end type toml_keyval","tags":"","url":"type/toml_keyval.html"},{"title":"toml_serializer – TOML-Fortran ","text":"type, public, extends( toml_visitor ) :: toml_serializer TOML serializer to produduce a TOML document from a datastructure Constructor public        interface toml_serializer Create standard constructor private  function new_serializer_func(config) result(self) Default constructor for TOML serializer Arguments Type Intent Optional Attributes Name type(toml_ser_config), intent(in), optional :: config Configuration for serializer Return Value type( toml_serializer ) Instance of the TOML serializer Type-Bound Procedures procedure, public :: visit Visit a TOML value private recursive subroutine visit(self, val) Visit a TOML value Arguments Type Intent Optional Attributes Name class( toml_serializer ), intent(inout) :: self Instance of the TOML serializer class( toml_value ), intent(inout) :: val TOML value to visit Source Code type , extends ( toml_visitor ) :: toml_serializer private !> Output string character (:), allocatable :: output !> Configuration for serializer type ( toml_ser_config ) :: config = toml_ser_config () !> Special mode for printing array of tables logical , private :: array_of_tables = . false . !> Special mode for printing inline arrays logical , private :: inline_array = . false . !> Top of the key stack integer , private :: top = 0 !> Key stack to create table headers type ( toml_key ), allocatable , private :: stack (:) contains !> Visit a TOML value procedure :: visit end type toml_serializer","tags":"","url":"type/toml_serializer.html"},{"title":"abstract_lexer – TOML-Fortran ","text":"type, public, abstract :: abstract_lexer Abstract base class for TOML lexers. Type-Bound Procedures generic, public :: extract => extract_string , extract_integer , extract_float , extract_bool , extract_datetime Extract a token private  subroutine extract_string(lexer, token, string) Extract string value of token, works for keypath, string, multiline string, literal,\nand mulitline literal tokens. Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract string value from character(len=:), intent(out), allocatable :: string String value of token private  subroutine extract_integer(lexer, token, val) Extract integer value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract integer value from integer(kind=tfi), intent(out) :: val Integer value of token private  subroutine extract_float(lexer, token, val) Extract floating point value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract floating point value from real(kind=tfr), intent(out) :: val Floating point value of token private  subroutine extract_bool(lexer, token, val) Extract boolean value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract boolean value from logical, intent(out) :: val Boolean value of token private  subroutine extract_datetime(lexer, token, val) Extract datetime value of token Arguments Type Intent Optional Attributes Name class( toml_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract datetime value from type( toml_datetime ), intent(out) :: val Datetime value of token procedure(extract_bool), public, deferred :: extract_bool Extract a boolean from a token subroutine extract_bool(lexer, token, val) Prototype Extract boolean value of token Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract boolean value from logical, intent(out) :: val Boolean value of token procedure(extract_datetime), public, deferred :: extract_datetime Extract a timestamp from a token subroutine extract_datetime(lexer, token, val) Prototype Extract datetime value of token Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract datetime value from type( toml_datetime ), intent(out) :: val Datetime value of token procedure(extract_float), public, deferred :: extract_float Extract a float from a token subroutine extract_float(lexer, token, val) Prototype Extract floating point value of token Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract floating point value from real(kind=tfr), intent(out) :: val Floating point value of token procedure(extract_integer), public, deferred :: extract_integer Extract an integer from a token subroutine extract_integer(lexer, token, val) Prototype Extract integer value of token Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract integer value from integer(kind=tfi), intent(out) :: val Integer value of token procedure(extract_string), public, deferred :: extract_string Extract a string from a token subroutine extract_string(lexer, token, string) Prototype Extract string value of token, works for keypath, string, multiline string, literal,\nand mulitline literal tokens. Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(in) :: lexer Instance of the lexer type( toml_token ), intent(in) :: token Token to extract string value from character(kind=tfc, len=:), intent(out), allocatable :: string String value of token procedure(get_info), public, deferred :: get_info Get information about the source subroutine get_info(lexer, meta, output) Prototype Extract information about the source Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(in) :: lexer Instance of the lexer character(kind=tfc, len=*), intent(in) :: meta Query about the source character(kind=tfc, len=:), intent(out), allocatable :: output Metadata about the source procedure(next), public, deferred :: next Obtain the next token subroutine next(lexer, token) Prototype Advance the lexer to the next token. Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(inout) :: lexer Instance of the lexer type( toml_token ), intent(inout) :: token Current lexeme Source Code type , abstract :: abstract_lexer contains !> Obtain the next token procedure ( next ), deferred :: next !> Extract a token generic :: extract => & & extract_string , extract_integer , extract_float , extract_bool , extract_datetime !> Extract a string from a token procedure ( extract_string ), deferred :: extract_string !> Extract an integer from a token procedure ( extract_integer ), deferred :: extract_integer !> Extract a float from a token procedure ( extract_float ), deferred :: extract_float !> Extract a boolean from a token procedure ( extract_bool ), deferred :: extract_bool !> Extract a timestamp from a token procedure ( extract_datetime ), deferred :: extract_datetime !> Get information about the source procedure ( get_info ), deferred :: get_info end type abstract_lexer","tags":"","url":"type/abstract_lexer.html"},{"title":"toml_parser – TOML-Fortran ","text":"type, public :: toml_parser TOML parser Components Type Visibility Attributes Name Initial type( toml_parser_config ), public :: config Configuration of the parser type( toml_context ), public :: context Context for producing diagnostics type( toml_table ), public, pointer :: current Pointer to the currently processed table type( toml_diagnostic ), public, allocatable :: diagnostic Diagnostic produced while parsing type( toml_table ), public, allocatable :: root Table containing the document root type( toml_token ), public :: token Current token Source Code type :: toml_parser !> Current token type ( toml_token ) :: token !> Table containing the document root type ( toml_table ), allocatable :: root !> Pointer to the currently processed table type ( toml_table ), pointer :: current !> Diagnostic produced while parsing type ( toml_diagnostic ), allocatable :: diagnostic !> Context for producing diagnostics type ( toml_context ) :: context !> Configuration of the parser type ( toml_parser_config ) :: config end type toml_parser","tags":"","url":"type/toml_parser.html"},{"title":"toml_parser_config – TOML-Fortran ","text":"type, public :: toml_parser_config Configuration of the TOML parser Components Type Visibility Attributes Name Initial type( toml_terminal ), public :: color = toml_terminal() Use colorful output for diagnostics integer, public :: context_detail = 0 Record all tokens Constructor public        interface toml_parser_config private pure function new_parser_config(color, context_detail) result(config) Create new configuration for the TOML parser Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: color Color support for diagnostics integer, intent(in), optional :: context_detail Record all tokens Return Value type( toml_parser_config ) Configuration of the parser Source Code type :: toml_parser_config !> Use colorful output for diagnostics type ( toml_terminal ) :: color = toml_terminal () !> Record all tokens integer :: context_detail = 0 end type toml_parser_config","tags":"","url":"type/toml_parser_config.html"},{"title":"toml_list_structure – TOML-Fortran ","text":"type, public, abstract :: toml_list_structure Ordered data structure, allows iterations Type-Bound Procedures procedure(destroy), public, deferred :: destroy Destroy the data structure subroutine destroy(self) Prototype Deconstructor for data structure Arguments Type Intent Optional Attributes Name class( toml_list_structure ), intent(inout), target :: self Instance of the structure procedure(get), public, deferred :: get Get TOML value at a given index subroutine get(self, idx, ptr) Prototype Get TOML value at a given index Arguments Type Intent Optional Attributes Name class( toml_list_structure ), intent(inout), target :: self Instance of the structure integer, intent(in) :: idx Position in the ordered structure class( toml_value ), intent(out), pointer :: ptr Pointer to the stored value at given index procedure(get_len), public, deferred :: get_len Get number of TOML values in the structure pure function get_len(self) result(length) Prototype Get number of TOML values in the structure Arguments Type Intent Optional Attributes Name class( toml_list_structure ), intent(in), target :: self Instance of the structure Return Value integer Current length of the ordered structure procedure(pop), public, deferred :: pop Remove the last element from the structure subroutine pop(self, val) Prototype Remove the last element from the data structure Arguments Type Intent Optional Attributes Name class( toml_list_structure ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved procedure(push_back), public, deferred :: push_back Push back a TOML value to the structure subroutine push_back(self, val) Prototype Push back a TOML value to the structure Arguments Type Intent Optional Attributes Name class( toml_list_structure ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(inout), allocatable :: val TOML value to be stored procedure(shift), public, deferred :: shift Remove the first element from the structure subroutine shift(self, val) Prototype Remove the first element from the data structure Arguments Type Intent Optional Attributes Name class( toml_list_structure ), intent(inout), target :: self Instance of the structure class( toml_value ), intent(out), allocatable :: val TOML value to be retrieved Source Code type , abstract :: toml_list_structure contains !> Get number of TOML values in the structure procedure ( get_len ), deferred :: get_len !> Push back a TOML value to the structure procedure ( push_back ), deferred :: push_back !> Remove the first element from the structure procedure ( shift ), deferred :: shift !> Remove the last element from the structure procedure ( pop ), deferred :: pop !> Get TOML value at a given index procedure ( get ), deferred :: get !> Destroy the data structure procedure ( destroy ), deferred :: destroy end type toml_list_structure","tags":"","url":"type/toml_list_structure.html"},{"title":"toml_context – TOML-Fortran ","text":"type, public :: toml_context Container storing tokens Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: filename Filename of the input character(kind=tfc, len=:), public, allocatable :: source Actual source type( toml_token ), public, allocatable :: token (:) Stack of stored tokens integer, public :: top = 0 Last stored token Type-Bound Procedures procedure, public :: push_back Push a new token to the stack private  subroutine push_back(self, token) Push a new token to the stack Arguments Type Intent Optional Attributes Name class( toml_context ), intent(inout) :: self Instance of the token storage type( toml_token ), intent(in) :: token New token to be added generic, public :: report => report1 , report2 Create a report private pure function report1(self, message, origin, label, level, color) result(string) Create a report with a single label Arguments Type Intent Optional Attributes Name class( toml_context ), intent(in) :: self Instance of the token storage character(kind=tfc, len=*), intent(in) :: message Message for the report integer, intent(in) :: origin Position to report at character(kind=tfc, len=*), intent(in), optional :: label String for the label integer, intent(in), optional :: level Highlight level type( toml_terminal ), intent(in), optional :: color Color terminal Return Value character(kind=tfc, len=:), allocatable Final rendered report private pure function report2(self, message, origin1, origin2, label1, label2, level1, level2, color) result(string) Create a report with two labels Arguments Type Intent Optional Attributes Name class( toml_context ), intent(in) :: self Instance of the token storage character(kind=tfc, len=*), intent(in) :: message Message for the report integer, intent(in) :: origin1 Position to report at integer, intent(in) :: origin2 Position to report at character(kind=tfc, len=*), intent(in), optional :: label1 String for the label character(kind=tfc, len=*), intent(in), optional :: label2 String for the label integer, intent(in), optional :: level1 Highlight level integer, intent(in), optional :: level2 Highlight level type( toml_terminal ), intent(in), optional :: color Color terminal Return Value character(kind=tfc, len=:), allocatable Final rendered report procedure, public :: report1 Create a report with a single label private pure function report1(self, message, origin, label, level, color) result(string) Create a report with a single label Arguments Type Intent Optional Attributes Name class( toml_context ), intent(in) :: self Instance of the token storage character(kind=tfc, len=*), intent(in) :: message Message for the report integer, intent(in) :: origin Position to report at character(kind=tfc, len=*), intent(in), optional :: label String for the label integer, intent(in), optional :: level Highlight level type( toml_terminal ), intent(in), optional :: color Color terminal Return Value character(kind=tfc, len=:), allocatable Final rendered report procedure, public :: report2 Create a report with a two labels private pure function report2(self, message, origin1, origin2, label1, label2, level1, level2, color) result(string) Create a report with two labels Arguments Type Intent Optional Attributes Name class( toml_context ), intent(in) :: self Instance of the token storage character(kind=tfc, len=*), intent(in) :: message Message for the report integer, intent(in) :: origin1 Position to report at integer, intent(in) :: origin2 Position to report at character(kind=tfc, len=*), intent(in), optional :: label1 String for the label character(kind=tfc, len=*), intent(in), optional :: label2 String for the label integer, intent(in), optional :: level1 Highlight level integer, intent(in), optional :: level2 Highlight level type( toml_terminal ), intent(in), optional :: color Color terminal Return Value character(kind=tfc, len=:), allocatable Final rendered report Source Code type :: toml_context !> Filename of the input character (:, tfc ), allocatable :: filename !> Actual source character (:, tfc ), allocatable :: source !> Stack of stored tokens type ( toml_token ), allocatable :: token (:) !> Last stored token integer :: top = 0 contains !> Push a new token to the stack procedure :: push_back !> Create a report generic :: report => report1 , report2 !> Create a report with a single label procedure :: report1 !> Create a report with a two labels procedure :: report2 end type toml_context","tags":"","url":"type/toml_context.html"},{"title":"compare_less – TOML-Fortran","text":"interface public pure function compare_less(lhs, rhs) result(less) Arguments Type Intent Optional Attributes Name type( toml_key ), intent(in) :: lhs Left hand side TOML key in comparison type( toml_key ), intent(in) :: rhs Right hand side TOML key in comparison Return Value logical Comparison result Description Define order relation between two TOML keys","tags":"","url":"interface/compare_less.html"},{"title":"has_date – TOML-Fortran","text":"public pure function has_date(datetime) Arguments Type Intent Optional Attributes Name class( toml_datetime ), intent(in) :: datetime Return Value logical Source Code pure function has_date ( datetime ) class ( toml_datetime ), intent ( in ) :: datetime logical :: has_date has_date = ( datetime % date % year >= 0 ) . and . & & ( datetime % date % month >= 0 ) . and . & & ( datetime % date % day >= 0 ) end function has_date","tags":"","url":"proc/has_date.html"},{"title":"has_time – TOML-Fortran","text":"public pure function has_time(datetime) Arguments Type Intent Optional Attributes Name class( toml_datetime ), intent(in) :: datetime Return Value logical Source Code pure function has_time ( datetime ) class ( toml_datetime ), intent ( in ) :: datetime logical :: has_time has_time = ( datetime % time % hour >= 0 ) . and . & & ( datetime % time % minute >= 0 ) . and . & & ( datetime % time % second >= 0 ) end function has_time","tags":"","url":"proc/has_time.html"},{"title":"operator(==) – TOML-Fortran","text":"public interface operator(==) Module Procedures private pure function compare_datetime(lhs, rhs) result(match) Arguments Type Intent Optional Attributes Name type( toml_datetime ), intent(in) :: lhs type( toml_datetime ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(==).html"},{"title":"to_string – TOML-Fortran","text":"public interface to_string Module Procedures private pure function to_string_datetime(datetime) result(str) Arguments Type Intent Optional Attributes Name type( toml_datetime ), intent(in) :: datetime Return Value character(kind=tfc, len=:), allocatable","tags":"","url":"interface/to_string.html"},{"title":"toml_datetime – TOML-Fortran","text":"public interface toml_datetime Create a new TOML datetime value Module Procedures private pure function new_datetime(year, month, day, hour, minute, second, msecond, zone) result(datetime) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: msecond character(len=*), intent(in), optional :: zone Return Value type( toml_datetime ) private pure function new_datetime_from_string(string) result(datetime) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( toml_datetime )","tags":"","url":"interface/toml_datetime.html"},{"title":"toml_time – TOML-Fortran","text":"public interface toml_time Module Procedures private elemental function new_toml_time(hour, minute, second, msec, zone) result(self) Constructor for toml_time type, necessary due to PGI bug in NVHPC 20.7 and 20.9 Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: msec character(len=*), intent(in), optional :: zone Return Value type( toml_time )","tags":"","url":"interface/toml_time.html"},{"title":"make_error – TOML-Fortran","text":"public  subroutine make_error(error, message, stat) Create new error message Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Error report character(kind=tfc, len=*), intent(in) :: message Message for the error integer, intent(in), optional :: stat Status code Source Code subroutine make_error ( error , message , stat ) !> Error report type ( toml_error ), allocatable , intent ( out ) :: error !> Message for the error character ( * , tfc ), intent ( in ) :: message !> Status code integer , intent ( in ), optional :: stat allocate ( error ) error % message = message if ( present ( stat )) then error % stat = stat else error % stat = toml_stat % fatal end if end subroutine make_error","tags":"","url":"proc/make_error.html"},{"title":"new_array – TOML-Fortran","text":"public  subroutine new_array(self) Constructor to create a new TOML array and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_array ), intent(out) :: self Instance of the TOML array Source Code subroutine new_array ( self ) !> Instance of the TOML array type ( toml_array ), intent ( out ) :: self call new_list_structure ( self % list ) end subroutine new_array","tags":"","url":"proc/new_array.html"},{"title":"initialized – TOML-Fortran","text":"public interface initialized Check whether data structure is initialized properly Module Procedures private pure function array_initialized(self) result(okay) Check whether data structure is initialized properly Arguments Type Intent Optional Attributes Name type( toml_array ), intent(in) :: self Instance of the TOML array Return Value logical Data structure is initialized","tags":"","url":"interface/initialized.html"},{"title":"len – TOML-Fortran","text":"public interface len Overload len function Module Procedures private pure function get_len(self) result(length) Get number of TOML values in the array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(in) :: self Instance of the TOML array Return Value integer Current length of the array","tags":"","url":"interface/len.html"},{"title":"new – TOML-Fortran","text":"public interface new Overloaded constructor for TOML values Module Procedures public  subroutine new_array (self) Constructor to create a new TOML array and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_array ), intent(out) :: self Instance of the TOML array","tags":"","url":"interface/new.html"},{"title":"toml_array – TOML-Fortran","text":"public interface toml_array Create standard constructor Module Procedures private  function new_array_func() result(self) Default constructor for TOML array type Arguments None Return Value type( toml_array ) Instance of the TOML array","tags":"","url":"interface/toml_array.html"},{"title":"merge_array – TOML-Fortran","text":"public recursive subroutine merge_array(lhs, rhs) Append values from one TOML array to another Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: lhs Instance of array to merge into class( toml_array ), intent(inout) :: rhs Instance of array to be merged Source Code recursive subroutine merge_array ( lhs , rhs ) !> Instance of array to merge into class ( toml_array ), intent ( inout ) :: lhs !> Instance of array to be merged class ( toml_array ), intent ( inout ) :: rhs class ( toml_value ), pointer :: ptr class ( toml_value ), allocatable :: tmp integer :: n , i , stat n = len ( rhs ) do i = 1 , n call rhs % get ( i , ptr ) if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp , source = ptr ) call lhs % push_back ( tmp , stat ) end do end subroutine merge_array","tags":"","url":"proc/merge_array.html"},{"title":"merge_table – TOML-Fortran","text":"public recursive subroutine merge_table(lhs, rhs, config) Merge TOML tables by appending their values Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: lhs Instance of table to merge into class( toml_table ), intent(inout) :: rhs Instance of table to be merged type( toml_merge_config ), intent(in), optional :: config Merge policy Source Code recursive subroutine merge_table ( lhs , rhs , config ) !> Instance of table to merge into class ( toml_table ), intent ( inout ) :: lhs !> Instance of table to be merged class ( toml_table ), intent ( inout ) :: rhs !> Merge policy type ( toml_merge_config ), intent ( in ), optional :: config type ( toml_merge_config ) :: policy type ( toml_key ), allocatable :: list (:) class ( toml_value ), pointer :: ptr1 , ptr2 class ( toml_keyval ), pointer :: kv class ( toml_value ), allocatable :: tmp logical :: has_key integer :: i , n , stat policy = toml_merge_config () if ( present ( config )) policy = config call rhs % get_keys ( list ) n = size ( list , 1 ) do i = 1 , n if ( allocated ( tmp )) deallocate ( tmp ) call rhs % get ( list ( i )% key , ptr1 ) has_key = lhs % has_key ( list ( i )% key ) select type ( ptr1 ) class is ( toml_keyval ) if ( has_key . and . policy % keyval == merge_policy % overwrite ) then call lhs % delete ( list ( i )% key ) has_key = . false . end if if (. not . has_key ) then allocate ( tmp , source = ptr1 ) kv => cast_to_keyval ( tmp ) kv % origin_value = 0 kv % origin = 0 call lhs % push_back ( tmp , stat ) end if class is ( toml_array ) if ( has_key . and . policy % array == merge_policy % overwrite ) then call lhs % delete ( list ( i )% key ) has_key = . false . end if if ( has_key . and . policy % array == merge_policy % append ) then call lhs % get ( list ( i )% key , ptr2 ) select type ( ptr2 ) class is ( toml_array ) call merge_array ( ptr2 , ptr1 ) end select end if if (. not . has_key ) then allocate ( tmp , source = ptr1 ) tmp % origin = 0 call lhs % push_back ( tmp , stat ) end if class is ( toml_table ) if ( has_key . and . policy % table == merge_policy % overwrite ) then call lhs % delete ( list ( i )% key ) has_key = . false . end if if ( has_key . and . policy % table == merge_policy % append ) then call lhs % get ( list ( i )% key , ptr2 ) select type ( ptr2 ) class is ( toml_table ) call merge_table ( ptr2 , ptr1 , policy ) end select end if if (. not . has_key ) then allocate ( tmp , source = ptr1 ) tmp % origin = 0 call lhs % push_back ( tmp , stat ) end if end select end do end subroutine merge_table","tags":"","url":"proc/merge_table.html"},{"title":"toml_merge_config – TOML-Fortran","text":"public interface toml_merge_config Constructor for merge configuration Module Procedures private pure function new_merge_config(table, array, keyval) result(config) Create a new merge configuration Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: table Policy for merging tables character(len=*), intent(in), optional :: array Policy for merging arrays character(len=*), intent(in), optional :: keyval Policy for merging values Return Value type( toml_merge_config ) Merge policy","tags":"","url":"interface/toml_merge_config.html"},{"title":"stringify – TOML-Fortran","text":"public pure function stringify(token) result(str) Represent a token as string Arguments Type Intent Optional Attributes Name type( toml_token ), intent(in) :: token Token to represent as string Return Value character(len=:), allocatable String representation of token Source Code pure function stringify ( token ) result ( str ) !> Token to represent as string type ( toml_token ), intent ( in ) :: token !> String representation of token character ( len = :), allocatable :: str select case ( token % kind ) case default ; str = \"unknown\" case ( token_kind % invalid ); str = \"invalid sequence\" case ( token_kind % eof ); str = \"end of file\" case ( token_kind % unclosed ); str = \"unclosed group\" case ( token_kind % whitespace ); str = \"whitespace\" case ( token_kind % comment ); str = \"comment\" case ( token_kind % newline ); str = \"newline\" case ( token_kind % dot ); str = \"dot\" case ( token_kind % comma ); str = \"comma\" case ( token_kind % equal ); str = \"equal\" case ( token_kind % lbrace ); str = \"opening brace\" case ( token_kind % rbrace ); str = \"closing brace\" case ( token_kind % lbracket ); str = \"opening bracket\" case ( token_kind % rbracket ); str = \"closing bracket\" case ( token_kind % string ); str = \"string\" case ( token_kind % mstring ); str = \"multiline string\" case ( token_kind % literal ); str = \"literal\" case ( token_kind % mliteral ); str = \"multiline-literal\" case ( token_kind % keypath ); str = \"keypath\" case ( token_kind % int ); str = \"integer\" case ( token_kind % float ); str = \"float\" case ( token_kind % bool ); str = \"bool\" case ( token_kind % datetime ); str = \"datetime\" case ( token_kind % nil ); str = \"nil\" end select end function stringify","tags":"","url":"proc/stringify.html"},{"title":"resize – TOML-Fortran","text":"public interface resize Reallocate a list of tokens Module Procedures private pure subroutine resize_token(var, n) Reallocate list of tokens Arguments Type Intent Optional Attributes Name type( toml_token ), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size","tags":"","url":"interface/resize.html"},{"title":"new_list_structure – TOML-Fortran","text":"public  subroutine new_list_structure(self) Constructor for the ordered storage data structure Arguments Type Intent Optional Attributes Name class( toml_list_structure ), intent(out), allocatable :: self Instance of the structure Source Code subroutine new_list_structure ( self ) !> Instance of the structure class ( toml_list_structure ), allocatable , intent ( out ) :: self block type ( toml_array_list ), allocatable :: list allocate ( list ) call new_array_list ( list ) call move_alloc ( list , self ) end block end subroutine new_list_structure","tags":"","url":"proc/new_list_structure.html"},{"title":"new_map_structure – TOML-Fortran","text":"public  subroutine new_map_structure(self) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name class( toml_map_structure ), intent(out), allocatable :: self Instance of the structure Source Code subroutine new_map_structure ( self ) !> Instance of the structure class ( toml_map_structure ), allocatable , intent ( out ) :: self block type ( toml_ordered_map ), allocatable :: map allocate ( map ) call new_ordered_map ( map ) call move_alloc ( map , self ) end block end subroutine new_map_structure","tags":"","url":"proc/new_map_structure.html"},{"title":"resize – TOML-Fortran","text":"public  subroutine resize(list, n) Change size of the TOML value list Arguments Type Intent Optional Attributes Name type( toml_node ), intent(inout), allocatable, target :: list (:) Array of TOML values to be resized integer, intent(in) :: n New size of the list Source Code subroutine resize ( list , n ) !> Array of TOML values to be resized type ( toml_node ), allocatable , intent ( inout ), target :: list (:) !> New size of the list integer , intent ( in ) :: n type ( toml_node ), allocatable , target :: tmp (:) integer :: i if ( allocated ( list )) then call move_alloc ( list , tmp ) allocate ( list ( n )) do i = 1 , min ( size ( tmp ), n ) if ( allocated ( tmp ( i )% val )) then call move_alloc ( tmp ( i )% val , list ( i )% val ) end if end do do i = n + 1 , size ( tmp ) if ( allocated ( tmp ( i )% val )) then call tmp ( i )% val % destroy deallocate ( tmp ( i )% val ) end if end do deallocate ( tmp ) else allocate ( list ( n )) end if end subroutine resize","tags":"","url":"proc/resize.html"},{"title":"get_value – TOML-Fortran","text":"public interface get_value Getter functions to manipulate TOML values Module Procedures private  subroutine get_value_float_sp(self, val, stat, origin) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair real(kind=tf_sp), intent(out) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_float_dp(self, val, stat, origin) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair real(kind=tf_dp), intent(out) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_integer_i1(self, val, stat, origin) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i1), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_integer_i2(self, val, stat, origin) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i2), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_integer_i4(self, val, stat, origin) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i4), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_integer_i8(self, val, stat, origin) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i8), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_bool(self, val, stat, origin) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair logical, intent(out) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_datetime(self, val, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair type( toml_datetime ), intent(out) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_string(self, val, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair character(kind=tfc, len=:), intent(out), allocatable :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"interface/get_value.html"},{"title":"set_value – TOML-Fortran","text":"public interface set_value Setter functions to manipulate TOML values Module Procedures private  subroutine set_value_float_sp(self, val, stat, origin) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_float_dp(self, val, stat, origin) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_integer_i1(self, val, stat, origin) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_integer_i2(self, val, stat, origin) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_integer_i4(self, val, stat, origin) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_integer_i8(self, val, stat, origin) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_bool(self, val, stat, origin) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_datetime(self, val, stat, origin) Set TOML value to datetime Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_string(self, val, stat, origin) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"interface/set_value.html"},{"title":"new_lexer_from_file – TOML-Fortran","text":"public  subroutine new_lexer_from_file(lexer, filename, error) Create a new instance of a lexer by reading from a file Arguments Type Intent Optional Attributes Name type( toml_lexer ), intent(out) :: lexer Instance of the lexer character(len=*), intent(in) :: filename Name of the file to read from type( toml_error ), intent(out), allocatable :: error Error code Source Code subroutine new_lexer_from_file ( lexer , filename , error ) !> Instance of the lexer type ( toml_lexer ), intent ( out ) :: lexer !> Name of the file to read from character ( len =* ), intent ( in ) :: filename !> Error code type ( toml_error ), allocatable , intent ( out ) :: error integer :: stat lexer % pos = 0 lexer % filename = filename call resize ( lexer % stack ) call read_whole_file ( filename , lexer % chunk , stat ) if ( stat /= 0 ) then call make_error ( error , \"Could not open file '\" // filename // \"'\" ) end if end subroutine new_lexer_from_file","tags":"","url":"proc/new_lexer_from_file.html"},{"title":"new_lexer_from_string – TOML-Fortran","text":"public  subroutine new_lexer_from_string(lexer, string) Create a new instance of a lexer by reading from a string. Arguments Type Intent Optional Attributes Name type( toml_lexer ), intent(out) :: lexer Instance of the lexer character(kind=tfc, len=*), intent(in) :: string String to read from Source Code subroutine new_lexer_from_string ( lexer , string ) !> Instance of the lexer type ( toml_lexer ), intent ( out ) :: lexer !> String to read from character ( * , tfc ), intent ( in ) :: string integer :: length length = len ( string ) lexer % pos = 0 lexer % buffer = 0 allocate ( character ( length ) :: lexer % chunk ) lexer % chunk (: length ) = string call resize ( lexer % stack ) end subroutine new_lexer_from_string","tags":"","url":"proc/new_lexer_from_string.html"},{"title":"new_lexer_from_unit – TOML-Fortran","text":"public  subroutine new_lexer_from_unit(lexer, io, error) Create a new instance of a lexer by reading from a unit. Currently, only sequential access units can be processed by this constructor. Arguments Type Intent Optional Attributes Name type( toml_lexer ), intent(out) :: lexer Instance of the lexer integer, intent(in) :: io Unit to read from type( toml_error ), intent(out), allocatable :: error Error code Source Code subroutine new_lexer_from_unit ( lexer , io , error ) !> Instance of the lexer type ( toml_lexer ), intent ( out ) :: lexer !> Unit to read from integer , intent ( in ) :: io !> Error code type ( toml_error ), allocatable , intent ( out ) :: error character (:, tfc ), allocatable :: source , line integer , parameter :: bufsize = 512 character ( bufsize , tfc ) :: filename , mode integer :: stat inquire ( unit = io , access = mode , name = filename ) select case ( trim ( mode )) case default stat = 1 case ( \"sequential\" , \"SEQUENTIAL\" ) allocate ( character ( 0 ) :: source ) do call read_whole_line ( io , line , stat ) if ( stat > 0 ) exit source = source // line // TOML_NEWLINE if ( stat < 0 ) then if ( is_iostat_end ( stat )) stat = 0 exit end if end do call new_lexer_from_string ( lexer , source ) end select if ( len_trim ( filename ) > 0 ) lexer % filename = trim ( filename ) if ( stat /= 0 ) then call make_error ( error , \"Failed to read from unit\" ) end if end subroutine new_lexer_from_unit","tags":"","url":"proc/new_lexer_from_unit.html"},{"title":"render – TOML-Fortran","text":"public interface render Module Procedures private pure recursive function render_diagnostic(diag, input, color) result(string) Arguments Type Intent Optional Attributes Name type( toml_diagnostic ), intent(in) :: diag character(len=*), intent(in) :: input type( toml_terminal ), intent(in) :: color Return Value character(len=:), allocatable private  function render_text(input, color, source) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input type( toml_terminal ), intent(in) :: color character(len=*), intent(in), optional :: source Return Value character(len=:), allocatable private  function render_text_with_label(input, label, color, source) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input type( toml_label ), intent(in) :: label type( toml_terminal ), intent(in) :: color character(len=*), intent(in), optional :: source Return Value character(len=:), allocatable private pure function render_text_with_labels(input, label, color, source) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input type( toml_label ), intent(in) :: label (:) type( toml_terminal ), intent(in) :: color character(len=*), intent(in), optional :: source Return Value character(len=:), allocatable","tags":"","url":"interface/render.html"},{"title":"toml_diagnostic – TOML-Fortran","text":"public interface toml_diagnostic Module Procedures private pure function new_diagnostic(level, message, source, label) result(new) Create new diagnostic message Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Level of message character(len=*), intent(in), optional :: message Primary message character(len=*), intent(in), optional :: source Context of the diagnostic source type( toml_label ), intent(in), optional :: label (:) Messages associated with this diagnostic Return Value type( toml_diagnostic )","tags":"","url":"interface/toml_diagnostic.html"},{"title":"toml_label – TOML-Fortran","text":"public interface toml_label Module Procedures private pure function new_label(level, first, last, text, primary) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level integer, intent(in) :: first integer, intent(in) :: last character(len=*), intent(in), optional :: text logical, intent(in), optional :: primary Return Value type( toml_label )","tags":"","url":"interface/toml_label.html"},{"title":"new_array_list – TOML-Fortran","text":"public  subroutine new_array_list(self, n) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name type( toml_array_list ), intent(out) :: self Instance of the structure integer, intent(in), optional :: n Initial storage capacity Source Code subroutine new_array_list ( self , n ) !> Instance of the structure type ( toml_array_list ), intent ( out ) :: self !> Initial storage capacity integer , intent ( in ), optional :: n self % n = 0 if ( present ( n )) then allocate ( self % lst ( min ( 1 , n ))) else allocate ( self % lst ( initial_size )) end if end subroutine new_array_list","tags":"","url":"proc/new_array_list.html"},{"title":"get_value – TOML-Fortran","text":"public interface get_value Getter functions to manipulate TOML tables Module Procedures private  subroutine get_path_table(table, path, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout), target :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_table ), intent(out), pointer :: ptr Pointer to child table logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_array(table, path, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_array ), intent(out), pointer :: ptr Pointer to child array logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_keyval(table, path, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_float_sp(table, path, val, default, stat, origin) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table real(kind=tf_sp), intent(out) :: val Real value real(kind=tf_sp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_float_dp(table, path, val, default, stat, origin) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table real(kind=tf_dp), intent(out) :: val Real value real(kind=tf_dp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_integer_i1(table, path, val, default, stat, origin) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i1), intent(out) :: val Integer value integer(kind=tf_i1), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_integer_i2(table, path, val, default, stat, origin) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i2), intent(out) :: val Integer value integer(kind=tf_i2), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_integer_i4(table, path, val, default, stat, origin) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i4), intent(out) :: val Integer value integer(kind=tf_i4), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_integer_i8(table, path, val, default, stat, origin) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i8), intent(out) :: val Integer value integer(kind=tf_i8), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_bool(table, path, val, default, stat, origin) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table logical, intent(out) :: val Boolean value logical, intent(in), optional :: default Default boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_datetime(table, path, val, default, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_datetime ), intent(out) :: val Datetime value type( toml_datetime ), intent(in), optional :: default Default datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_string(table, path, val, default, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table character(kind=tfc, len=:), intent(out), allocatable :: val String value character(kind=tfc, len=*), intent(in), optional :: default Default string value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"interface/get_value~2.html"},{"title":"set_value – TOML-Fortran","text":"public interface set_value Setter functions to manipulate TOML tables Module Procedures private  subroutine set_path_value_float_sp(table, path, val, stat, origin) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_float_dp(table, path, val, stat, origin) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_integer_i1(table, path, val, stat, origin) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_integer_i2(table, path, val, stat, origin) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_integer_i4(table, path, val, stat, origin) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_integer_i8(table, path, val, stat, origin) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_bool(table, path, val, stat, origin) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_datetime(table, path, val, stat, origin) Set TOML value to datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_string(table, path, val, stat, origin) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"interface/set_value~2.html"},{"title":"toml_path – TOML-Fortran","text":"public interface toml_path Convenience constructors for building key paths from strings instead of keys Module Procedures private pure function new_path2(key1, key2) result(path) Create a new path with two components Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key1 First key to retrieve character(len=*), intent(in) :: key2 Second key to retrieve Return Value type( toml_path ) New path private pure function new_path3(key1, key2, key3) result(path) Create a new path with three components Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: key1 First key to retrieve character(kind=tfc, len=*), intent(in) :: key2 Second key to retrieve character(kind=tfc, len=*), intent(in) :: key3 Third key to retrieve Return Value type( toml_path ) New path private pure function new_path4(key1, key2, key3, key4) result(path) Create a new path with three components Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: key1 First key to retrieve character(kind=tfc, len=*), intent(in) :: key2 Second key to retrieve character(kind=tfc, len=*), intent(in) :: key3 Third key to retrieve character(kind=tfc, len=*), intent(in) :: key4 Forth key to retrieve Return Value type( toml_path ) New path","tags":"","url":"interface/toml_path.html"},{"title":"new_table – TOML-Fortran","text":"public  subroutine new_table(self) Constructor to create a new TOML table and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out) :: self Instance of the TOML table Source Code subroutine new_table ( self ) !> Instance of the TOML table type ( toml_table ), intent ( out ) :: self call new_map_structure ( self % map ) end subroutine new_table","tags":"","url":"proc/new_table.html"},{"title":"initialized – TOML-Fortran","text":"public interface initialized Check whether data structure is initialized properly Module Procedures private pure function table_initialized(self) result(okay) Check whether data structure is initialized properly Arguments Type Intent Optional Attributes Name type( toml_table ), intent(in) :: self Instance of the TOML table Return Value logical Data structure is initialized","tags":"","url":"interface/initialized~2.html"},{"title":"new – TOML-Fortran","text":"public interface new Overloaded constructor for TOML values Module Procedures public  subroutine new_table (self) Constructor to create a new TOML table and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out) :: self Instance of the TOML table","tags":"","url":"interface/new~2.html"},{"title":"toml_table – TOML-Fortran","text":"public interface toml_table Create standard constructor Module Procedures private  function new_table_func() result(self) Default constructor for TOML table type Arguments None Return Value type( toml_table ) Instance of the TOML table","tags":"","url":"interface/toml_table.html"},{"title":"escape – TOML-Fortran","text":"public pure function escape(code) result(str) Transform a color code into an actual ANSI escape sequence Arguments Type Intent Optional Attributes Name type( ansi_code ), intent(in) :: code Color code to be used Return Value character(len=:), allocatable ANSI escape sequence representing the color code Source Code pure function escape ( code ) result ( str ) !> Color code to be used type ( ansi_code ), intent ( in ) :: code !> ANSI escape sequence representing the color code character ( len = :), allocatable :: str if ( anycolor ( code )) then str = achar ( 27 ) // \"[0\" ! Always reset the style if ( code % style > 0 ) str = str // \";\" // to_string ( code % style ) if ( code % fg >= 0 ) str = str // \";\" // to_string ( code % fg ) if ( code % bg >= 0 ) str = str // \";\" // to_string ( code % bg ) str = str // \"m\" else str = \"\" end if end function escape","tags":"","url":"proc/escape.html"},{"title":"operator(+) – TOML-Fortran","text":"public interface operator(+) Module Procedures private pure function add(lval, rval) result(code) Add two escape sequences, attributes in the right value override the left value ones. Arguments Type Intent Optional Attributes Name type( ansi_code ), intent(in) :: lval First escape code type( ansi_code ), intent(in) :: rval Second escape code Return Value type( ansi_code ) Combined escape code","tags":"","url":"interface/operator(+).html"},{"title":"operator(//) – TOML-Fortran","text":"public interface operator(//) Module Procedures private pure function concat_left(lval, code) result(str) Concatenate an escape code with a string and turn it into an actual escape sequence Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lval String to add the escape code to type( ansi_code ), intent(in) :: code Escape sequence Return Value character(len=:), allocatable Concatenated string private pure function concat_right(code, rval) result(str) Concatenate an escape code with a string and turn it into an actual escape sequence Arguments Type Intent Optional Attributes Name type( ansi_code ), intent(in) :: code Escape sequence character(len=*), intent(in) :: rval String to add the escape code to Return Value character(len=:), allocatable Concatenated string","tags":"","url":"interface/operator(SLASHSLASH).html"},{"title":"toml_terminal – TOML-Fortran","text":"public interface toml_terminal Constructor to create new terminal Module Procedures private pure function new_terminal(use_color) result(new) Create new terminal Arguments Type Intent Optional Attributes Name logical, intent(in) :: use_color Enable color support in terminal Return Value type( toml_terminal ) New terminal instance","tags":"","url":"interface/toml_terminal.html"},{"title":"get_tomlf_version – TOML-Fortran","text":"public  subroutine get_tomlf_version(major, minor, patch, string) Getter function to retrieve TOML-Fortran version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the TOML-Fortran version integer, intent(out), optional :: minor Minor version number of the TOML-Fortran version integer, intent(out), optional :: patch Patch version number of the TOML-Fortran version character(len=:), intent(out), optional, allocatable :: string String representation of the TOML-Fortran version Source Code subroutine get_tomlf_version ( major , minor , patch , string ) !> Major version number of the TOML-Fortran version integer , intent ( out ), optional :: major !> Minor version number of the TOML-Fortran version integer , intent ( out ), optional :: minor !> Patch version number of the TOML-Fortran version integer , intent ( out ), optional :: patch !> String representation of the TOML-Fortran version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = tomlf_major end if if ( present ( minor )) then minor = tomlf_minor end if if ( present ( patch )) then patch = tomlf_patch end if if ( present ( string )) then string = tomlf_version_string end if end subroutine get_tomlf_version","tags":"","url":"proc/get_tomlf_version.html"},{"title":"cast_to_array – TOML-Fortran","text":"public  function cast_to_array(ptr) result(array) Cast an abstract TOML value to a TOML array Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in), target :: ptr TOML value to be casted Return Value type( toml_array ), pointer TOML array view, nullified if the value is not an array Source Code function cast_to_array ( ptr ) result ( array ) !> TOML value to be casted class ( toml_value ), intent ( in ), target :: ptr !> TOML array view, nullified if the value is not an array type ( toml_array ), pointer :: array nullify ( array ) select type ( ptr ) type is ( toml_array ) array => ptr end select end function cast_to_array","tags":"","url":"proc/cast_to_array.html"},{"title":"cast_to_keyval – TOML-Fortran","text":"public  function cast_to_keyval(ptr) result(kval) Cast an abstract TOML value to a TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in), target :: ptr TOML value to be casted Return Value type( toml_keyval ), pointer TOML key-value view, nullified if the value is not a table Source Code function cast_to_keyval ( ptr ) result ( kval ) !> TOML value to be casted class ( toml_value ), intent ( in ), target :: ptr !> TOML key-value view, nullified if the value is not a table type ( toml_keyval ), pointer :: kval nullify ( kval ) select type ( ptr ) type is ( toml_keyval ) kval => ptr end select end function cast_to_keyval","tags":"","url":"proc/cast_to_keyval.html"},{"title":"cast_to_table – TOML-Fortran","text":"public  function cast_to_table(ptr) result(table) Cast an abstract TOML value to a TOML table Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in), target :: ptr TOML value to be casted Return Value type( toml_table ), pointer TOML table view, nullified if the value is not a table Source Code function cast_to_table ( ptr ) result ( table ) !> TOML value to be casted class ( toml_value ), intent ( in ), target :: ptr !> TOML table view, nullified if the value is not a table type ( toml_table ), pointer :: table nullify ( table ) select type ( ptr ) type is ( toml_table ) table => ptr end select end function cast_to_table","tags":"","url":"proc/cast_to_table.html"},{"title":"is_array_of_tables – TOML-Fortran","text":"public  function is_array_of_tables(array) result(only_tables) Determine if array contains only tables Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array TOML value to visit Return Value logical Array contains only tables Source Code function is_array_of_tables ( array ) result ( only_tables ) !> TOML value to visit class ( toml_array ), intent ( inout ) :: array !> Array contains only tables logical :: only_tables class ( toml_value ), pointer :: ptr integer :: i , n n = len ( array ) only_tables = n > 0 do i = 1 , n call array % get ( i , ptr ) select type ( ptr ) type is ( toml_table ) cycle class default only_tables = . false . exit end select end do end function is_array_of_tables","tags":"","url":"proc/is_array_of_tables.html"},{"title":"add_array – TOML-Fortran","text":"public interface add_array Interface to build new arrays Module Procedures private  subroutine add_array_to_table(table, key, ptr, stat) Create a new TOML array inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key for the new array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation private  subroutine add_array_to_table_key(table, key, ptr, stat) Create a new TOML array inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key for the new array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation private  subroutine add_array_to_array(array, ptr, stat) Create a new TOML array inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation","tags":"","url":"interface/add_array.html"},{"title":"add_keyval – TOML-Fortran","text":"public interface add_keyval Interface to build new key-value pairs Module Procedures private  subroutine add_keyval_to_table(table, key, ptr, stat) Create a new key-value pair inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key for the new key-value pair type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation private  subroutine add_keyval_to_table_key(table, key, ptr, stat) Create a new key-value pair inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key for the new key-value pair type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation private  subroutine add_keyval_to_array(array, ptr, stat) Create a new key-value pair inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation","tags":"","url":"interface/add_keyval.html"},{"title":"add_table – TOML-Fortran","text":"public interface add_table Interface to build new tables Module Procedures private  subroutine add_table_to_table(table, key, ptr, stat) Create a new TOML table inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key for the new table type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation private  subroutine add_table_to_table_key(table, key, ptr, stat) Create a new TOML table inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key for the new table type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation private  subroutine add_table_to_array(array, ptr, stat) Create a new TOML table inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation","tags":"","url":"interface/add_table.html"},{"title":"new_ordered_map – TOML-Fortran","text":"public  subroutine new_ordered_map(self, n) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name type( toml_ordered_map ), intent(out) :: self Instance of the structure integer, intent(in), optional :: n Initial storage capacity Source Code subroutine new_ordered_map ( self , n ) !> Instance of the structure type ( toml_ordered_map ), intent ( out ) :: self !> Initial storage capacity integer , intent ( in ), optional :: n self % n = 0 if ( present ( n )) then allocate ( self % lst ( min ( 1 , n ))) else allocate ( self % lst ( initial_size )) end if end subroutine new_ordered_map","tags":"","url":"proc/new_ordered_map.html"},{"title":"read_whole_file – TOML-Fortran","text":"public  subroutine read_whole_file(filename, string, stat) Read a whole file into an array of characters Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: filename File to read character(kind=tfc, len=:), intent(out), allocatable :: string Array of characters representing the file integer, intent(out) :: stat Error status Source Code subroutine read_whole_file ( filename , string , stat ) !> File to read character ( * , tfc ), intent ( in ) :: filename !> Array of characters representing the file character (:, tfc ), allocatable , intent ( out ) :: string !> Error status integer , intent ( out ) :: stat integer :: io , length open ( file = filename , & & status = \"old\" , & & access = \"stream\" , & & position = \"append\" , & & newunit = io , & & iostat = stat ) if ( stat == 0 ) then inquire ( unit = io , pos = length ) allocate ( character ( length - 1 , tfc ) :: string , stat = stat ) end if if ( stat == 0 ) then read ( io , pos = 1 , iostat = stat ) string (: length - 1 ) end if if ( stat == 0 ) then close ( io ) end if end subroutine read_whole_file","tags":"","url":"proc/read_whole_file.html"},{"title":"read_whole_line – TOML-Fortran","text":"public  subroutine read_whole_line(io, string, stat) Read a whole line from a formatted unit into a deferred length character variable Arguments Type Intent Optional Attributes Name integer, intent(in) :: io Formatted IO unit character(kind=tfc, len=:), intent(out), allocatable :: string Line to read integer, intent(out) :: stat Status of operation Source Code subroutine read_whole_line ( io , string , stat ) !> Formatted IO unit integer , intent ( in ) :: io !> Line to read character (:, tfc ), allocatable , intent ( out ) :: string !> Status of operation integer , intent ( out ) :: stat integer , parameter :: bufsize = 4096 character ( bufsize , tfc ) :: buffer , msg integer :: chunk logical :: opened if ( io /= - 1 ) then inquire ( unit = io , opened = opened ) else opened = . false . end if if ( opened ) then open ( unit = io , pad = \"yes\" , iostat = stat ) else stat = 1 msg = \"Unit is not connected\" end if string = \"\" do while ( stat == 0 ) read ( io , '(a)' , advance = 'no' , iostat = stat , size = chunk ) buffer if ( stat > 0 ) exit string = string // buffer (: chunk ) end do if ( is_iostat_eor ( stat )) stat = 0 end subroutine read_whole_line","tags":"","url":"proc/read_whole_line.html"},{"title":"get_value – TOML-Fortran","text":"public interface get_value Getter functions to manipulate TOML arrays Module Procedures private  subroutine get_elem_table(array, pos, ptr, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_table ), intent(out), pointer :: ptr Pointer to child table integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_array(array, pos, ptr, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_array ), intent(out), pointer :: ptr Pointer to child array integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_keyval(array, pos, ptr, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_string(array, pos, val, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array character(kind=tfc, len=:), intent(out), allocatable :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_float_sp(array, pos, val, stat, origin) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_sp), intent(out) :: val Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_float_dp(array, pos, val, stat, origin) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_dp), intent(out) :: val Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_int_i1(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i1), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_int_i2(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i2), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_int_i4(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i4), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_int_i8(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i8), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_bool(array, pos, val, stat, origin) Retrieve TOML value as boolean Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array logical, intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_datetime(array, pos, val, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_datetime ), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_float_sp(array, val, stat, origin) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array real(kind=tf_sp), intent(out), allocatable :: val (:) Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_float_dp(array, val, stat, origin) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array real(kind=tf_dp), intent(out), allocatable :: val (:) Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_int_i1(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i1), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_int_i2(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i2), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_int_i4(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i4), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_int_i8(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i8), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_bool(array, val, stat, origin) Retrieve TOML value as boolean Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array logical, intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_datetime(array, val, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_datetime ), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"interface/get_value~3.html"},{"title":"set_value – TOML-Fortran","text":"public interface set_value Setter functions to manipulate TOML arrays Module Procedures private  subroutine set_elem_value_string(array, pos, val, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_float_sp(array, pos, val, stat, origin) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_sp), intent(in) :: val Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_float_dp(array, pos, val, stat, origin) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_dp), intent(in) :: val Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_int_i1(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_int_i2(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_int_i4(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_int_i8(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_bool(array, pos, val, stat, origin) Retrieve TOML value as boolean value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_datetime(array, pos, val, stat, origin) Retrieve TOML value as datetime value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_float_sp(array, val, stat, origin) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array real(kind=tf_sp), intent(in) :: val (:) Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_float_dp(array, val, stat, origin) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array real(kind=tf_dp), intent(in) :: val (:) Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_int_i1(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i1), intent(in) :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_int_i2(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i2), intent(in) :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_int_i4(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i4), intent(in) :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_int_i8(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i8), intent(in) :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_bool(array, val, stat, origin) Retrieve TOML value as boolean value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array logical, intent(in) :: val (:) Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_datetime(array, val, stat, origin) Retrieve TOML value as datetime value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_datetime ), intent(in) :: val (:) Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"interface/set_value~3.html"},{"title":"new_keyval – TOML-Fortran","text":"public  subroutine new_keyval(self) Constructor to create a new TOML key-value pair Arguments Type Intent Optional Attributes Name type( toml_keyval ), intent(out) :: self Instance of the TOML key-value pair Source Code subroutine new_keyval ( self ) !> Instance of the TOML key-value pair type ( toml_keyval ), intent ( out ) :: self associate ( self => self ); end associate end subroutine new_keyval","tags":"","url":"proc/new_keyval.html"},{"title":"new – TOML-Fortran","text":"public interface new Overloaded constructor for TOML values Module Procedures public  subroutine new_keyval (self) Constructor to create a new TOML key-value pair Arguments Type Intent Optional Attributes Name type( toml_keyval ), intent(out) :: self Instance of the TOML key-value pair","tags":"","url":"interface/new~3.html"},{"title":"get_value – TOML-Fortran","text":"public interface get_value Getter functions to manipulate TOML tables Module Procedures private  subroutine get_child_table(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_table ), intent(out), pointer :: ptr Pointer to child table logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_array(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_array ), intent(out), pointer :: ptr Pointer to child array logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_keyval(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_float_sp(table, key, val, default, stat, origin) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(out) :: val Real value real(kind=tf_sp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_float_dp(table, key, val, default, stat, origin) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(out) :: val Real value real(kind=tf_dp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_integer_i1(table, key, val, default, stat, origin) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(out) :: val Integer value integer(kind=tf_i1), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_integer_i2(table, key, val, default, stat, origin) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(out) :: val Integer value integer(kind=tf_i2), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_integer_i4(table, key, val, default, stat, origin) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(out) :: val Integer value integer(kind=tf_i4), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_integer_i8(table, key, val, default, stat, origin) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(out) :: val Integer value integer(kind=tf_i8), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_bool(table, key, val, default, stat, origin) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table logical, intent(out) :: val Boolean value logical, intent(in), optional :: default Default boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_datetime(table, key, val, default, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_datetime ), intent(out) :: val Datetime value type( toml_datetime ), intent(in), optional :: default Default datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_string(table, key, val, default, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table character(kind=tfc, len=:), intent(out), allocatable :: val String value character(kind=tfc, len=*), intent(in), optional :: default Default string value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_table(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_table ), intent(out), pointer :: ptr Pointer to child table logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_array(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_array ), intent(out), pointer :: ptr Pointer to child array logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_keyval(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_float_sp(table, key, val, default, stat, origin) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(out) :: val Real value real(kind=tf_sp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_float_dp(table, key, val, default, stat, origin) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(out) :: val Real value real(kind=tf_dp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_integer_i1(table, key, val, default, stat, origin) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(out) :: val Integer value integer(kind=tf_i1), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_integer_i2(table, key, val, default, stat, origin) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(out) :: val Integer value integer(kind=tf_i2), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_integer_i4(table, key, val, default, stat, origin) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(out) :: val Integer value integer(kind=tf_i4), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_integer_i8(table, key, val, default, stat, origin) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(out) :: val Integer value integer(kind=tf_i8), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_bool(table, key, val, default, stat, origin) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table logical, intent(out) :: val Boolean value logical, intent(in), optional :: default Default boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_datetime(table, key, val, default, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_datetime ), intent(out) :: val Datetime value type( toml_datetime ), intent(in), optional :: default Default datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_string(table, key, val, default, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table character(kind=tfc, len=:), intent(out), allocatable :: val String value character(kind=tfc, len=*), intent(in), optional :: default Default string value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"interface/get_value~4.html"},{"title":"set_value – TOML-Fortran","text":"public interface set_value Setter functions to manipulate TOML tables Module Procedures private  subroutine set_child_value_float_sp(table, key, val, stat, origin) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_float_dp(table, key, val, stat, origin) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_integer_i1(table, key, val, stat, origin) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_integer_i2(table, key, val, stat, origin) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_integer_i4(table, key, val, stat, origin) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_integer_i8(table, key, val, stat, origin) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_bool(table, key, val, stat, origin) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_datetime(table, key, val, stat, origin) Set TOML value to datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_string(table, key, val, stat, origin) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_float_sp(table, key, val, stat, origin) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_float_dp(table, key, val, stat, origin) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_integer_i1(table, key, val, stat, origin) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_integer_i2(table, key, val, stat, origin) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_integer_i4(table, key, val, stat, origin) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_integer_i8(table, key, val, stat, origin) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_bool(table, key, val, stat, origin) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_datetime(table, key, val, stat, origin) Set TOML value to datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_string(table, key, val, stat, origin) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"interface/set_value~4.html"},{"title":"toml_serialize – TOML-Fortran","text":"public  function toml_serialize(val, config) result(string) Serialize a JSON value to a string and return it. In case of an error this function will invoke an error stop. Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: val TOML value to visit type(toml_ser_config), intent(in), optional :: config Configuration for serializer Return Value character(len=:), allocatable Serialized JSON value Source Code function toml_serialize ( val , config ) result ( string ) !> TOML value to visit class ( toml_value ), intent ( inout ) :: val !> Configuration for serializer type ( toml_ser_config ), intent ( in ), optional :: config !> Serialized JSON value character ( len = :), allocatable :: string type ( toml_error ), allocatable :: error call toml_dumps ( val , string , error , config = config ) if ( allocated ( error )) then print '(a)' , \"Error: \" // error % message error stop 1 end if end function toml_serialize","tags":"","url":"proc/toml_serialize.html"},{"title":"new_serializer – TOML-Fortran","text":"public  subroutine new_serializer(self, config) Constructor to create new serializer instance Arguments Type Intent Optional Attributes Name type( toml_serializer ), intent(out) :: self Instance of the TOML serializer type(toml_ser_config), intent(in), optional :: config Configuration for serializer Source Code subroutine new_serializer ( self , config ) !> Instance of the TOML serializer type ( toml_serializer ), intent ( out ) :: self !> Configuration for serializer type ( toml_ser_config ), intent ( in ), optional :: config self % output = \"\" if ( present ( config )) self % config = config end subroutine new_serializer","tags":"","url":"proc/new_serializer.html"},{"title":"new – TOML-Fortran","text":"public interface new Overloaded constructor for TOML serializers Module Procedures public  subroutine new_serializer (self, config) Constructor to create new serializer instance Arguments Type Intent Optional Attributes Name type( toml_serializer ), intent(out) :: self Instance of the TOML serializer type(toml_ser_config), intent(in), optional :: config Configuration for serializer","tags":"","url":"interface/new~4.html"},{"title":"toml_dump – TOML-Fortran","text":"public interface toml_dump Module Procedures private  subroutine toml_dump_to_file(val, filename, error, config) Write string representation of JSON value to a file Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: val TOML value to visit character(len=*), intent(in) :: filename File name to write to type( toml_error ), intent(out), allocatable :: error Error handling type(toml_ser_config), intent(in), optional :: config Configuration for serializer private  subroutine toml_dump_to_unit(val, io, error, config) Write string representation of JSON value to a connected formatted unit Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: val TOML value to visit integer, intent(in) :: io Formatted unit to write to type( toml_error ), intent(out), allocatable :: error Error handling type(toml_ser_config), intent(in), optional :: config Configuration for serializer","tags":"","url":"interface/toml_dump.html"},{"title":"toml_dumps – TOML-Fortran","text":"public interface toml_dumps Module Procedures private  subroutine toml_dump_to_string(val, string, error, config) Create a string representing the JSON value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: val TOML value to visit character(len=:), intent(out), allocatable :: string Formatted unit to write to type( toml_error ), intent(out), allocatable :: error Error handling type(toml_ser_config), intent(in), optional :: config Configuration for serializer","tags":"","url":"interface/toml_dumps.html"},{"title":"toml_serializer – TOML-Fortran","text":"public interface toml_serializer Create standard constructor Module Procedures private  function new_serializer_func(config) result(self) Default constructor for TOML serializer Arguments Type Intent Optional Attributes Name type(toml_ser_config), intent(in), optional :: config Configuration for serializer Return Value type( toml_serializer ) Instance of the TOML serializer","tags":"","url":"interface/toml_serializer.html"},{"title":"toml_escape_string – TOML-Fortran","text":"public  subroutine toml_escape_string(raw, escaped, multiline) Escape all special characters in a TOML string Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: raw Raw representation of TOML string character(kind=tfc, len=:), intent(out), allocatable :: escaped Escaped view of the TOML string logical, intent(in), optional :: multiline Preserve newline characters Source Code subroutine toml_escape_string ( raw , escaped , multiline ) !> Raw representation of TOML string character ( kind = tfc , len =* ), intent ( in ) :: raw !> Escaped view of the TOML string character ( kind = tfc , len = :), allocatable , intent ( out ) :: escaped !> Preserve newline characters logical , intent ( in ), optional :: multiline integer :: i logical :: preserve_newline preserve_newline = . false . if ( present ( multiline )) preserve_newline = multiline escaped = '\"' do i = 1 , len ( raw ) select case ( raw ( i : i )) case default ; escaped = escaped // raw ( i : i ) case ( '\\'); escaped = escaped // ' \\\\ ' case(' \"'); escaped = escaped // '\\\"' case(TOML_NEWLINE) if (preserve_newline) then escaped = escaped // raw(i:i) else escaped = escaped // '\\n' end if case(TOML_FORMFEED); escaped = escaped // '\\f' case(TOML_CARRIAGE_RETURN); escaped = escaped // '\\r' case(TOML_TABULATOR); escaped = escaped // '\\t' case(TOML_BACKSPACE); escaped = escaped // '\\b' end select end do escaped = escaped // '\" ' end subroutine toml_escape_string","tags":"","url":"proc/toml_escape_string.html"},{"title":"to_string – TOML-Fortran","text":"public interface to_string Module Procedures private pure function to_string_i1(val) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Integer value to create string from Return Value character(len=:), allocatable String representation of integer private pure function to_string_i2(val) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Integer value to create string from Return Value character(len=:), allocatable String representation of integer private pure function to_string_i4(val) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Integer value to create string from Return Value character(len=:), allocatable String representation of integer private pure function to_string_i8(val) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Integer value to create string from Return Value character(len=:), allocatable String representation of integer private pure function to_string_r8(val) result(string) Represent an real as character sequence. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: val Real value to create string from Return Value character(len=:), allocatable String representation of integer","tags":"","url":"interface/to_string~2.html"},{"title":"parse – TOML-Fortran","text":"public  subroutine parse(lexer, table, config, context, error) Parse TOML document and return root table Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(inout) :: lexer Instance of the lexer type( toml_table ), intent(out), allocatable :: table TOML data structure type( toml_parser_config ), intent(in), optional :: config Configuration for the parser type( toml_context ), intent(out), optional :: context Context tracking the origin of the data structure to allow rich reports type( toml_error ), intent(out), optional, allocatable :: error Error handler Source Code subroutine parse ( lexer , table , config , context , error ) !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> TOML data structure type ( toml_table ), allocatable , intent ( out ) :: table !> Configuration for the parser type ( toml_parser_config ), intent ( in ), optional :: config !> Context tracking the origin of the data structure to allow rich reports type ( toml_context ), intent ( out ), optional :: context !> Error handler type ( toml_error ), allocatable , intent ( out ), optional :: error type ( toml_parser ) :: parser call new_parser ( parser , config ) call parse_root ( parser , lexer ) if ( present ( error ) . and . allocated ( parser % diagnostic )) then call make_error ( error , parser % diagnostic , lexer , parser % config % color ) end if if ( allocated ( parser % diagnostic )) return call move_alloc ( parser % root , table ) if ( present ( context )) then context = parser % context call lexer % get_info ( \"filename\" , context % filename ) call lexer % get_info ( \"source\" , context % source ) end if end subroutine parse","tags":"","url":"proc/parse.html"},{"title":"toml_parser_config – TOML-Fortran","text":"public interface toml_parser_config Module Procedures private pure function new_parser_config(color, context_detail) result(config) Create new configuration for the TOML parser Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: color Color support for diagnostics integer, intent(in), optional :: context_detail Record all tokens Return Value type( toml_parser_config ) Configuration of the parser","tags":"","url":"interface/toml_parser_config.html"},{"title":"sort – TOML-Fortran","text":"public interface sort Create overloaded interface for export Module Procedures private pure subroutine sort_keys(list, idx, compare) Entry point for sorting algorithm Arguments Type Intent Optional Attributes Name type( toml_key ), intent(inout) :: list (:) List of TOML keys to be sorted integer, intent(out), optional :: idx (:) Optionally, mapping from unsorted list to sorted list procedure( compare_less ), optional :: compare Function implementing the order relation between two TOML keys","tags":"","url":"interface/sort.html"},{"title":"toml_load – TOML-Fortran","text":"public interface toml_load Load a TOML data structure from the provided source Module Procedures private  subroutine toml_load_file(table, filename, config, context, error) Load TOML data structure from file Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error character(kind=tfc, len=*), intent(in) :: filename type( toml_parser_config ), intent(in), optional :: config Configuration for the parser type( toml_context ), intent(out), optional :: context Context tracking the origin of the data structure to allow rich reports type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error private  subroutine toml_load_unit(table, io, config, context, error) Load TOML data structure from unit Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error integer, intent(in) :: io Unit to read from type( toml_parser_config ), intent(in), optional :: config Configuration for the parser type( toml_context ), intent(out), optional :: context Context tracking the origin of the data structure to allow rich reports type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error","tags":"","url":"interface/toml_load.html"},{"title":"toml_loads – TOML-Fortran","text":"public interface toml_loads Load a TOML data structure from a string Module Procedures private  subroutine toml_load_string(table, string, config, context, error) Load TOML data structure from string Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error character(kind=tfc, len=*), intent(in) :: string String containing TOML document type( toml_parser_config ), intent(in), optional :: config Configuration for the parser type( toml_context ), intent(out), optional :: context Context tracking the origin of the data structure to allow rich reports type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error","tags":"","url":"interface/toml_loads.html"},{"title":"toml_parse – TOML-Fortran","text":"public interface toml_parse Parse a TOML document. This interface is deprecated in favor of toml_load and toml_loads Module Procedures private  subroutine toml_parse_unit(table, unit, error) Parse a TOML input from a given IO unit. Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error integer, intent(in) :: unit Unit to read from type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error private  subroutine toml_parse_string(table, string, error) Wrapper to parse a TOML string. Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error character(len=*), intent(in), target :: string String containing TOML document type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error","tags":"","url":"interface/toml_parse.html"},{"title":"tomlf_type_value – TOML-Fortran","text":"Class definitions for basic data types used for handling TOML Uses tomlf_utils tomlf_constants Derived Types type, public :: toml_key Thin wrapper around the deferred-size character intrinisc Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value type, public, abstract :: toml_value Abstract base value for TOML data types Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure procedure(destroy), public, deferred :: destroy Release allocation hold by TOML value procedure, public :: get_key Get escaped key to TOML value procedure, public :: match_key Compare raw key of TOML value to input key type, public, abstract :: toml_visitor Abstract visitor for TOML values Type-Bound Procedures procedure(visit), public, deferred :: visit Visitor visiting a TOML value","tags":"","url":"module/tomlf_type_value.html"},{"title":"tomlf_datetime – TOML-Fortran","text":"Implementation of a TOML datetime value Uses tomlf_constants Interfaces public        interface operator(==) private pure function compare_datetime(lhs, rhs) result(match) Arguments Type Intent Optional Attributes Name type( toml_datetime ), intent(in) :: lhs type( toml_datetime ), intent(in) :: rhs Return Value logical public        interface to_string private pure function to_string_datetime(datetime) result(str) Arguments Type Intent Optional Attributes Name type( toml_datetime ), intent(in) :: datetime Return Value character(kind=tfc, len=:), allocatable public        interface toml_datetime Create a new TOML datetime value private pure function new_datetime(year, month, day, hour, minute, second, msecond, zone) result(datetime) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: year integer, intent(in), optional :: month integer, intent(in), optional :: day integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: msecond character(len=*), intent(in), optional :: zone Return Value type( toml_datetime ) private pure function new_datetime_from_string(string) result(datetime) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( toml_datetime ) public        interface toml_time private elemental function new_toml_time(hour, minute, second, msec, zone) result(self) Constructor for toml_time type, necessary due to PGI bug in NVHPC 20.7 and 20.9 Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: hour integer, intent(in), optional :: minute integer, intent(in), optional :: second integer, intent(in), optional :: msec character(len=*), intent(in), optional :: zone Return Value type( toml_time ) Derived Types type, public :: toml_date TOML date value (YYYY-MM-DD) Components Type Visibility Attributes Name Initial integer, public :: day = -1 integer, public :: month = -1 integer, public :: year = -1 type, public :: toml_datetime TOML datatime value type Components Type Visibility Attributes Name Initial type( toml_date ), public :: date type( toml_time ), public :: time Constructor Create a new TOML datetime value private\n\n                    pure\n                    function new_datetime (year, month, day, hour, minute, second, msecond, zone) private\n\n                    pure\n                    function new_datetime_from_string (string) type, public :: toml_time TOML time value (HH:MM:SS.sssssZ…) Components Type Visibility Attributes Name Initial integer, public :: hour = -1 integer, public :: minute = -1 integer, public :: msec = -1 integer, public :: second = -1 character(len=:), public, allocatable :: zone Constructor private\n\n                    elemental\n                    function new_toml_time (hour, minute, second, msec, zone) Constructor for toml_time type, necessary due to PGI bug in NVHPC 20.7 and 20.9 Functions public pure function has_date (datetime) Arguments Type Intent Optional Attributes Name class( toml_datetime ), intent(in) :: datetime Return Value logical public pure function has_time (datetime) Arguments Type Intent Optional Attributes Name class( toml_datetime ), intent(in) :: datetime Return Value logical","tags":"","url":"module/tomlf_datetime.html"},{"title":"tomlf_error – TOML-Fortran","text":"Central registry for error codes Uses tomlf_constants Variables Type Visibility Attributes Name Initial type(enum_stat), public, parameter :: toml_stat = enum_stat() Actual enumerator for return states Derived Types type, public :: toml_error Error message produced by TOML-Fortran Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: message Payload of the error integer, public :: stat = toml_stat%fatal Error code Subroutines public  subroutine make_error (error, message, stat) Create new error message Arguments Type Intent Optional Attributes Name type( toml_error ), intent(out), allocatable :: error Error report character(kind=tfc, len=*), intent(in) :: message Message for the error integer, intent(in), optional :: stat Status code","tags":"","url":"module/tomlf_error.html"},{"title":"tomlf_type_array – TOML-Fortran","text":"Implementation of the TOML array data type. Uses tomlf_structure tomlf_error tomlf_type_value Interfaces public        interface initialized Check whether data structure is initialized properly private pure function array_initialized(self) result(okay) Check whether data structure is initialized properly Arguments Type Intent Optional Attributes Name type( toml_array ), intent(in) :: self Instance of the TOML array Return Value logical Data structure is initialized public        interface len Overload len function private pure function get_len(self) result(length) Get number of TOML values in the array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(in) :: self Instance of the TOML array Return Value integer Current length of the array public        interface new Overloaded constructor for TOML values public  subroutine new_array (self) Constructor to create a new TOML array and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_array ), intent(out) :: self Instance of the TOML array public        interface toml_array Create standard constructor private  function new_array_func() result(self) Default constructor for TOML array type Arguments None Return Value type( toml_array ) Instance of the TOML array Derived Types type, public, extends( toml_value ) :: toml_array TOML array Components Type Visibility Attributes Name Initial logical, public :: inline = .true. Is an inline array rather than an array of tables character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value Constructor Create standard constructor private\n\n                    \n                    function new_array_func () Default constructor for TOML array type Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure procedure, public :: destroy Release allocation hold by TOML array procedure, public :: get Get the TOML value at a given index procedure, public :: get_key Get escaped key to TOML value procedure, public :: match_key Compare raw key of TOML value to input key procedure, public :: pop Remove the last element from the array procedure, public :: push_back Append value to array procedure, public :: shift Remove the first element from the array Subroutines public  subroutine new_array (self) Constructor to create a new TOML array and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_array ), intent(out) :: self Instance of the TOML array","tags":"","url":"module/tomlf_type_array.html"},{"title":"tomlf_build_merge – TOML-Fortran","text":"Merge TOML data structures, the merge policy can be adjusted. Note that the context information cannot be preserved. Uses tomlf_type tomlf_constants Variables Type Visibility Attributes Name Initial type(enum_policy), public, parameter :: merge_policy = enum_policy() Actual enumerator for merging data structures Interfaces public        interface toml_merge_config Constructor for merge configuration private pure function new_merge_config(table, array, keyval) result(config) Create a new merge configuration Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: table Policy for merging tables character(len=*), intent(in), optional :: array Policy for merging arrays character(len=*), intent(in), optional :: keyval Policy for merging values Return Value type( toml_merge_config ) Merge policy Derived Types type, public :: toml_merge_config Configuration for merging data structures Components Type Visibility Attributes Name Initial integer, public :: array = merge_policy%preserve Policy for merging arrays integer, public :: keyval = merge_policy%preserve Policy for merging values integer, public :: table = merge_policy%append Policy for merging tables Constructor Constructor for merge configuration private\n\n                    pure\n                    function new_merge_config (table, array, keyval) Create a new merge configuration Subroutines public recursive subroutine merge_array (lhs, rhs) Append values from one TOML array to another Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: lhs Instance of array to merge into class( toml_array ), intent(inout) :: rhs Instance of array to be merged public recursive subroutine merge_table (lhs, rhs, config) Merge TOML tables by appending their values Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: lhs Instance of table to merge into class( toml_table ), intent(inout) :: rhs Instance of table to be merged type( toml_merge_config ), intent(in), optional :: config Merge policy","tags":"","url":"module/tomlf_build_merge.html"},{"title":"tomlf_de_token – TOML-Fortran","text":"Provides a definition for a token Variables Type Visibility Attributes Name Initial type(enum_token), public, parameter :: token_kind = enum_token() Actual enumerator for token kinds Interfaces public        interface resize Reallocate a list of tokens private pure subroutine resize_token(var, n) Reallocate list of tokens Arguments Type Intent Optional Attributes Name type( toml_token ), intent(inout), allocatable :: var (:) Instance of the array to be resized integer, intent(in), optional :: n Dimension of the final array size Derived Types type, public :: toml_token Token containing Components Type Visibility Attributes Name Initial integer, public :: chunk = 0 Identifier for the chunk index in case of buffered reading integer, public :: first = 0 Starting position of the token in character stream integer, public :: kind = token_kind%newline Kind of token integer, public :: last = 0 Last position of the token in character stream Functions public pure function stringify (token) result(str) Represent a token as string Arguments Type Intent Optional Attributes Name type( toml_token ), intent(in) :: token Token to represent as string Return Value character(len=:), allocatable String representation of token","tags":"","url":"module/tomlf_de_token.html"},{"title":"tomlf_structure – TOML-Fortran","text":"Abstraction layer for the actual storage of the data structure. The structure implementations provide the actual storage for TOML values, with\na generic enough interface to make the definition of the TOML data structures\nindependent of the actual algorithm used for storing the TOML values. Every data structure defined here should strive to only use allocatable\ndata types and limit the use of pointer attributes as they interfer with\nthe automatic memory management of Fortran. A well defined data structure\nin allocatables allows deep-copying of TOML values by assignment, data structures\nrequiring pointer attributes have to define an assignment(=) interface to\nallow deep-copying of TOML values. Uses tomlf_structure_list tomlf_structure_array_list tomlf_structure_ordered_map tomlf_structure_map Subroutines public  subroutine new_list_structure (self) Constructor for the ordered storage data structure Arguments Type Intent Optional Attributes Name class( toml_list_structure ), intent(out), allocatable :: self Instance of the structure public  subroutine new_map_structure (self) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name class( toml_map_structure ), intent(out), allocatable :: self Instance of the structure","tags":"","url":"module/tomlf_structure.html"},{"title":"tomlf_structure_map – TOML-Fortran","text":"Abstract base class definitions for data structures to store TOML values Uses tomlf_constants tomlf_type_value Derived Types type, public, abstract :: toml_map_structure Abstract data structure Type-Bound Procedures procedure(delete), public, deferred :: delete Delete TOML value at a given key procedure(destroy), public, deferred :: destroy Destroy the data structure procedure(get), public, deferred :: get Get TOML value at a given key procedure(get_keys), public, deferred :: get_keys Get list of all keys in the structure procedure(pop), public, deferred :: pop Remove TOML value at a given key and return it procedure(push_back), public, deferred :: push_back Push back a TOML value to the structure","tags":"","url":"module/tomlf_structure_map.html"},{"title":"tomlf_structure_node – TOML-Fortran","text":"Implementation of a basic storage structure as pointer list of pointers. This implementation does purposely not use pointer attributes in the\ndatastructure to make it safer to work with. Uses tomlf_type_value Derived Types type, public :: toml_node Wrapped TOML value to generate pointer list Components Type Visibility Attributes Name Initial class( toml_value ), public, allocatable :: val TOML value payload Subroutines public  subroutine resize (list, n) Change size of the TOML value list Arguments Type Intent Optional Attributes Name type( toml_node ), intent(inout), allocatable, target :: list (:) Array of TOML values to be resized integer, intent(in) :: n New size of the list","tags":"","url":"module/tomlf_structure_node.html"},{"title":"tomlf_build_keyval – TOML-Fortran","text":"Functions to build a TOML values The build module defines an interface to work with TOML values instead\nof accessing the raw value directly. Both setter and getter routines defined\nhere are rarely needed in any user context, but serve as a basic building\nblock to define uniform access methods for TOML tables and arrays. Uses tomlf_error tomlf_datetime tomlf_type tomlf_utils tomlf_constants Interfaces public        interface get_value Getter functions to manipulate TOML values private  subroutine get_value_float_sp(self, val, stat, origin) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair real(kind=tf_sp), intent(out) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_float_dp(self, val, stat, origin) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair real(kind=tf_dp), intent(out) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_integer_i1(self, val, stat, origin) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i1), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_integer_i2(self, val, stat, origin) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i2), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_integer_i4(self, val, stat, origin) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i4), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_integer_i8(self, val, stat, origin) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair integer(kind=tf_i8), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_bool(self, val, stat, origin) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair logical, intent(out) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_datetime(self, val, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair type( toml_datetime ), intent(out) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_value_string(self, val, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(in) :: self Instance of the key-value pair character(kind=tfc, len=:), intent(out), allocatable :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure public        interface set_value Setter functions to manipulate TOML values private  subroutine set_value_float_sp(self, val, stat, origin) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_float_dp(self, val, stat, origin) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_integer_i1(self, val, stat, origin) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_integer_i2(self, val, stat, origin) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_integer_i4(self, val, stat, origin) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_integer_i8(self, val, stat, origin) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_bool(self, val, stat, origin) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_datetime(self, val, stat, origin) Set TOML value to datetime Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_value_string(self, val, stat, origin) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_keyval ), intent(inout) :: self Instance of the key-value pair character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"module/tomlf_build_keyval.html"},{"title":"tomlf_build – TOML-Fortran","text":"Functions to build a TOML data structures The build module defines a high level interface to work with TOML data structures\nand construct them in a convenient way. Uses tomlf_build_keyval tomlf_build_table tomlf_build_array tomlf_build_merge tomlf_build_path","tags":"","url":"module/tomlf_build.html"},{"title":"tomlf_de_lexer – TOML-Fortran","text":"Provides tokenization for TOML documents. The lexer provides a way to turn a stream of characters into tokens which\nare further processed by the parser and turned into actual TOML data structures.\nIn the current structure no knowledge about the character stream is required\nin the parser to generate the data structures. The validity of all tokens can be guaranteed by the lexer, however syntax errors\nand semantic errors are not detected until the parser is run. Identification of\ninvalid tokens and recovery of the tokenization is done on a best effort basis. To avoid overflows in the parser due to deeply nested but unclosed groups, the\nlexer will always tokenize a complete group to verify it is closed properly.\nUnclosed groups will lead to the first token of the group getting invalidated,\nto allow reporting in the parsing phase. Uses tomlf_de_token tomlf_de_abc tomlf_error tomlf_datetime tomlf_de_context tomlf_utils tomlf_constants Derived Types type, public, extends( abstract_lexer ) :: toml_lexer Tokenizer for TOML documents. Components Type Visibility Attributes Name Initial integer, public :: buffer = 0 Index in the buffer queue character(kind=tfc, len=:), public, allocatable :: chunk Current source chunk, for convenience stored as character array rather than string type( toml_context ), public :: context Douple-ended queue for buffering tokens character(len=:), public, allocatable :: filename Name of the source file, used for error reporting integer, public :: pos = 0 Current internal position in the source chunk type(stack_item), public, allocatable :: stack (:) Stack of scopes, used to identify the current state of the lexer integer, public :: top = 0 Last scope of the lexer Type-Bound Procedures generic, public :: extract => extract_string , extract_integer , extract_float , extract_bool , extract_datetime Extract a token procedure, public :: extract_bool Extract a boolean from a token procedure, public :: extract_datetime Extract a timestamp from a token procedure, public :: extract_float Extract a float from a token procedure, public :: extract_integer Extract an integer from a token procedure, public :: extract_string Extract a string from a token procedure, public :: get_info Get information about source procedure, public :: next Obtain the next token Subroutines public  subroutine new_lexer_from_file (lexer, filename, error) Create a new instance of a lexer by reading from a file Arguments Type Intent Optional Attributes Name type( toml_lexer ), intent(out) :: lexer Instance of the lexer character(len=*), intent(in) :: filename Name of the file to read from type( toml_error ), intent(out), allocatable :: error Error code public  subroutine new_lexer_from_string (lexer, string) Create a new instance of a lexer by reading from a string. Arguments Type Intent Optional Attributes Name type( toml_lexer ), intent(out) :: lexer Instance of the lexer character(kind=tfc, len=*), intent(in) :: string String to read from public  subroutine new_lexer_from_unit (lexer, io, error) Create a new instance of a lexer by reading from a unit. Read more… Arguments Type Intent Optional Attributes Name type( toml_lexer ), intent(out) :: lexer Instance of the lexer integer, intent(in) :: io Unit to read from type( toml_error ), intent(out), allocatable :: error Error code","tags":"","url":"module/tomlf_de_lexer.html"},{"title":"tomlf_diagnostic – TOML-Fortran","text":"Diagnostic message support for TOML Fortran Uses tomlf_terminal Variables Type Visibility Attributes Name Initial type(level_enum), public, parameter :: toml_level = level_enum() Actual enumerator values Interfaces public        interface render private pure recursive function render_diagnostic(diag, input, color) result(string) Arguments Type Intent Optional Attributes Name type( toml_diagnostic ), intent(in) :: diag character(len=*), intent(in) :: input type( toml_terminal ), intent(in) :: color Return Value character(len=:), allocatable private  function render_text(input, color, source) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input type( toml_terminal ), intent(in) :: color character(len=*), intent(in), optional :: source Return Value character(len=:), allocatable private  function render_text_with_label(input, label, color, source) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input type( toml_label ), intent(in) :: label type( toml_terminal ), intent(in) :: color character(len=*), intent(in), optional :: source Return Value character(len=:), allocatable private pure function render_text_with_labels(input, label, color, source) result(string) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input type( toml_label ), intent(in) :: label (:) type( toml_terminal ), intent(in) :: color character(len=*), intent(in), optional :: source Return Value character(len=:), allocatable public        interface toml_diagnostic private pure function new_diagnostic(level, message, source, label) result(new) Create new diagnostic message Arguments Type Intent Optional Attributes Name integer, intent(in) :: level Level of message character(len=*), intent(in), optional :: message Primary message character(len=*), intent(in), optional :: source Context of the diagnostic source type( toml_label ), intent(in), optional :: label (:) Messages associated with this diagnostic Return Value type( toml_diagnostic ) public        interface toml_label private pure function new_label(level, first, last, text, primary) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: level integer, intent(in) :: first integer, intent(in) :: last character(len=*), intent(in), optional :: text logical, intent(in), optional :: primary Return Value type( toml_label ) Derived Types type, public :: toml_diagnostic Definition of diagnostic message Components Type Visibility Attributes Name Initial type( toml_label ), public, allocatable :: label (:) Messages associated with this diagnostic integer, public :: level Level of message character(len=:), public, allocatable :: message Primary message character(len=:), public, allocatable :: source Context of the diagnostic source Constructor private\n\n                    pure\n                    function new_diagnostic (level, message, source, label) Create new diagnostic message type, public :: toml_label Components Type Visibility Attributes Name Initial integer, public :: first First and last character of message integer, public :: last First and last character of message integer, public :: level Level of message logical, public :: primary Primary message character(len=:), public, allocatable :: source Identifier of context character(len=:), public, allocatable :: text Message text Constructor private\n\n                    pure\n                    function new_label (level, first, last, text, primary)","tags":"","url":"module/tomlf_diagnostic.html"},{"title":"tomlf_structure_array_list – TOML-Fortran","text":"Implementation of a basic storage structure as pointer list of pointers. This implementation does purposely not use pointer attributes in the\ndatastructure to make it safer to work with. Uses tomlf_structure_list tomlf_type_value tomlf_constants tomlf_structure_node Derived Types type, public, extends( toml_list_structure ) :: toml_array_list Stores TOML values in a list of pointers Components Type Visibility Attributes Name Initial type( toml_node ), public, allocatable :: lst (:) List of TOML values integer, public :: n = 0 Current number of stored TOML values Type-Bound Procedures procedure, public :: destroy Destroy the data structure procedure, public :: get Get TOML value at a given index procedure, public :: get_len Get number of TOML values in the structure procedure, public :: pop Remove the last element from the structure procedure, public :: push_back Push back a TOML value to the structure procedure, public :: shift Remove the first element from the structure Subroutines public  subroutine new_array_list (self, n) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name type( toml_array_list ), intent(out) :: self Instance of the structure integer, intent(in), optional :: n Initial storage capacity","tags":"","url":"module/tomlf_structure_array_list.html"},{"title":"tomlf_build_path – TOML-Fortran","text":"Support for retrieving and setting values using a key path. Uses tomlf_error tomlf_build_table tomlf_datetime tomlf_type tomlf_constants Interfaces public        interface get_value Getter functions to manipulate TOML tables private  subroutine get_path_table(table, path, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout), target :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_table ), intent(out), pointer :: ptr Pointer to child table logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_array(table, path, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_array ), intent(out), pointer :: ptr Pointer to child array logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_keyval(table, path, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_float_sp(table, path, val, default, stat, origin) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table real(kind=tf_sp), intent(out) :: val Real value real(kind=tf_sp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_float_dp(table, path, val, default, stat, origin) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table real(kind=tf_dp), intent(out) :: val Real value real(kind=tf_dp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_integer_i1(table, path, val, default, stat, origin) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i1), intent(out) :: val Integer value integer(kind=tf_i1), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_integer_i2(table, path, val, default, stat, origin) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i2), intent(out) :: val Integer value integer(kind=tf_i2), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_integer_i4(table, path, val, default, stat, origin) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i4), intent(out) :: val Integer value integer(kind=tf_i4), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_integer_i8(table, path, val, default, stat, origin) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i8), intent(out) :: val Integer value integer(kind=tf_i8), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_bool(table, path, val, default, stat, origin) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table logical, intent(out) :: val Boolean value logical, intent(in), optional :: default Default boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_datetime(table, path, val, default, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_datetime ), intent(out) :: val Datetime value type( toml_datetime ), intent(in), optional :: default Default datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_path_value_string(table, path, val, default, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table character(kind=tfc, len=:), intent(out), allocatable :: val String value character(kind=tfc, len=*), intent(in), optional :: default Default string value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure public        interface set_value Setter functions to manipulate TOML tables private  subroutine set_path_value_float_sp(table, path, val, stat, origin) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_float_dp(table, path, val, stat, origin) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_integer_i1(table, path, val, stat, origin) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_integer_i2(table, path, val, stat, origin) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_integer_i4(table, path, val, stat, origin) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_integer_i8(table, path, val, stat, origin) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_bool(table, path, val, stat, origin) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_datetime(table, path, val, stat, origin) Set TOML value to datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_path_value_string(table, path, val, stat, origin) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_path ), intent(in) :: path Path in this TOML table character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure public        interface toml_path Convenience constructors for building key paths from strings instead of keys private pure function new_path2(key1, key2) result(path) Create a new path with two components Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key1 First key to retrieve character(len=*), intent(in) :: key2 Second key to retrieve Return Value type( toml_path ) New path private pure function new_path3(key1, key2, key3) result(path) Create a new path with three components Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: key1 First key to retrieve character(kind=tfc, len=*), intent(in) :: key2 Second key to retrieve character(kind=tfc, len=*), intent(in) :: key3 Third key to retrieve Return Value type( toml_path ) New path private pure function new_path4(key1, key2, key3, key4) result(path) Create a new path with three components Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: key1 First key to retrieve character(kind=tfc, len=*), intent(in) :: key2 Second key to retrieve character(kind=tfc, len=*), intent(in) :: key3 Third key to retrieve character(kind=tfc, len=*), intent(in) :: key4 Forth key to retrieve Return Value type( toml_path ) New path Derived Types type, public :: toml_path Wrapper for storing key paths Components Type Visibility Attributes Name Initial type( toml_key ), public, allocatable :: path (:) Path components Constructor Convenience constructors for building key paths from strings instead of keys private\n\n                    pure\n                    function new_path2 (key1, key2) Create a new path with two components private\n\n                    pure\n                    function new_path3 (key1, key2, key3) Create a new path with three components private\n\n                    pure\n                    function new_path4 (key1, key2, key3, key4) Create a new path with three components","tags":"","url":"module/tomlf_build_path.html"},{"title":"tomlf_type_table – TOML-Fortran","text":"Implementation of the TOML table data type. Every TOML document contains at least one (root) table which holds key-value\npairs, arrays and other tables. Uses tomlf_structure tomlf_error tomlf_constants tomlf_type_value Interfaces public        interface initialized Check whether data structure is initialized properly private pure function table_initialized(self) result(okay) Check whether data structure is initialized properly Arguments Type Intent Optional Attributes Name type( toml_table ), intent(in) :: self Instance of the TOML table Return Value logical Data structure is initialized public        interface new Overloaded constructor for TOML values public  subroutine new_table (self) Constructor to create a new TOML table and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out) :: self Instance of the TOML table public        interface toml_table Create standard constructor private  function new_table_func() result(self) Default constructor for TOML table type Arguments None Return Value type( toml_table ) Instance of the TOML table Derived Types type, public, extends( toml_value ) :: toml_table TOML table Components Type Visibility Attributes Name Initial logical, public :: implicit = .false. Table was implictly created logical, public :: inline = .false. Is an inline table and is therefore non-extendable character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value Constructor Create standard constructor private\n\n                    \n                    function new_table_func () Default constructor for TOML table type Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure procedure, public :: delete Delete TOML value at a given key procedure, public :: destroy Release allocation hold by TOML table procedure, public :: get Get the TOML value associated with the respective key procedure, public :: get_key Get escaped key to TOML value procedure, public :: get_keys Get list of all keys in this table procedure, public :: has_key Check if key is already present in this table instance procedure, public :: match_key Compare raw key of TOML value to input key procedure, public :: pop Remove TOML value at a given key and return it procedure, public :: push_back Append value to table (checks automatically for key) Subroutines public  subroutine new_table (self) Constructor to create a new TOML table and allocate the internal storage Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out) :: self Instance of the TOML table","tags":"","url":"module/tomlf_type_table.html"},{"title":"tomlf_terminal – TOML-Fortran","text":"Implementation of a terminal to provide ANSI escape sequences ANSI escape codes for producing terminal colors. The ansi_code derived\ntype is used to store ANSI escape codes and can be combined with other\ncodes or applied to strings by concatenation. The default or uninitialized ansi_code is a stub and does not produce escape sequences when applied\nto a string. Available colors are color foreground background black black (30) bg_black (40) red red (31) bg_red (41) green green (32) bg_green (42) yellow yellow (33) bg_yellow (43) blue blue (34) bg_blue (44) magenta magenta (35) bg_magenta (45) cyan cyan (36) bg_cyan (46) white white (37) bg_white (47) gray gray (90) bg_gray (100) bright red bright_red (91) bg_bright_red (101) bright green bright_green (92) bg_bright_green (102) bright yellow bright_yellow (93) bg_bright_yellow (103) bright blue bright_blue (94) bg_bright_blue (104) bright magenta bright_magenta (95) bg_bright_magenta (105) bright cyan bright_cyan (96) bg_bright_cyan (106) bright white bright_white (97) bg_bright_white (107) Available styles are style       |\n------------| ---------------\nreset       | reset (0)\nbold        | bold (1)\ndim         | dim (2)\nitalic      | italic (3)\nunderline   | underline (4)\nblink       | blink (5)\nblink rapid | blink_rapid (6)\nreverse     | reverse (7)\nhidden      | hidden (8)\ncrossed     | crossed (9) Uses tomlf_utils Variables Type Visibility Attributes Name Initial type( ansi_code ), public, parameter :: bg_black = ansi_code(bg=40_i1) type( ansi_code ), public, parameter :: bg_blue = ansi_code(bg=44_i1) type( ansi_code ), public, parameter :: bg_bright_blue = ansi_code(bg=104_i1) type( ansi_code ), public, parameter :: bg_bright_cyan = ansi_code(bg=106_i1) type( ansi_code ), public, parameter :: bg_bright_green = ansi_code(bg=102_i1) type( ansi_code ), public, parameter :: bg_bright_magenta = ansi_code(bg=105_i1) type( ansi_code ), public, parameter :: bg_bright_red = ansi_code(bg=101_i1) type( ansi_code ), public, parameter :: bg_bright_white = ansi_code(bg=107_i1) type( ansi_code ), public, parameter :: bg_bright_yellow = ansi_code(bg=103_i1) type( ansi_code ), public, parameter :: bg_cyan = ansi_code(bg=46_i1) type( ansi_code ), public, parameter :: bg_gray = ansi_code(bg=100_i1) type( ansi_code ), public, parameter :: bg_green = ansi_code(bg=42_i1) type( ansi_code ), public, parameter :: bg_magenta = ansi_code(bg=45_i1) type( ansi_code ), public, parameter :: bg_red = ansi_code(bg=41_i1) type( ansi_code ), public, parameter :: bg_white = ansi_code(bg=47_i1) type( ansi_code ), public, parameter :: bg_yellow = ansi_code(bg=43_i1) type( ansi_code ), public, parameter :: black = ansi_code(fg=30_i1) type( ansi_code ), public, parameter :: blink = ansi_code(style=5_i1) type( ansi_code ), public, parameter :: blink_rapid = ansi_code(style=6_i1) type( ansi_code ), public, parameter :: blue = ansi_code(fg=34_i1) type( ansi_code ), public, parameter :: bold = ansi_code(style=1_i1) type( ansi_code ), public, parameter :: bright_blue = ansi_code(fg=94_i1) type( ansi_code ), public, parameter :: bright_cyan = ansi_code(fg=96_i1) type( ansi_code ), public, parameter :: bright_green = ansi_code(fg=92_i1) type( ansi_code ), public, parameter :: bright_magenta = ansi_code(fg=95_i1) type( ansi_code ), public, parameter :: bright_red = ansi_code(fg=91_i1) type( ansi_code ), public, parameter :: bright_white = ansi_code(fg=97_i1) type( ansi_code ), public, parameter :: bright_yellow = ansi_code(fg=93_i1) type( ansi_code ), public, parameter :: crossed = ansi_code(style=9_i1) type( ansi_code ), public, parameter :: cyan = ansi_code(fg=36_i1) type( ansi_code ), public, parameter :: dim = ansi_code(style=2_i1) type( ansi_code ), public, parameter :: gray = ansi_code(fg=90_i1) type( ansi_code ), public, parameter :: green = ansi_code(fg=32_i1) type( ansi_code ), public, parameter :: hidden = ansi_code(style=8_i1) type( ansi_code ), public, parameter :: italic = ansi_code(style=3_i1) type( ansi_code ), public, parameter :: magenta = ansi_code(fg=35_i1) type( ansi_code ), public, parameter :: red = ansi_code(fg=31_i1) type( ansi_code ), public, parameter :: reset = ansi_code(style=0_i1) type( ansi_code ), public, parameter :: reverse = ansi_code(style=7_i1) type( ansi_code ), public, parameter :: underline = ansi_code(style=4_i1) type( ansi_code ), public, parameter :: white = ansi_code(fg=37_i1) type( ansi_code ), public, parameter :: yellow = ansi_code(fg=33_i1) Interfaces public        interface operator(+) private pure function add(lval, rval) result(code) Add two escape sequences, attributes in the right value override the left value ones. Arguments Type Intent Optional Attributes Name type( ansi_code ), intent(in) :: lval First escape code type( ansi_code ), intent(in) :: rval Second escape code Return Value type( ansi_code ) Combined escape code public        interface operator(//) private pure function concat_left(lval, code) result(str) Concatenate an escape code with a string and turn it into an actual escape sequence Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lval String to add the escape code to type( ansi_code ), intent(in) :: code Escape sequence Return Value character(len=:), allocatable Concatenated string private pure function concat_right(code, rval) result(str) Concatenate an escape code with a string and turn it into an actual escape sequence Arguments Type Intent Optional Attributes Name type( ansi_code ), intent(in) :: code Escape sequence character(len=*), intent(in) :: rval String to add the escape code to Return Value character(len=:), allocatable Concatenated string public        interface toml_terminal Constructor to create new terminal private pure function new_terminal(use_color) result(new) Create new terminal Arguments Type Intent Optional Attributes Name logical, intent(in) :: use_color Enable color support in terminal Return Value type( toml_terminal ) New terminal instance Derived Types type, public :: ansi_code Container for terminal escape code type, public :: toml_terminal Terminal wrapper to handle color escape sequences, must be initialized with\ncolor support to provide colorful output. Default and uninitialized instances\nwill remain usable but provide only stubs and do not produce colorful output.\nThis behavior is useful for creating applications which can toggle color support. Components Type Visibility Attributes Name Initial type( ansi_code ), public :: bg_black = ansi_code() type( ansi_code ), public :: bg_blue = ansi_code() type( ansi_code ), public :: bg_bright_blue = ansi_code() type( ansi_code ), public :: bg_bright_cyan = ansi_code() type( ansi_code ), public :: bg_bright_green = ansi_code() type( ansi_code ), public :: bg_bright_magenta = ansi_code() type( ansi_code ), public :: bg_bright_red = ansi_code() type( ansi_code ), public :: bg_bright_white = ansi_code() type( ansi_code ), public :: bg_bright_yellow = ansi_code() type( ansi_code ), public :: bg_cyan = ansi_code() type( ansi_code ), public :: bg_gray = ansi_code() type( ansi_code ), public :: bg_green = ansi_code() type( ansi_code ), public :: bg_magenta = ansi_code() type( ansi_code ), public :: bg_red = ansi_code() type( ansi_code ), public :: bg_white = ansi_code() type( ansi_code ), public :: bg_yellow = ansi_code() type( ansi_code ), public :: black = ansi_code() type( ansi_code ), public :: blink = ansi_code() type( ansi_code ), public :: blink_rapid = ansi_code() type( ansi_code ), public :: blue = ansi_code() type( ansi_code ), public :: bold = ansi_code() type( ansi_code ), public :: bright_blue = ansi_code() type( ansi_code ), public :: bright_cyan = ansi_code() type( ansi_code ), public :: bright_green = ansi_code() type( ansi_code ), public :: bright_magenta = ansi_code() type( ansi_code ), public :: bright_red = ansi_code() type( ansi_code ), public :: bright_white = ansi_code() type( ansi_code ), public :: bright_yellow = ansi_code() type( ansi_code ), public :: crossed = ansi_code() type( ansi_code ), public :: cyan = ansi_code() type( ansi_code ), public :: dim = ansi_code() type( ansi_code ), public :: gray = ansi_code() type( ansi_code ), public :: green = ansi_code() type( ansi_code ), public :: hidden = ansi_code() type( ansi_code ), public :: italic = ansi_code() type( ansi_code ), public :: magenta = ansi_code() type( ansi_code ), public :: red = ansi_code() type( ansi_code ), public :: reset = ansi_code() type( ansi_code ), public :: reverse = ansi_code() type( ansi_code ), public :: underline = ansi_code() type( ansi_code ), public :: white = ansi_code() type( ansi_code ), public :: yellow = ansi_code() Constructor Constructor to create new terminal private\n\n                    pure\n                    function new_terminal (use_color) Create new terminal Functions public pure function escape (code) result(str) Transform a color code into an actual ANSI escape sequence Arguments Type Intent Optional Attributes Name type( ansi_code ), intent(in) :: code Color code to be used Return Value character(len=:), allocatable ANSI escape sequence representing the color code","tags":"","url":"module/tomlf_terminal.html"},{"title":"tomlf_version – TOML-Fortran","text":"Version information on TOML-Fortran Variables Type Visibility Attributes Name Initial integer, public, parameter :: tomlf_version_compact = tomlf_major*10000+tomlf_minor*100+tomlf_patch Compact numeric representation of the TOML-Fortran version character(len=*), public, parameter :: tomlf_version_string = \"0.4.3\" String representation of the TOML-Fortran version Subroutines public  subroutine get_tomlf_version (major, minor, patch, string) Getter function to retrieve TOML-Fortran version Arguments Type Intent Optional Attributes Name integer, intent(out), optional :: major Major version number of the TOML-Fortran version integer, intent(out), optional :: minor Minor version number of the TOML-Fortran version integer, intent(out), optional :: patch Patch version number of the TOML-Fortran version character(len=:), intent(out), optional, allocatable :: string String representation of the TOML-Fortran version","tags":"","url":"module/tomlf_version.html"},{"title":"tomlf_type – TOML-Fortran","text":"Collection of the central datatypes to define TOML data structures All TOML data types should inherit from an abstract value allowing to generate\na generic interface to deal with all more specialized TOML data types, while\nthe abstract value is interesting for developing algorithms in TOML-Fortran,\nthe user of TOML-Fortran will usually only care about TOML tables and possibly\narrays. The TOML types defined here should implement the TOML data structures (mostly)\nwithout taking the actual implementation of the data structures into account.\nThis is done by providing a bare minimum interface using type bound procedures\nto minimize the interdependencies between the datatypes. To make the data types extendable a visitor pattern allows access to the TOML\ndata types and can be used to implement further algorithms. Uses tomlf_type_keyval tomlf_error tomlf_type_table tomlf_type_value tomlf_constants tomlf_type_array Interfaces public        interface add_array Interface to build new arrays private  subroutine add_array_to_table(table, key, ptr, stat) Create a new TOML array inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key for the new array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation private  subroutine add_array_to_table_key(table, key, ptr, stat) Create a new TOML array inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key for the new array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation private  subroutine add_array_to_array(array, ptr, stat) Create a new TOML array inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_array ), intent(out), pointer :: ptr Pointer to the newly created array integer, intent(out), optional :: stat Status of operation public        interface add_keyval Interface to build new key-value pairs private  subroutine add_keyval_to_table(table, key, ptr, stat) Create a new key-value pair inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key for the new key-value pair type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation private  subroutine add_keyval_to_table_key(table, key, ptr, stat) Create a new key-value pair inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key for the new key-value pair type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation private  subroutine add_keyval_to_array(array, ptr, stat) Create a new key-value pair inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_keyval ), intent(out), pointer :: ptr Pointer to the newly created key-value pair integer, intent(out), optional :: stat Status of operation public        interface add_table Interface to build new tables private  subroutine add_table_to_table(table, key, ptr, stat) Create a new TOML table inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key for the new table type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation private  subroutine add_table_to_table_key(table, key, ptr, stat) Create a new TOML table inside an existing table Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key for the new table type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation private  subroutine add_table_to_array(array, ptr, stat) Create a new TOML table inside an existing array Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_table ), intent(out), pointer :: ptr Pointer to the newly created table integer, intent(out), optional :: stat Status of operation Functions public  function cast_to_array (ptr) result(array) Cast an abstract TOML value to a TOML array Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in), target :: ptr TOML value to be casted Return Value type( toml_array ), pointer TOML array view, nullified if the value is not an array public  function cast_to_keyval (ptr) result(kval) Cast an abstract TOML value to a TOML key-value pair Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in), target :: ptr TOML value to be casted Return Value type( toml_keyval ), pointer TOML key-value view, nullified if the value is not a table public  function cast_to_table (ptr) result(table) Cast an abstract TOML value to a TOML table Arguments Type Intent Optional Attributes Name class( toml_value ), intent(in), target :: ptr TOML value to be casted Return Value type( toml_table ), pointer TOML table view, nullified if the value is not a table public  function is_array_of_tables (array) result(only_tables) Determine if array contains only tables Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array TOML value to visit Return Value logical Array contains only tables","tags":"","url":"module/tomlf_type.html"},{"title":"tomlf_structure_ordered_map – TOML-Fortran","text":"Implementation of a basic storage structure as pointer list of pointers. This implementation does purposely not use pointer attributes in the\ndatastructure to make it safer to work with. Uses tomlf_structure_map tomlf_type_value tomlf_constants tomlf_structure_node Derived Types type, public, extends( toml_map_structure ) :: toml_ordered_map Stores TOML values in a list of pointers Components Type Visibility Attributes Name Initial type( toml_node ), public, allocatable :: lst (:) List of TOML values integer, public :: n = 0 Current number of stored TOML values Type-Bound Procedures procedure, public :: delete Delete TOML value at a given key procedure, public :: destroy Destroy the data structure procedure, public :: get Get TOML value at a given key procedure, public :: get_keys Get list of all keys in the structure procedure, public :: pop Remove TOML value at a given key and return it procedure, public :: push_back Push back a TOML value to the structure Subroutines public  subroutine new_ordered_map (self, n) Constructor for the storage data structure Arguments Type Intent Optional Attributes Name type( toml_ordered_map ), intent(out) :: self Instance of the structure integer, intent(in), optional :: n Initial storage capacity","tags":"","url":"module/tomlf_structure_ordered_map.html"},{"title":"tomlf_utils_io – TOML-Fortran","text":"Utilities for handling input and output operations Uses tomlf_constants Subroutines public  subroutine read_whole_file (filename, string, stat) Read a whole file into an array of characters Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: filename File to read character(kind=tfc, len=:), intent(out), allocatable :: string Array of characters representing the file integer, intent(out) :: stat Error status public  subroutine read_whole_line (io, string, stat) Read a whole line from a formatted unit into a deferred length character variable Arguments Type Intent Optional Attributes Name integer, intent(in) :: io Formatted IO unit character(kind=tfc, len=:), intent(out), allocatable :: string Line to read integer, intent(out) :: stat Status of operation","tags":"","url":"module/tomlf_utils_io.html"},{"title":"tomlf_build_array – TOML-Fortran","text":"Functions to build TOML arrays. This build module defines a high level interface to work with TOML arrays\nand construct them in a convenient way. The access to the array elements happens by position in the array, the indexing\nis one based, following the language convention of Fortran. All functions\nwill only allow access of elements within the bounds of the array, specifying\nindices out-of-bounds should be save, as it only sets the status of operation.\nThe getter functions allow access to other tables and arrays as well as\nconvenient wrappers to retrieve value data The setter functions are somewhat weaker compared to the setter functions\navailable for TOML tables. To limit the potential havoc this routines can\ncause they can only access the array within its bounds. Setting a value to\nanother value will overwrite it, while setting a value to a table or an array\nwill fail, for safety reasons. To (re)build an array appending to it is the best choice, tables and arrays\nshould always be create by using the corresponding add_table and add_array function. While this can become cumbersome for values, the setter routines\nallow out-of-bound access to for the next element in an array and will indeed\njust append a new value to it. Uses tomlf_build_keyval tomlf_error tomlf_datetime tomlf_type tomlf_constants Interfaces public        interface get_value Getter functions to manipulate TOML arrays private  subroutine get_elem_table(array, pos, ptr, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_table ), intent(out), pointer :: ptr Pointer to child table integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_array(array, pos, ptr, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_array ), intent(out), pointer :: ptr Pointer to child array integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_keyval(array, pos, ptr, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_string(array, pos, val, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array character(kind=tfc, len=:), intent(out), allocatable :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_float_sp(array, pos, val, stat, origin) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_sp), intent(out) :: val Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_float_dp(array, pos, val, stat, origin) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_dp), intent(out) :: val Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_int_i1(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i1), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_int_i2(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i2), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_int_i4(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i4), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_int_i8(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i8), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_bool(array, pos, val, stat, origin) Retrieve TOML value as boolean Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array logical, intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_elem_value_datetime(array, pos, val, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_datetime ), intent(out) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_float_sp(array, val, stat, origin) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array real(kind=tf_sp), intent(out), allocatable :: val (:) Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_float_dp(array, val, stat, origin) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array real(kind=tf_dp), intent(out), allocatable :: val (:) Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_int_i1(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i1), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_int_i2(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i2), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_int_i4(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i4), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_int_i8(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i8), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_bool(array, val, stat, origin) Retrieve TOML value as boolean Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array logical, intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_array_value_datetime(array, val, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_datetime ), intent(out), allocatable :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure public        interface set_value Setter functions to manipulate TOML arrays private  subroutine set_elem_value_string(array, pos, val, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_float_sp(array, pos, val, stat, origin) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_sp), intent(in) :: val Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_float_dp(array, pos, val, stat, origin) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array real(kind=tf_dp), intent(in) :: val Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_int_i1(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_int_i2(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_int_i4(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_int_i8(array, pos, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_bool(array, pos, val, stat, origin) Retrieve TOML value as boolean value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_elem_value_datetime(array, pos, val, stat, origin) Retrieve TOML value as datetime value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer, intent(in) :: pos Position in the array type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_float_sp(array, val, stat, origin) Retrieve TOML value as single precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array real(kind=tf_sp), intent(in) :: val (:) Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_float_dp(array, val, stat, origin) Retrieve TOML value as double precision floating point number Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array real(kind=tf_dp), intent(in) :: val (:) Floating point value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_int_i1(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i1), intent(in) :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_int_i2(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i2), intent(in) :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_int_i4(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i4), intent(in) :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_int_i8(array, val, stat, origin) Retrieve TOML value as integer value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array integer(kind=tf_i8), intent(in) :: val (:) Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_bool(array, val, stat, origin) Retrieve TOML value as boolean value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array logical, intent(in) :: val (:) Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_array_value_datetime(array, val, stat, origin) Retrieve TOML value as datetime value Arguments Type Intent Optional Attributes Name class( toml_array ), intent(inout) :: array Instance of the TOML array type( toml_datetime ), intent(in) :: val (:) Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"module/tomlf_build_array.html"},{"title":"tomlf – TOML-Fortran","text":"Minimal public API for TOML-Fortran Uses tomlf_version tomlf_ser tomlf_error tomlf_utils_sort tomlf_de tomlf_datetime tomlf_type tomlf_build tomlf_terminal","tags":"","url":"module/tomlf.html"},{"title":"tomlf_all – TOML-Fortran","text":"Complete reexport of the public API of TOML-Fortran Uses tomlf_utils tomlf_version tomlf_ser tomlf_structure tomlf_error tomlf_de tomlf_datetime tomlf_type tomlf_build tomlf_constants","tags":"","url":"module/tomlf_all.html"},{"title":"tomlf_type_keyval – TOML-Fortran","text":"TOML key-value pair Uses tomlf_datetime tomlf_constants tomlf_type_value Interfaces public        interface new Overloaded constructor for TOML values public  subroutine new_keyval (self) Constructor to create a new TOML key-value pair Arguments Type Intent Optional Attributes Name type( toml_keyval ), intent(out) :: self Instance of the TOML key-value pair Derived Types type, public, extends( toml_value ) :: toml_keyval TOML key-value pair Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: key Raw representation of the key to the TOML value integer, public :: origin = 0 Original source of the value integer, public :: origin_value = 0 Origin of value class(generic_value), public, allocatable :: val Actual TOML value Type-Bound Procedures procedure, public :: accept Accept a visitor to transverse the data structure procedure, public :: destroy Release allocation hold by TOML key-value pair generic, public :: get => get_float , get_integer , get_boolean , get_datetime , get_string Get the value stored in the key-value pair procedure, public :: get_boolean procedure, public :: get_datetime procedure, public :: get_float procedure, public :: get_integer procedure, public :: get_key Get escaped key to TOML value procedure, public :: get_string procedure, public :: get_type Get the type of the value stored in the key-value pair procedure, public :: match_key Compare raw key of TOML value to input key generic, public :: set => set_float , set_integer , set_boolean , set_datetime , set_string Set the value for the key-value pair procedure, public :: set_boolean procedure, public :: set_datetime procedure, public :: set_float procedure, public :: set_integer procedure, public :: set_string Subroutines public  subroutine new_keyval (self) Constructor to create a new TOML key-value pair Arguments Type Intent Optional Attributes Name type( toml_keyval ), intent(out) :: self Instance of the TOML key-value pair","tags":"","url":"module/tomlf_type_keyval.html"},{"title":"tomlf_build_table – TOML-Fortran","text":"Functions to build TOML tables The build module defines a high level interface to work with TOML tables\nand construct them in a convenient way. The getter functions allow to both retrieve and set values, to easily\nsupport default values when reading from a TOML data structure.\nUsing the getter function with a default value specified will request\nthe respective setter function to add it to the table if it was not\nfound in the first place. This allows to build a TOML table using only the getter functions, which\nrepresents the finally read values for the applications. Note that neither setter nor getter functions can overwrite existing\nTOML values for safety reasons, request the deletion on the respective\nkey from the TOML table and than set it. The deletion of a subtable or\narray will recursively destroy the contained data nodes. Uses tomlf_build_keyval tomlf_error tomlf_datetime tomlf_type tomlf_constants Interfaces public        interface get_value Getter functions to manipulate TOML tables private  subroutine get_child_table(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_table ), intent(out), pointer :: ptr Pointer to child table logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_array(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_array ), intent(out), pointer :: ptr Pointer to child array logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_keyval(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_float_sp(table, key, val, default, stat, origin) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(out) :: val Real value real(kind=tf_sp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_float_dp(table, key, val, default, stat, origin) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(out) :: val Real value real(kind=tf_dp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_integer_i1(table, key, val, default, stat, origin) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(out) :: val Integer value integer(kind=tf_i1), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_integer_i2(table, key, val, default, stat, origin) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(out) :: val Integer value integer(kind=tf_i2), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_integer_i4(table, key, val, default, stat, origin) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(out) :: val Integer value integer(kind=tf_i4), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_integer_i8(table, key, val, default, stat, origin) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(out) :: val Integer value integer(kind=tf_i8), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_bool(table, key, val, default, stat, origin) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table logical, intent(out) :: val Boolean value logical, intent(in), optional :: default Default boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_datetime(table, key, val, default, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_datetime ), intent(out) :: val Datetime value type( toml_datetime ), intent(in), optional :: default Default datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_child_value_string(table, key, val, default, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table character(kind=tfc, len=:), intent(out), allocatable :: val String value character(kind=tfc, len=*), intent(in), optional :: default Default string value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_table(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_table ), intent(out), pointer :: ptr Pointer to child table logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_array(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_array ), intent(out), pointer :: ptr Pointer to child array logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_keyval(table, key, ptr, requested, stat, origin) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_keyval ), intent(out), pointer :: ptr Pointer to child value logical, intent(in), optional :: requested Child value must be present integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_float_sp(table, key, val, default, stat, origin) Retrieve TOML value as single precision float (might lose accuracy) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(out) :: val Real value real(kind=tf_sp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_float_dp(table, key, val, default, stat, origin) Retrieve TOML value as double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(out) :: val Real value real(kind=tf_dp), intent(in), optional :: default Default real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_integer_i1(table, key, val, default, stat, origin) Retrieve TOML value as one byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(out) :: val Integer value integer(kind=tf_i1), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_integer_i2(table, key, val, default, stat, origin) Retrieve TOML value as two byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(out) :: val Integer value integer(kind=tf_i2), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_integer_i4(table, key, val, default, stat, origin) Retrieve TOML value as four byte integer (might loose precision) Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(out) :: val Integer value integer(kind=tf_i4), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_integer_i8(table, key, val, default, stat, origin) Retrieve TOML value as eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(out) :: val Integer value integer(kind=tf_i8), intent(in), optional :: default Default integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_bool(table, key, val, default, stat, origin) Retrieve TOML value as logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table logical, intent(out) :: val Boolean value logical, intent(in), optional :: default Default boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_datetime(table, key, val, default, stat, origin) Retrieve TOML value as datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_datetime ), intent(out) :: val Datetime value type( toml_datetime ), intent(in), optional :: default Default datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine get_key_value_string(table, key, val, default, stat, origin) Retrieve TOML value as deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table character(kind=tfc, len=:), intent(out), allocatable :: val String value character(kind=tfc, len=*), intent(in), optional :: default Default string value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure public        interface set_value Setter functions to manipulate TOML tables private  subroutine set_child_value_float_sp(table, key, val, stat, origin) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_float_dp(table, key, val, stat, origin) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_integer_i1(table, key, val, stat, origin) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_integer_i2(table, key, val, stat, origin) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_integer_i4(table, key, val, stat, origin) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_integer_i8(table, key, val, stat, origin) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_bool(table, key, val, stat, origin) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_datetime(table, key, val, stat, origin) Set TOML value to datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_child_value_string(table, key, val, stat, origin) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table character(kind=tfc, len=*), intent(in) :: key Key in this TOML table character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_float_sp(table, key, val, stat, origin) Set TOML value to single precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table real(kind=tf_sp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_float_dp(table, key, val, stat, origin) Set TOML value to double precision float Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table real(kind=tf_dp), intent(in) :: val Real value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_integer_i1(table, key, val, stat, origin) Set TOML value to one byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i1), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_integer_i2(table, key, val, stat, origin) Set TOML value to two byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i2), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_integer_i4(table, key, val, stat, origin) Set TOML value to four byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i4), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_integer_i8(table, key, val, stat, origin) Set TOML value to eight byte integer Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table integer(kind=tf_i8), intent(in) :: val Integer value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_bool(table, key, val, stat, origin) Set TOML value to logical Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table logical, intent(in) :: val Boolean value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_datetime(table, key, val, stat, origin) Set TOML value to datetime Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table type( toml_datetime ), intent(in) :: val Datetime value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure private  subroutine set_key_value_string(table, key, val, stat, origin) Set TOML value to deferred-length character Arguments Type Intent Optional Attributes Name class( toml_table ), intent(inout) :: table Instance of the TOML table type( toml_key ), intent(in) :: key Key in this TOML table character(kind=tfc, len=*), intent(in) :: val String value integer, intent(out), optional :: stat Status of operation integer, intent(out), optional :: origin Origin in the data structure","tags":"","url":"module/tomlf_build_table.html"},{"title":"tomlf_constants – TOML-Fortran","text":"Uses iso_fortran_env Variables Type Visibility Attributes Name Initial character(kind=tfc, len=*), public, parameter :: TOML_BACKSPACE = achar(8) character(kind=tfc, len=*), public, parameter :: TOML_BAREKEY = TOML_LETTERS//TOML_DIGITS//'_-' Allowed characters in TOML bare keys. character(kind=tfc, len=*), public, parameter :: TOML_BINDIGITS = '01' character(kind=tfc, len=*), public, parameter :: TOML_CARRIAGE_RETURN = achar(13) character(kind=tfc, len=*), public, parameter :: TOML_DIGITS = '0123456789' character(kind=tfc, len=*), public, parameter :: TOML_DQUOTE = '\"' Double quotes denote strings (with escape character possible) character(kind=tfc, len=*), public, parameter :: TOML_FORMFEED = achar(12) character(kind=tfc, len=*), public, parameter :: TOML_HEXDIGITS = '0123456789ABCDEFabcdef' character(kind=tfc, len=*), public, parameter :: TOML_LETTERS = TOML_LOWERCASE//TOML_UPPERCASE character(kind=tfc, len=*), public, parameter :: TOML_LITERALS = TOML_LETTERS//TOML_DIGITS//'_-+.' character(kind=tfc, len=*), public, parameter :: TOML_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz' character(kind=tfc, len=*), public, parameter :: TOML_NEWLINE = new_line('a') character(kind=tfc, len=*), public, parameter :: TOML_OCTDIGITS = '01234567' character(kind=tfc, len=*), public, parameter :: TOML_SQUOTE = \"'\" Single quotes denote literal strings character(kind=tfc, len=*), public, parameter :: TOML_TABULATOR = achar(9) character(kind=tfc, len=*), public, parameter :: TOML_TIMESTAMP = TOML_DIGITS//'.:+-T Zz' character(kind=tfc, len=*), public, parameter :: TOML_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' character(kind=tfc, len=*), public, parameter :: TOML_WHITESPACE = ' '//toml_escape%tabulator Whitespace in TOML are blanks and tabs. integer, public, parameter :: tf_dp = selected_real_kind(15) Double precision real numbers integer, public, parameter :: tf_i1 = selected_int_kind(2) Char length for integers integer, public, parameter :: tf_i2 = selected_int_kind(4) Short length for integers integer, public, parameter :: tf_i4 = selected_int_kind(9) Length of default integers integer, public, parameter :: tf_i8 = selected_int_kind(18) Long length for integers integer, public, parameter :: tf_sp = selected_real_kind(6) Single precision real numbers integer, public, parameter :: tfc = selected_char_kind('DEFAULT') Default character kind integer, public, parameter :: tfi = tf_i8 Default integer precision, 64 bit (signed long) range expected integer, public, parameter :: tfout = output_unit Default output channel integer, public, parameter :: tfr = tf_dp Default float precision, IEEE 754 binary64 values expected type(enum_escape), public, parameter :: toml_escape = enum_escape() Actual enumerator with TOML escape characters type(enum_type), public, parameter :: toml_type = enum_type() Actual enumerator with TOML value types","tags":"","url":"module/tomlf_constants.html"},{"title":"tomlf_ser – TOML-Fortran","text":"TOML serializer implementation Uses tomlf_error tomlf_datetime tomlf_type tomlf_utils tomlf_constants Interfaces public        interface new Overloaded constructor for TOML serializers public  subroutine new_serializer (self, config) Constructor to create new serializer instance Arguments Type Intent Optional Attributes Name type( toml_serializer ), intent(out) :: self Instance of the TOML serializer type(toml_ser_config), intent(in), optional :: config Configuration for serializer public        interface toml_dump private  subroutine toml_dump_to_file(val, filename, error, config) Write string representation of JSON value to a file Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: val TOML value to visit character(len=*), intent(in) :: filename File name to write to type( toml_error ), intent(out), allocatable :: error Error handling type(toml_ser_config), intent(in), optional :: config Configuration for serializer private  subroutine toml_dump_to_unit(val, io, error, config) Write string representation of JSON value to a connected formatted unit Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: val TOML value to visit integer, intent(in) :: io Formatted unit to write to type( toml_error ), intent(out), allocatable :: error Error handling type(toml_ser_config), intent(in), optional :: config Configuration for serializer public        interface toml_dumps private  subroutine toml_dump_to_string(val, string, error, config) Create a string representing the JSON value Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: val TOML value to visit character(len=:), intent(out), allocatable :: string Formatted unit to write to type( toml_error ), intent(out), allocatable :: error Error handling type(toml_ser_config), intent(in), optional :: config Configuration for serializer public        interface toml_serializer Create standard constructor private  function new_serializer_func(config) result(self) Default constructor for TOML serializer Arguments Type Intent Optional Attributes Name type(toml_ser_config), intent(in), optional :: config Configuration for serializer Return Value type( toml_serializer ) Instance of the TOML serializer Derived Types type, public, extends( toml_visitor ) :: toml_serializer TOML serializer to produduce a TOML document from a datastructure Constructor Create standard constructor private\n\n                    \n                    function new_serializer_func (config) Default constructor for TOML serializer Type-Bound Procedures procedure, public :: visit Visit a TOML value Functions public  function toml_serialize (val, config) result(string) Serialize a JSON value to a string and return it. Read more… Arguments Type Intent Optional Attributes Name class( toml_value ), intent(inout) :: val TOML value to visit type(toml_ser_config), intent(in), optional :: config Configuration for serializer Return Value character(len=:), allocatable Serialized JSON value Subroutines public  subroutine new_serializer (self, config) Constructor to create new serializer instance Arguments Type Intent Optional Attributes Name type( toml_serializer ), intent(out) :: self Instance of the TOML serializer type(toml_ser_config), intent(in), optional :: config Configuration for serializer","tags":"","url":"module/tomlf_ser.html"},{"title":"tomlf_de_abc – TOML-Fortran","text":"Defines the abstract base class which is implemented by the TOML lexer. Uses tomlf_datetime tomlf_de_token tomlf_constants Derived Types type, public, abstract :: abstract_lexer Abstract base class for TOML lexers. Type-Bound Procedures generic, public :: extract => extract_string , extract_integer , extract_float , extract_bool , extract_datetime Extract a token procedure(extract_bool), public, deferred :: extract_bool Extract a boolean from a token procedure(extract_datetime), public, deferred :: extract_datetime Extract a timestamp from a token procedure(extract_float), public, deferred :: extract_float Extract a float from a token procedure(extract_integer), public, deferred :: extract_integer Extract an integer from a token procedure(extract_string), public, deferred :: extract_string Extract a string from a token procedure(get_info), public, deferred :: get_info Get information about the source procedure(next), public, deferred :: next Obtain the next token","tags":"","url":"module/tomlf_de_abc.html"},{"title":"tomlf_utils – TOML-Fortran","text":"Uses tomlf_utils_io tomlf_datetime tomlf_constants Interfaces public        interface to_string private pure function to_string_i1(val) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Integer value to create string from Return Value character(len=:), allocatable String representation of integer private pure function to_string_i2(val) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Integer value to create string from Return Value character(len=:), allocatable String representation of integer private pure function to_string_i4(val) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Integer value to create string from Return Value character(len=:), allocatable String representation of integer private pure function to_string_i8(val) result(string) Represent an integer as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: val Integer value to create string from Return Value character(len=:), allocatable String representation of integer private pure function to_string_r8(val) result(string) Represent an real as character sequence. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: val Real value to create string from Return Value character(len=:), allocatable String representation of integer Subroutines public  subroutine toml_escape_string (raw, escaped, multiline) Escape all special characters in a TOML string Arguments Type Intent Optional Attributes Name character(kind=tfc, len=*), intent(in) :: raw Raw representation of TOML string character(kind=tfc, len=:), intent(out), allocatable :: escaped Escaped view of the TOML string logical, intent(in), optional :: multiline Preserve newline characters","tags":"","url":"module/tomlf_utils.html"},{"title":"tomlf_de_parser – TOML-Fortran","text":"Implementation of a parser for transforming a token stream to TOML datastructures. Uses tomlf_de_token tomlf_diagnostic tomlf_de_abc tomlf_error tomlf_datetime tomlf_de_context tomlf_type tomlf_terminal tomlf_constants Interfaces public        interface toml_parser_config private pure function new_parser_config(color, context_detail) result(config) Create new configuration for the TOML parser Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: color Color support for diagnostics integer, intent(in), optional :: context_detail Record all tokens Return Value type( toml_parser_config ) Configuration of the parser Derived Types type, public :: toml_parser TOML parser Components Type Visibility Attributes Name Initial type( toml_parser_config ), public :: config Configuration of the parser type( toml_context ), public :: context Context for producing diagnostics type( toml_table ), public, pointer :: current Pointer to the currently processed table type( toml_diagnostic ), public, allocatable :: diagnostic Diagnostic produced while parsing type( toml_table ), public, allocatable :: root Table containing the document root type( toml_token ), public :: token Current token type, public :: toml_parser_config Configuration of the TOML parser Components Type Visibility Attributes Name Initial type( toml_terminal ), public :: color = toml_terminal() Use colorful output for diagnostics integer, public :: context_detail = 0 Record all tokens Constructor private\n\n                    pure\n                    function new_parser_config (color, context_detail) Create new configuration for the TOML parser Subroutines public  subroutine parse (lexer, table, config, context, error) Parse TOML document and return root table Arguments Type Intent Optional Attributes Name class( abstract_lexer ), intent(inout) :: lexer Instance of the lexer type( toml_table ), intent(out), allocatable :: table TOML data structure type( toml_parser_config ), intent(in), optional :: config Configuration for the parser type( toml_context ), intent(out), optional :: context Context tracking the origin of the data structure to allow rich reports type( toml_error ), intent(out), optional, allocatable :: error Error handler","tags":"","url":"module/tomlf_de_parser.html"},{"title":"tomlf_structure_list – TOML-Fortran","text":"Abstract base class definitions for data structures to store TOML values Uses tomlf_constants tomlf_type_value Derived Types type, public, abstract :: toml_list_structure Ordered data structure, allows iterations Type-Bound Procedures procedure(destroy), public, deferred :: destroy Destroy the data structure procedure(get), public, deferred :: get Get TOML value at a given index procedure(get_len), public, deferred :: get_len Get number of TOML values in the structure procedure(pop), public, deferred :: pop Remove the last element from the structure procedure(push_back), public, deferred :: push_back Push back a TOML value to the structure procedure(shift), public, deferred :: shift Remove the first element from the structure","tags":"","url":"module/tomlf_structure_list.html"},{"title":"tomlf_de_context – TOML-Fortran","text":"Provides a container to store tokens for later use Uses tomlf_de_token tomlf_diagnostic tomlf_constants tomlf_terminal Derived Types type, public :: toml_context Container storing tokens Components Type Visibility Attributes Name Initial character(kind=tfc, len=:), public, allocatable :: filename Filename of the input character(kind=tfc, len=:), public, allocatable :: source Actual source type( toml_token ), public, allocatable :: token (:) Stack of stored tokens integer, public :: top = 0 Last stored token Type-Bound Procedures procedure, public :: push_back Push a new token to the stack generic, public :: report => report1 , report2 Create a report procedure, public :: report1 Create a report with a single label procedure, public :: report2 Create a report with a two labels","tags":"","url":"module/tomlf_de_context.html"},{"title":"tomlf_utils_sort – TOML-Fortran","text":"Sorting algorithms to work with hash maps Uses tomlf_type_value Interfaces public        interface sort Create overloaded interface for export private pure subroutine sort_keys(list, idx, compare) Entry point for sorting algorithm Arguments Type Intent Optional Attributes Name type( toml_key ), intent(inout) :: list (:) List of TOML keys to be sorted integer, intent(out), optional :: idx (:) Optionally, mapping from unsorted list to sorted list procedure( compare_less ), optional :: compare Function implementing the order relation between two TOML keys Abstract Interfaces abstract interface public pure function compare_less(lhs, rhs) result(less) Define order relation between two TOML keys Arguments Type Intent Optional Attributes Name type( toml_key ), intent(in) :: lhs Left hand side TOML key in comparison type( toml_key ), intent(in) :: rhs Right hand side TOML key in comparison Return Value logical Comparison result","tags":"","url":"module/tomlf_utils_sort.html"},{"title":"tomlf_de – TOML-Fortran","text":"Proxy module for providing loading and deserialization of TOML data structures Uses tomlf_de_parser tomlf_diagnostic tomlf_de_lexer tomlf_error tomlf_de_context tomlf_type tomlf_constants Interfaces public        interface toml_load Load a TOML data structure from the provided source private  subroutine toml_load_file(table, filename, config, context, error) Load TOML data structure from file Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error character(kind=tfc, len=*), intent(in) :: filename type( toml_parser_config ), intent(in), optional :: config Configuration for the parser type( toml_context ), intent(out), optional :: context Context tracking the origin of the data structure to allow rich reports type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error private  subroutine toml_load_unit(table, io, config, context, error) Load TOML data structure from unit Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error integer, intent(in) :: io Unit to read from type( toml_parser_config ), intent(in), optional :: config Configuration for the parser type( toml_context ), intent(out), optional :: context Context tracking the origin of the data structure to allow rich reports type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error public        interface toml_loads Load a TOML data structure from a string private  subroutine toml_load_string(table, string, config, context, error) Load TOML data structure from string Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error character(kind=tfc, len=*), intent(in) :: string String containing TOML document type( toml_parser_config ), intent(in), optional :: config Configuration for the parser type( toml_context ), intent(out), optional :: context Context tracking the origin of the data structure to allow rich reports type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error public        interface toml_parse Parse a TOML document. This interface is deprecated in favor of toml_load and toml_loads private  subroutine toml_parse_unit(table, unit, error) Parse a TOML input from a given IO unit. Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error integer, intent(in) :: unit Unit to read from type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error private  subroutine toml_parse_string(table, string, error) Wrapper to parse a TOML string. Arguments Type Intent Optional Attributes Name type( toml_table ), intent(out), allocatable :: table Instance of the TOML data structure, not allocated in case of error character(len=*), intent(in), target :: string String containing TOML document type( toml_error ), intent(out), optional, allocatable :: error Error handling, provides detailed diagnostic in case of error","tags":"","url":"module/tomlf_de.html"},{"title":"value.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Class definitions for basic data types used for handling TOML module tomlf_type_value use tomlf_constants , only : tfc , TOML_BAREKEY use tomlf_utils , only : toml_escape_string implicit none private public :: toml_value , toml_visitor , toml_key !> Abstract base value for TOML data types type , abstract :: toml_value !> Raw representation of the key to the TOML value character ( kind = tfc , len = :), allocatable :: key !> Original source of the value integer :: origin = 0 contains !> Accept a visitor to transverse the data structure procedure :: accept !> Get escaped key to TOML value procedure :: get_key !> Compare raw key of TOML value to input key procedure :: match_key !> Release allocation hold by TOML value procedure ( destroy ), deferred :: destroy end type toml_value !> Abstract visitor for TOML values type , abstract :: toml_visitor contains !> Visitor visiting a TOML value procedure ( visit ), deferred :: visit end type toml_visitor !> Thin wrapper around the deferred-size character intrinisc type :: toml_key !> Raw representation of the key to the TOML value character ( kind = tfc , len = :), allocatable :: key !> Original source of the value integer :: origin = 0 end type toml_key abstract interface !> Accept a visitor to transverse the data structure recursive subroutine visit ( self , val ) import toml_value , toml_visitor !> Instance of the visitor class ( toml_visitor ), intent ( inout ) :: self !> Value to visit class ( toml_value ), intent ( inout ) :: val end subroutine visit !> Deconstructor to cleanup allocations (optional) subroutine destroy ( self ) import toml_value !> Instance of the TOML value class ( toml_value ), intent ( inout ) :: self end subroutine destroy end interface contains !> Accept a visitor to transverse the data structure recursive subroutine accept ( self , visitor ) !> Instance of the TOML value class ( toml_value ), intent ( inout ) :: self !> Visitor for this value class ( toml_visitor ), intent ( inout ) :: visitor call visitor % visit ( self ) end subroutine accept !> Get escaped key to TOML value subroutine get_key ( self , key ) !> TOML value instance. class ( toml_value ), intent ( in ) :: self !> Contains valid TOML key on exit character ( kind = tfc , len = :), allocatable :: key if ( allocated ( self % key )) then if ( verify ( self % key , TOML_BAREKEY ) == 0 . and . len ( self % key ) > 0 ) then key = self % key else call toml_escape_string ( self % key , key ) end if end if end subroutine get_key !> Compare raw key of TOML value to input key pure function match_key ( self , key ) result ( match ) !> TOML value instance. class ( toml_value ), intent ( in ) :: self !> TOML raw key to compare to character ( kind = tfc , len =* ), intent ( in ) :: key logical :: match if ( allocated ( self % key )) then match = key == self % key else match = . false . end if end function match_key end module tomlf_type_value","tags":"","url":"sourcefile/value.f90.html"},{"title":"datetime.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a TOML datetime value module tomlf_datetime use tomlf_constants , only : tfc implicit none private public :: toml_datetime , toml_time , toml_date , to_string , has_date , has_time public :: operator ( == ) !> TOML time value (HH:MM:SS.sssssZ...) type :: toml_time integer :: hour = - 1 integer :: minute = - 1 integer :: second = - 1 integer :: msec = - 1 character ( len = :), allocatable :: zone end type interface toml_time module procedure :: new_toml_time end interface toml_time !> TOML date value (YYYY-MM-DD) type :: toml_date integer :: year = - 1 integer :: month = - 1 integer :: day = - 1 end type !> TOML datatime value type type :: toml_datetime type ( toml_date ) :: date type ( toml_time ) :: time end type !> Create a new TOML datetime value interface toml_datetime module procedure :: new_datetime module procedure :: new_datetime_from_string end interface toml_datetime interface operator ( == ) module procedure :: compare_datetime end interface operator ( == ) interface to_string module procedure :: to_string_datetime end interface to_string contains pure function new_datetime ( year , month , day , hour , minute , second , msecond , zone ) & & result ( datetime ) integer , intent ( in ), optional :: year integer , intent ( in ), optional :: month integer , intent ( in ), optional :: day integer , intent ( in ), optional :: hour integer , intent ( in ), optional :: minute integer , intent ( in ), optional :: second integer , intent ( in ), optional :: msecond character ( len =* ), intent ( in ), optional :: zone type ( toml_datetime ) :: datetime if ( present ( year ) . and . present ( month ) . and . present ( day )) then datetime % date % year = year datetime % date % month = month datetime % date % day = day end if if ( present ( hour ) . and . present ( minute ) . and . present ( second )) then datetime % time % hour = hour datetime % time % minute = minute datetime % time % second = second if ( present ( msecond )) then datetime % time % msec = msecond end if if ( present ( zone )) then datetime % time % zone = zone end if end if end function new_datetime pure function new_datetime_from_string ( string ) result ( datetime ) character ( len =* ), intent ( in ) :: string type ( toml_datetime ) :: datetime type ( toml_date ) :: date type ( toml_time ) :: time integer :: it , tmp , first character ( * , tfc ), parameter :: num = \"0123456789\" integer , allocatable :: msec (:) first = 0 if ( all ([ string ( first + 5 : first + 5 ), string ( first + 8 : first + 8 )] == \"-\" )) then date % year = 0 do it = first + 1 , first + 4 tmp = scan ( num , string ( it : it )) - 1 if ( tmp < 0 ) exit date % year = date % year * 10 + tmp end do date % month = 0 do it = first + 6 , first + 7 tmp = scan ( num , string ( it : it )) - 1 if ( tmp < 0 ) exit date % month = date % month * 10 + tmp end do date % day = 0 do it = first + 9 , first + 10 tmp = scan ( num , string ( it : it )) - 1 if ( tmp < 0 ) exit date % day = date % day * 10 + tmp end do first = first + 11 datetime % date = date end if if ( first >= len ( string )) return if ( all ([ string ( first + 3 : first + 3 ), string ( first + 6 : first + 6 )] == \":\" )) then time % hour = 0 do it = first + 1 , first + 2 tmp = scan ( num , string ( it : it )) - 1 if ( tmp < 0 ) exit time % hour = time % hour * 10 + tmp end do time % minute = 0 do it = first + 4 , first + 5 tmp = scan ( num , string ( it : it )) - 1 if ( tmp < 0 ) exit time % minute = time % minute * 10 + tmp end do time % second = 0 do it = first + 7 , first + 8 tmp = scan ( num , string ( it : it )) - 1 if ( tmp < 0 ) exit time % second = time % second * 10 + tmp end do first = first + 8 if ( string ( first + 1 : first + 1 ) == \".\" ) then msec = [ integer :: ] do it = first + 2 , len ( string ) tmp = scan ( num , string ( it : it )) - 1 if ( tmp < 0 ) exit msec = [ msec , tmp ] end do first = it - 1 msec = [ msec , 0 , 0 , 0 , 0 , 0 , 0 ] time % msec = sum ( msec ( 1 : 6 ) * [ 100000 , 10000 , 1000 , 100 , 10 , 1 ]) end if if ( first < len ( string )) then time % zone = \"\" do it = first + 1 , len ( string ) time % zone = time % zone // string ( it : it ) end do if ( time % zone == \"z\" ) time % zone = \"Z\" end if datetime % time = time end if end function new_datetime_from_string pure function to_string_datetime ( datetime ) result ( str ) type ( toml_datetime ), intent ( in ) :: datetime character ( kind = tfc , len = :), allocatable :: str str = \"\" if ( has_date ( datetime )) then str = str // to_string_date ( datetime % date ) end if if ( has_time ( datetime )) then if ( has_date ( datetime )) then str = str // ' ' end if str = str // to_string_time ( datetime % time ) end if end function to_string_datetime pure function to_string_date ( date ) result ( str ) type ( toml_date ), intent ( in ) :: date character (:, tfc ), allocatable :: str allocate ( character ( 10 , tfc ) :: str ) write ( str , '(i4.4,\"-\",i2.2,\"-\",i2.2)' ) & & date % year , date % month , date % day end function to_string_date pure function to_string_time ( time ) result ( str ) type ( toml_time ), intent ( in ) :: time character (:, tfc ), allocatable :: str integer :: msec , width character ( 1 ), parameter :: places ( 6 ) = [ \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" ] if ( time % msec < 0 ) then allocate ( character ( 8 , tfc ) :: str ) write ( str , '(i2.2,\":\",i2.2,\":\",i2.2)' ) & & time % hour , time % minute , time % second else width = 6 msec = time % msec do while ( mod ( msec , 10 ) == 0 . and . width > 3 ) width = width - 1 msec = msec / 10 end do allocate ( character ( 9 + width , tfc ) :: str ) write ( str , '(i2.2,\":\",i2.2,\":\",i2.2,\".\",i' // places ( width ) // '.' // places ( width ) // ')' ) & & time % hour , time % minute , time % second , msec end if if ( allocated ( time % zone )) str = str // trim ( time % zone ) end function to_string_time pure function has_date ( datetime ) class ( toml_datetime ), intent ( in ) :: datetime logical :: has_date has_date = ( datetime % date % year >= 0 ) . and . & & ( datetime % date % month >= 0 ) . and . & & ( datetime % date % day >= 0 ) end function has_date pure function has_time ( datetime ) class ( toml_datetime ), intent ( in ) :: datetime logical :: has_time has_time = ( datetime % time % hour >= 0 ) . and . & & ( datetime % time % minute >= 0 ) . and . & & ( datetime % time % second >= 0 ) end function has_time !> Constructor for toml_time type, necessary due to PGI bug in NVHPC 20.7 and 20.9 elemental function new_toml_time ( hour , minute , second , msec , zone ) & & result ( self ) integer , intent ( in ), optional :: hour integer , intent ( in ), optional :: minute integer , intent ( in ), optional :: second integer , intent ( in ), optional :: msec character ( len =* ), intent ( in ), optional :: zone type ( toml_time ) :: self if ( present ( hour )) self % hour = hour if ( present ( minute )) self % minute = minute if ( present ( second )) self % second = second if ( present ( msec )) self % msec = msec if ( present ( zone )) self % zone = zone end function new_toml_time pure function compare_datetime ( lhs , rhs ) result ( match ) type ( toml_datetime ), intent ( in ) :: lhs type ( toml_datetime ), intent ( in ) :: rhs logical :: match match = ( has_date ( lhs ) . eqv . has_date ( rhs )) & & . and . ( has_time ( lhs ) . eqv . has_time ( rhs )) if ( has_date ( lhs ) . and . has_date ( rhs )) then match = match . and . compare_date ( lhs % date , rhs % date ) end if if ( has_time ( lhs ) . and . has_time ( rhs )) then match = match . and . compare_time ( lhs % time , rhs % time ) end if end function compare_datetime pure function compare_date ( lhs , rhs ) result ( match ) type ( toml_date ), intent ( in ) :: lhs type ( toml_date ), intent ( in ) :: rhs logical :: match match = lhs % year == rhs % year . and . lhs % month == rhs % month . and . lhs % day == rhs % day end function compare_date pure function compare_time ( lhs , rhs ) result ( match ) type ( toml_time ), intent ( in ) :: lhs type ( toml_time ), intent ( in ) :: rhs logical :: match integer :: lms , rms lms = max ( lhs % msec , 0 ) rms = max ( rhs % msec , 0 ) match = lhs % hour == rhs % hour . and . lhs % minute == rhs % minute . and . lhs % second == rhs % second & & . and . lms == rms . and . allocated ( lhs % zone ) . eqv . allocated ( rhs % zone ) if ( allocated ( lhs % zone ) . and . allocated ( rhs % zone )) then match = match . and . lhs % zone == rhs % zone end if end function compare_time end module tomlf_datetime","tags":"","url":"sourcefile/datetime.f90.html"},{"title":"error.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Central registry for error codes module tomlf_error use tomlf_constants , only : tfc , TOML_NEWLINE implicit none private public :: toml_stat , toml_error , make_error !> Possible TOML-Fortran error codes type :: enum_stat !> Successful run integer :: success = 0 !> Internal error: !> !> General undefined error state, usually caused by algorithmic errors. integer :: fatal = - 1 !> Duplicate key encountered integer :: duplicate_key = - 2 !> Incorrect type when reading a value integer :: type_mismatch = - 3 !> Conversion error when downcasting a value integer :: conversion_error = - 4 !> Key not present in table integer :: missing_key = - 5 end type enum_stat !> Actual enumerator for return states type ( enum_stat ), parameter :: toml_stat = enum_stat () !> Error message produced by TOML-Fortran type :: toml_error !> Error code integer :: stat = toml_stat % fatal !> Payload of the error character ( kind = tfc , len = :), allocatable :: message end type toml_error contains !> Create new error message subroutine make_error ( error , message , stat ) !> Error report type ( toml_error ), allocatable , intent ( out ) :: error !> Message for the error character ( * , tfc ), intent ( in ) :: message !> Status code integer , intent ( in ), optional :: stat allocate ( error ) error % message = message if ( present ( stat )) then error % stat = stat else error % stat = toml_stat % fatal end if end subroutine make_error end module tomlf_error","tags":"","url":"sourcefile/error.f90.html"},{"title":"array.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of the TOML array data type. module tomlf_type_array use tomlf_error , only : toml_stat use tomlf_type_value , only : toml_value , toml_visitor use tomlf_structure , only : toml_list_structure , new_list_structure implicit none private public :: toml_array , new_array , new , initialized , len !> TOML array type , extends ( toml_value ) :: toml_array !> Is an inline array rather than an array of tables logical :: inline = . true . !> Storage unit for TOML values of this array class ( toml_list_structure ), allocatable , private :: list contains !> Get the TOML value at a given index procedure :: get !> Append value to array procedure :: push_back !> Remove the first element from the array procedure :: shift !> Remove the last element from the array procedure :: pop !> Release allocation hold by TOML array procedure :: destroy end type toml_array !> Create standard constructor interface toml_array module procedure :: new_array_func end interface toml_array !> Overloaded constructor for TOML values interface new module procedure :: new_array end interface !> Overload len function interface len module procedure :: get_len end interface !> Check whether data structure is initialized properly interface initialized module procedure :: array_initialized end interface initialized contains !> Constructor to create a new TOML array and allocate the internal storage subroutine new_array ( self ) !> Instance of the TOML array type ( toml_array ), intent ( out ) :: self call new_list_structure ( self % list ) end subroutine new_array !> Default constructor for TOML array type function new_array_func () result ( self ) !> Instance of the TOML array type ( toml_array ) :: self call new_array ( self ) end function new_array_func !> Check whether data structure is initialized properly pure function array_initialized ( self ) result ( okay ) !> Instance of the TOML array type ( toml_array ), intent ( in ) :: self !> Data structure is initialized logical :: okay okay = allocated ( self % list ) end function array_initialized !> Get number of TOML values in the array pure function get_len ( self ) result ( length ) !> Instance of the TOML array class ( toml_array ), intent ( in ) :: self !> Current length of the array integer :: length length = self % list % get_len () end function get_len !> Get the TOML value at the respective index subroutine get ( self , idx , ptr ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self !> Index to the TOML value integer , intent ( in ) :: idx !> Pointer to the TOML value class ( toml_value ), pointer , intent ( out ) :: ptr call self % list % get ( idx , ptr ) end subroutine get !> Push back a TOML value to the array subroutine push_back ( self , val , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self !> TOML value to append to array class ( toml_value ), allocatable , intent ( inout ) :: val !> Status of operation integer , intent ( out ) :: stat if ( allocated ( val % key )) then stat = toml_stat % fatal return end if call self % list % push_back ( val ) stat = toml_stat % success end subroutine push_back !> Remove the first element from the data structure subroutine shift ( self , val ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val call self % list % shift ( val ) end subroutine shift !> Remove the last element from the data structure subroutine pop ( self , val ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val call self % list % pop ( val ) end subroutine pop !> Deconstructor to cleanup allocations (optional) subroutine destroy ( self ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: self if ( allocated ( self % key )) then deallocate ( self % key ) end if if ( allocated ( self % list )) then call self % list % destroy deallocate ( self % list ) end if end subroutine destroy end module tomlf_type_array","tags":"","url":"sourcefile/array.f90.html"},{"title":"merge.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Merge TOML data structures, the merge policy can be adjusted. !> !> Note that the context information cannot be preserved. module tomlf_build_merge use tomlf_constants , only : tfc use tomlf_type , only : toml_table , toml_array , toml_keyval , toml_value , & & toml_key , cast_to_keyval , len implicit none private public :: merge_table , merge_array , merge_policy , toml_merge_config !> Possible merge policies type :: enum_policy !> Overwrite existing values integer :: overwrite = 1 !> Preserve existing values integer :: preserve = 2 !> Append to existing values integer :: append = 3 end type enum_policy !> Actual enumerator for merging data structures type ( enum_policy ), parameter :: merge_policy = enum_policy () !> Configuration for merging data structures type :: toml_merge_config !> Policy for merging tables integer :: table = merge_policy % append !> Policy for merging arrays integer :: array = merge_policy % preserve !> Policy for merging values integer :: keyval = merge_policy % preserve end type toml_merge_config !> Constructor for merge configuration interface toml_merge_config module procedure :: new_merge_config end interface toml_merge_config contains !> Create a new merge configuration pure function new_merge_config ( table , array , keyval ) result ( config ) !> Policy for merging tables character ( * ), intent ( in ), optional :: table !> Policy for merging arrays character ( * ), intent ( in ), optional :: array !> Policy for merging values character ( * ), intent ( in ), optional :: keyval !> Merge policy type ( toml_merge_config ) :: config if ( present ( table )) call set_enum ( config % table , table ) if ( present ( array )) call set_enum ( config % array , array ) if ( present ( keyval )) call set_enum ( config % keyval , keyval ) contains pure subroutine set_enum ( enum , str ) character ( * ), intent ( in ) :: str integer , intent ( inout ) :: enum select case ( str ) case ( \"append\" ) enum = merge_policy % append case ( \"overwrite\" ) enum = merge_policy % overwrite case ( \"preserve\" ) enum = merge_policy % preserve end select end subroutine set_enum end function new_merge_config !> Merge TOML tables by appending their values recursive subroutine merge_table ( lhs , rhs , config ) !> Instance of table to merge into class ( toml_table ), intent ( inout ) :: lhs !> Instance of table to be merged class ( toml_table ), intent ( inout ) :: rhs !> Merge policy type ( toml_merge_config ), intent ( in ), optional :: config type ( toml_merge_config ) :: policy type ( toml_key ), allocatable :: list (:) class ( toml_value ), pointer :: ptr1 , ptr2 class ( toml_keyval ), pointer :: kv class ( toml_value ), allocatable :: tmp logical :: has_key integer :: i , n , stat policy = toml_merge_config () if ( present ( config )) policy = config call rhs % get_keys ( list ) n = size ( list , 1 ) do i = 1 , n if ( allocated ( tmp )) deallocate ( tmp ) call rhs % get ( list ( i )% key , ptr1 ) has_key = lhs % has_key ( list ( i )% key ) select type ( ptr1 ) class is ( toml_keyval ) if ( has_key . and . policy % keyval == merge_policy % overwrite ) then call lhs % delete ( list ( i )% key ) has_key = . false . end if if (. not . has_key ) then allocate ( tmp , source = ptr1 ) kv => cast_to_keyval ( tmp ) kv % origin_value = 0 kv % origin = 0 call lhs % push_back ( tmp , stat ) end if class is ( toml_array ) if ( has_key . and . policy % array == merge_policy % overwrite ) then call lhs % delete ( list ( i )% key ) has_key = . false . end if if ( has_key . and . policy % array == merge_policy % append ) then call lhs % get ( list ( i )% key , ptr2 ) select type ( ptr2 ) class is ( toml_array ) call merge_array ( ptr2 , ptr1 ) end select end if if (. not . has_key ) then allocate ( tmp , source = ptr1 ) tmp % origin = 0 call lhs % push_back ( tmp , stat ) end if class is ( toml_table ) if ( has_key . and . policy % table == merge_policy % overwrite ) then call lhs % delete ( list ( i )% key ) has_key = . false . end if if ( has_key . and . policy % table == merge_policy % append ) then call lhs % get ( list ( i )% key , ptr2 ) select type ( ptr2 ) class is ( toml_table ) call merge_table ( ptr2 , ptr1 , policy ) end select end if if (. not . has_key ) then allocate ( tmp , source = ptr1 ) tmp % origin = 0 call lhs % push_back ( tmp , stat ) end if end select end do end subroutine merge_table !> Append values from one TOML array to another recursive subroutine merge_array ( lhs , rhs ) !> Instance of array to merge into class ( toml_array ), intent ( inout ) :: lhs !> Instance of array to be merged class ( toml_array ), intent ( inout ) :: rhs class ( toml_value ), pointer :: ptr class ( toml_value ), allocatable :: tmp integer :: n , i , stat n = len ( rhs ) do i = 1 , n call rhs % get ( i , ptr ) if ( allocated ( tmp )) deallocate ( tmp ) allocate ( tmp , source = ptr ) call lhs % push_back ( tmp , stat ) end do end subroutine merge_array end module tomlf_build_merge","tags":"","url":"sourcefile/merge.f90.html"},{"title":"token.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Provides a definition for a token module tomlf_de_token implicit none private public :: toml_token , stringify , token_kind , resize !> Possible token kinds type :: enum_token !> Invalid token found integer :: invalid = - 1 !> End of file integer :: eof = - 2 !> Unclosed group from inline table or array integer :: unclosed = - 3 !> Whitespace (space, tab) integer :: whitespace = 0 !> Newline character (\\r\\n, \\n) integer :: newline = 1 !> Comments (#) integer :: comment = 2 !> Separator in table path (.) integer :: dot = 3 !> Separator in inline arrays and inline tables (,) integer :: comma = 4 !> Separator in key-value pairs (=) integer :: equal = 5 !> Beginning of an inline table ({) integer :: lbrace = 6 !> End of an inline table (}) integer :: rbrace = 7 !> Beginning of an inline array or table header ([) integer :: lbracket = 8 !> End of an inline array or table header (]) integer :: rbracket = 9 !> String literal integer :: string = 10 !> String literal integer :: mstring = 11 !> String literal integer :: literal = 12 !> String literal integer :: mliteral = 13 !> String literal integer :: keypath = 14 !> Floating point value integer :: float = 15 !> Integer value integer :: int = 16 !> Boolean value integer :: bool = 17 !> Datetime value integer :: datetime = 18 !> Absence of value integer :: nil = 19 end type enum_token !> Actual enumerator for token kinds type ( enum_token ), parameter :: token_kind = enum_token () !> Token containing type :: toml_token !> Kind of token integer :: kind = token_kind % newline !> Starting position of the token in character stream integer :: first = 0 !> Last position of the token in character stream integer :: last = 0 !> Identifier for the chunk index in case of buffered reading integer :: chunk = 0 end type toml_token !> Reallocate a list of tokens interface resize module procedure :: resize_token end interface contains !> Reallocate list of tokens pure subroutine resize_token ( var , n ) !> Instance of the array to be resized type ( toml_token ), allocatable , intent ( inout ) :: var (:) !> Dimension of the final array size integer , intent ( in ), optional :: n type ( toml_token ), allocatable :: tmp (:) integer :: this_size , new_size integer , parameter :: initial_size = 8 if ( allocated ( var )) then this_size = size ( var , 1 ) call move_alloc ( var , tmp ) else this_size = initial_size end if if ( present ( n )) then new_size = n else new_size = this_size + this_size / 2 + 1 end if allocate ( var ( new_size )) if ( allocated ( tmp )) then this_size = min ( size ( tmp , 1 ), size ( var , 1 )) var (: this_size ) = tmp (: this_size ) deallocate ( tmp ) end if end subroutine resize_token !> Represent a token as string pure function stringify ( token ) result ( str ) !> Token to represent as string type ( toml_token ), intent ( in ) :: token !> String representation of token character ( len = :), allocatable :: str select case ( token % kind ) case default ; str = \"unknown\" case ( token_kind % invalid ); str = \"invalid sequence\" case ( token_kind % eof ); str = \"end of file\" case ( token_kind % unclosed ); str = \"unclosed group\" case ( token_kind % whitespace ); str = \"whitespace\" case ( token_kind % comment ); str = \"comment\" case ( token_kind % newline ); str = \"newline\" case ( token_kind % dot ); str = \"dot\" case ( token_kind % comma ); str = \"comma\" case ( token_kind % equal ); str = \"equal\" case ( token_kind % lbrace ); str = \"opening brace\" case ( token_kind % rbrace ); str = \"closing brace\" case ( token_kind % lbracket ); str = \"opening bracket\" case ( token_kind % rbracket ); str = \"closing bracket\" case ( token_kind % string ); str = \"string\" case ( token_kind % mstring ); str = \"multiline string\" case ( token_kind % literal ); str = \"literal\" case ( token_kind % mliteral ); str = \"multiline-literal\" case ( token_kind % keypath ); str = \"keypath\" case ( token_kind % int ); str = \"integer\" case ( token_kind % float ); str = \"float\" case ( token_kind % bool ); str = \"bool\" case ( token_kind % datetime ); str = \"datetime\" case ( token_kind % nil ); str = \"nil\" end select end function stringify end module tomlf_de_token","tags":"","url":"sourcefile/token.f90.html"},{"title":"structure.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Abstraction layer for the actual storage of the data structure. !> !> The structure implementations provide the actual storage for TOML values, with !> a generic enough interface to make the definition of the TOML data structures !> independent of the actual algorithm used for storing the TOML values. !> !> Every data structure defined here should strive to only use allocatable !> data types and limit the use of pointer attributes as they interfer with !> the automatic memory management of Fortran. A well defined data structure !> in allocatables allows deep-copying of TOML values by assignment, data structures !> requiring pointer attributes have to define an assignment(=) interface to !> allow deep-copying of TOML values. module tomlf_structure use tomlf_structure_list , only : toml_list_structure use tomlf_structure_map , only : toml_map_structure use tomlf_structure_array_list , only : toml_array_list , new_array_list use tomlf_structure_ordered_map , only : toml_ordered_map , new_ordered_map implicit none private public :: toml_list_structure , toml_map_structure public :: new_list_structure , new_map_structure contains !> Constructor for the ordered storage data structure subroutine new_list_structure ( self ) !> Instance of the structure class ( toml_list_structure ), allocatable , intent ( out ) :: self block type ( toml_array_list ), allocatable :: list allocate ( list ) call new_array_list ( list ) call move_alloc ( list , self ) end block end subroutine new_list_structure !> Constructor for the storage data structure subroutine new_map_structure ( self ) !> Instance of the structure class ( toml_map_structure ), allocatable , intent ( out ) :: self block type ( toml_ordered_map ), allocatable :: map allocate ( map ) call new_ordered_map ( map ) call move_alloc ( map , self ) end block end subroutine new_map_structure end module tomlf_structure","tags":"","url":"sourcefile/structure.f90.html"},{"title":"map.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Abstract base class definitions for data structures to store TOML values module tomlf_structure_map use tomlf_constants , only : tfc use tomlf_type_value , only : toml_value , toml_key implicit none private public :: toml_map_structure !> Abstract data structure type , abstract :: toml_map_structure contains !> Get TOML value at a given key procedure ( get ), deferred :: get !> Push back a TOML value to the structure procedure ( push_back ), deferred :: push_back !> Get list of all keys in the structure procedure ( get_keys ), deferred :: get_keys !> Remove TOML value at a given key and return it procedure ( pop ), deferred :: pop !> Delete TOML value at a given key procedure ( delete ), deferred :: delete !> Destroy the data structure procedure ( destroy ), deferred :: destroy end type toml_map_structure abstract interface !> Get TOML value at a given key subroutine get ( self , key , ptr ) import :: toml_map_structure , toml_value , tfc !> Instance of the structure class ( toml_map_structure ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the stored value at given key class ( toml_value ), pointer , intent ( out ) :: ptr end subroutine get !> Push back a TOML value to the structure subroutine push_back ( self , val ) import :: toml_map_structure , toml_value !> Instance of the structure class ( toml_map_structure ), intent ( inout ), target :: self !> TOML value to be stored class ( toml_value ), allocatable , intent ( inout ) :: val end subroutine push_back !> Get list of all keys in the structure subroutine get_keys ( self , list ) import :: toml_map_structure , toml_key !> Instance of the structure class ( toml_map_structure ), intent ( inout ), target :: self !> List of all keys type ( toml_key ), allocatable , intent ( out ) :: list (:) end subroutine get_keys !> Remove TOML value at a given key and return it subroutine pop ( self , key , val ) import :: toml_map_structure , toml_value , tfc !> Instance of the structure class ( toml_map_structure ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Removed TOML value class ( toml_value ), allocatable , intent ( out ) :: val end subroutine pop !> Delete TOML value at a given key subroutine delete ( self , key ) import :: toml_map_structure , toml_value , tfc !> Instance of the structure class ( toml_map_structure ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key end subroutine delete !> Deconstructor for data structure subroutine destroy ( self ) import :: toml_map_structure !> Instance of the structure class ( toml_map_structure ), intent ( inout ), target :: self end subroutine destroy end interface end module tomlf_structure_map","tags":"","url":"sourcefile/map.f90.html"},{"title":"node.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a basic storage structure as pointer list of pointers. !> !> This implementation does purposely not use pointer attributes in the !> datastructure to make it safer to work with. module tomlf_structure_node use tomlf_type_value , only : toml_value implicit none private public :: toml_node , resize !> Wrapped TOML value to generate pointer list type :: toml_node !> TOML value payload class ( toml_value ), allocatable :: val end type toml_node !> Initial storage capacity of the datastructure integer , parameter :: initial_size = 16 contains !> Change size of the TOML value list subroutine resize ( list , n ) !> Array of TOML values to be resized type ( toml_node ), allocatable , intent ( inout ), target :: list (:) !> New size of the list integer , intent ( in ) :: n type ( toml_node ), allocatable , target :: tmp (:) integer :: i if ( allocated ( list )) then call move_alloc ( list , tmp ) allocate ( list ( n )) do i = 1 , min ( size ( tmp ), n ) if ( allocated ( tmp ( i )% val )) then call move_alloc ( tmp ( i )% val , list ( i )% val ) end if end do do i = n + 1 , size ( tmp ) if ( allocated ( tmp ( i )% val )) then call tmp ( i )% val % destroy deallocate ( tmp ( i )% val ) end if end do deallocate ( tmp ) else allocate ( list ( n )) end if end subroutine resize end module tomlf_structure_node","tags":"","url":"sourcefile/node.f90.html"},{"title":"keyval.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Functions to build a TOML values !> !> The build module defines an interface to work with TOML values instead !> of accessing the raw value directly. Both setter and getter routines defined !> here are rarely needed in any user context, but serve as a basic building !> block to define uniform access methods for TOML tables and arrays. module tomlf_build_keyval use tomlf_constants , only : tfc , tfi , tfr , tf_i1 , tf_i2 , tf_i4 , tf_i8 , & & tf_sp , tf_dp , TOML_NEWLINE use tomlf_datetime , only : toml_datetime use tomlf_error , only : toml_stat use tomlf_type , only : toml_value , toml_table , toml_array , toml_keyval , & & new_table , new_array , new_keyval , add_table , add_array , add_keyval , len use tomlf_utils , only : toml_escape_string , to_string implicit none private public :: get_value , set_value !> Setter functions to manipulate TOML values interface set_value module procedure :: set_value_float_sp module procedure :: set_value_float_dp module procedure :: set_value_integer_i1 module procedure :: set_value_integer_i2 module procedure :: set_value_integer_i4 module procedure :: set_value_integer_i8 module procedure :: set_value_bool module procedure :: set_value_datetime module procedure :: set_value_string end interface set_value !> Getter functions to manipulate TOML values interface get_value module procedure :: get_value_float_sp module procedure :: get_value_float_dp module procedure :: get_value_integer_i1 module procedure :: get_value_integer_i2 module procedure :: get_value_integer_i4 module procedure :: get_value_integer_i8 module procedure :: get_value_bool module procedure :: get_value_datetime module procedure :: get_value_string end interface get_value !> Length for the static character variables integer , parameter :: buffersize = 128 contains !> Retrieve TOML value as single precision float (might lose accuracy) subroutine get_value_float_sp ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Real value real ( tf_sp ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info real ( tfr ), pointer :: dummy integer ( tfi ), pointer :: idummy call self % get ( dummy ) if ( associated ( dummy )) then val = real ( dummy , tf_sp ) info = toml_stat % success else call self % get ( idummy ) if ( associated ( idummy )) then val = real ( idummy , tf_sp ) if ( nint ( val , tfi ) == idummy ) then info = toml_stat % success else info = toml_stat % conversion_error end if else info = toml_stat % type_mismatch end if end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_float_sp !> Retrieve TOML value as double precision float subroutine get_value_float_dp ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Real value real ( tf_dp ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info real ( tfr ), pointer :: dummy integer ( tfi ), pointer :: idummy call self % get ( dummy ) if ( associated ( dummy )) then val = real ( dummy , tf_dp ) info = toml_stat % success else call self % get ( idummy ) if ( associated ( idummy )) then val = real ( idummy , tf_dp ) if ( nint ( val , tfi ) == idummy ) then info = toml_stat % success else info = toml_stat % conversion_error end if else info = toml_stat % type_mismatch end if end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_float_dp !> Retrieve TOML value as one byte integer (might loose precision) subroutine get_value_integer_i1 ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Integer value integer ( tf_i1 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info integer ( tfi ), pointer :: dummy call self % get ( dummy ) if ( associated ( dummy )) then val = int ( dummy , tf_i1 ) if ( dummy <= huge ( val ) . and . dummy >= - huge ( val ) - 1 ) then info = toml_stat % success else info = toml_stat % conversion_error end if else info = toml_stat % type_mismatch end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_integer_i1 !> Retrieve TOML value as two byte integer (might loose precision) subroutine get_value_integer_i2 ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Integer value integer ( tf_i2 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info integer ( tfi ), pointer :: dummy call self % get ( dummy ) if ( associated ( dummy )) then val = int ( dummy , tf_i2 ) if ( dummy <= huge ( val ) . and . dummy >= - huge ( val ) - 1 ) then info = toml_stat % success else info = toml_stat % conversion_error end if else info = toml_stat % type_mismatch end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_integer_i2 !> Retrieve TOML value as four byte integer (might loose precision) subroutine get_value_integer_i4 ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Integer value integer ( tf_i4 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info integer ( tfi ), pointer :: dummy call self % get ( dummy ) if ( associated ( dummy )) then val = int ( dummy , tf_i4 ) if ( dummy <= huge ( val ) . and . dummy >= - huge ( val ) - 1 ) then info = toml_stat % success else info = toml_stat % conversion_error end if else info = toml_stat % type_mismatch end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_integer_i4 !> Retrieve TOML value as eight byte integer subroutine get_value_integer_i8 ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Integer value integer ( tf_i8 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info integer ( tfi ), pointer :: dummy call self % get ( dummy ) if ( associated ( dummy )) then val = int ( dummy , tf_i8 ) info = toml_stat % success else info = toml_stat % type_mismatch end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_integer_i8 !> Retrieve TOML value as logical subroutine get_value_bool ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Boolean value logical , intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info logical , pointer :: dummy call self % get ( dummy ) if ( associated ( dummy )) then val = dummy info = toml_stat % success else info = toml_stat % type_mismatch end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_bool !> Retrieve TOML value as datetime subroutine get_value_datetime ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> Datetime value type ( toml_datetime ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info type ( toml_datetime ), pointer :: dummy call self % get ( dummy ) if ( associated ( dummy )) then val = dummy info = toml_stat % success else info = toml_stat % type_mismatch end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_datetime !> Retrieve TOML value as deferred-length character subroutine get_value_string ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( in ) :: self !> String value character ( kind = tfc , len = :), allocatable , intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: info character (:, tfc ), pointer :: dummy call self % get ( dummy ) if ( associated ( dummy )) then val = dummy info = toml_stat % success else info = toml_stat % type_mismatch end if if ( present ( stat )) stat = info if ( present ( origin )) origin = self % origin_value end subroutine get_value_string !> Set TOML value to single precision float subroutine set_value_float_sp ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Real value real ( tf_sp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( real ( val , tfr )) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_float_sp !> Set TOML value to double precision float subroutine set_value_float_dp ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Real value real ( tf_dp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( real ( val , tfr )) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_float_dp !> Set TOML value to one byte integer subroutine set_value_integer_i1 ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Integer value integer ( tf_i1 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( int ( val , tfi )) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_integer_i1 !> Set TOML value to two byte integer subroutine set_value_integer_i2 ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Integer value integer ( tf_i2 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( int ( val , tfi )) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_integer_i2 !> Set TOML value to four byte integer subroutine set_value_integer_i4 ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Integer value integer ( tf_i4 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( int ( val , tfi )) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_integer_i4 !> Set TOML value to eight byte integer subroutine set_value_integer_i8 ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Integer value integer ( tf_i8 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( int ( val , tfi )) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_integer_i8 !> Set TOML value to logical subroutine set_value_bool ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Boolean value logical , intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( val ) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_bool !> Set TOML value to datetime subroutine set_value_datetime ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Datetime value type ( toml_datetime ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( val ) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_datetime !> Set TOML value to deferred-length character subroutine set_value_string ( self , val , stat , origin ) !> Instance of the key-value pair class ( toml_keyval ), intent ( inout ) :: self !> String value character ( kind = tfc , len =* ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call self % set ( val ) if ( present ( stat )) stat = toml_stat % success self % origin_value = 0 if ( present ( origin )) origin = self % origin end subroutine set_value_string end module tomlf_build_keyval","tags":"","url":"sourcefile/keyval.f90.html"},{"title":"build.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Functions to build a TOML data structures !> !> The build module defines a high level interface to work with TOML data structures !> and construct them in a convenient way. module tomlf_build use tomlf_build_array , only : get_value , set_value use tomlf_build_keyval , only : get_value , set_value use tomlf_build_merge , only : merge_table , merge_array , merge_policy , toml_merge_config use tomlf_build_path , only : get_value , set_value , toml_path use tomlf_build_table , only : get_value , set_value implicit none private public :: get_value , set_value public :: merge_table , merge_array , merge_policy , toml_merge_config public :: toml_path end module tomlf_build","tags":"","url":"sourcefile/build.f90.html"},{"title":"lexer.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Provides tokenization for TOML documents. !> !> The lexer provides a way to turn a stream of characters into tokens which !> are further processed by the parser and turned into actual TOML data structures. !> In the current structure no knowledge about the character stream is required !> in the parser to generate the data structures. !> !> The validity of all tokens can be guaranteed by the lexer, however syntax errors !> and semantic errors are not detected until the parser is run. Identification of !> invalid tokens and recovery of the tokenization is done on a best effort basis. !> !> To avoid overflows in the parser due to deeply nested but unclosed groups, the !> lexer will always tokenize a complete group to verify it is closed properly. !> Unclosed groups will lead to the first token of the group getting invalidated, !> to allow reporting in the parsing phase. module tomlf_de_lexer use tomlf_constants , only : tfc , tfi , tfr , TOML_BACKSPACE , TOML_TABULATOR , TOML_NEWLINE , & & TOML_CARRIAGE_RETURN , TOML_FORMFEED use tomlf_datetime , only : toml_datetime , toml_date , toml_time use tomlf_de_abc , only : abstract_lexer use tomlf_de_context , only : toml_context use tomlf_de_token , only : toml_token , stringify , token_kind , resize use tomlf_error , only : toml_error , toml_stat , make_error use tomlf_utils , only : read_whole_file , read_whole_line implicit none private public :: toml_lexer , new_lexer_from_file , new_lexer_from_unit , new_lexer_from_string public :: toml_token , stringify , token_kind !> Possible characters encountered in a lexeme type :: enum_char character ( 1 , tfc ) :: space = tfc_ \" \" character ( 1 , tfc ) :: hash = tfc_ \"#\" character ( 1 , tfc ) :: squote = tfc_ \"'\" character ( 3 , tfc ) :: squote3 = repeat ( tfc_ \"'\" , 3 ) character ( 1 , tfc ) :: dquote = tfc_ \"\"\"\" character ( 3 , tfc ) :: dquote3 = repeat ( tfc_ \"\"\"\" , 3 ) character ( 1 , tfc ) :: backslash = tfc_ \"\\\" character(1, tfc) :: dot = tfc_\" . \" character(1, tfc) :: comma = tfc_\" , \" character(1, tfc) :: equal = tfc_\" = \" character(1, tfc) :: lbrace = tfc_\" { \" character(1, tfc) :: rbrace = tfc_\" } \" character(1, tfc) :: lbracket = tfc_\" [ \" character(1, tfc) :: rbracket = tfc_\" ] \" character(1, tfc) :: newline = achar(10, kind=tfc) character(1, tfc) :: formfeed = achar(12, kind=tfc) character(1, tfc) :: carriage_return = achar(13, kind=tfc) character(1, tfc) :: bspace = achar(8, kind=tfc) character(1, tfc) :: tab = achar(9, kind=tfc) character(1, tfc) :: plus = tfc_\" + \" character(1, tfc) :: minus = tfc_\" - \" character(12, tfc) :: literal = tfc_\" 0123456789 - _ \" end type enum_char !> Actual enumerator for possible characters type(enum_char), parameter :: char_kind = enum_char() !> Set of characters marking a terminated lexeme, mainly used for values and to !> obtain boundaries of invalid tokens. character(*, tfc), parameter :: terminated = & & char_kind%space//char_kind%tab//char_kind%newline//char_kind%carriage_return//& & char_kind%hash//char_kind%rbrace//char_kind%rbracket//char_kind%comma//& & char_kind%equal !> Scopes to identify the state of the lexer. type :: enum_scope !> Table scopes allow keypaths, in this scenario only bare keys, strings and !> literals are allowed, furthermore dots become special characters to separate !> the keypaths. integer :: table = 1 !> Terminates a table scope and opens a value scope. Here usual values, like integer, !> floats or strings are allowed. integer :: equal = 2 !> Opens an array scope, similar to the value scope for allowed characters but with !> simplified closing rules to allow handling of values and inline tables in arrays. integer :: array = 3 end type enum_scope !> Actual enumerator for auxiliary scopes type(enum_scope), parameter :: lexer_scope = enum_scope() !> Item identifying the scope and the corresponding token index type :: stack_item !> Current scope of the item, can only be removed with matching scope integer :: scope !> Token index in the buffer of the lexer, used for invalidation of unclosed groups integer :: token end type stack_item !> Reallocate the stack of scopes interface resize module procedure :: resize_scope end interface !> Tokenizer for TOML documents. type, extends(abstract_lexer) :: toml_lexer !> Name of the source file, used for error reporting character(len=:), allocatable :: filename !> Current internal position in the source chunk integer :: pos = 0 !> Current source chunk, for convenience stored as character array rather than string character(:, tfc), allocatable :: chunk !> Last scope of the lexer integer :: top = 0 !> Stack of scopes, used to identify the current state of the lexer type(stack_item), allocatable :: stack(:) !> Index in the buffer queue integer :: buffer = 0 !> Douple-ended queue for buffering tokens type(toml_context) :: context contains !> Obtain the next token procedure :: next !> Extract a string from a token procedure :: extract_string !> Extract an integer from a token procedure :: extract_integer !> Extract a float from a token procedure :: extract_float !> Extract a boolean from a token procedure :: extract_bool !> Extract a timestamp from a token procedure :: extract_datetime !> Get information about source procedure :: get_info end type toml_lexer contains !> Create a new instance of a lexer by reading from a file subroutine new_lexer_from_file(lexer, filename, error) !> Instance of the lexer type(toml_lexer), intent(out) :: lexer !> Name of the file to read from character(len=*), intent(in) :: filename !> Error code type(toml_error), allocatable, intent(out) :: error integer :: stat lexer%pos = 0 lexer%filename = filename call resize(lexer%stack) call read_whole_file(filename, lexer%chunk, stat) if (stat /= 0) then call make_error(error, \" Could not open file '\"//filename//\"' \") end if end subroutine new_lexer_from_file !> Create a new instance of a lexer by reading from a unit. !> !> Currently, only sequential access units can be processed by this constructor. subroutine new_lexer_from_unit(lexer, io, error) !> Instance of the lexer type(toml_lexer), intent(out) :: lexer !> Unit to read from integer, intent(in) :: io !> Error code type(toml_error), allocatable, intent(out) :: error character(:, tfc), allocatable :: source, line integer, parameter :: bufsize = 512 character(bufsize, tfc) :: filename, mode integer :: stat inquire(unit=io, access=mode, name=filename) select case(trim(mode)) case default stat = 1 case(\" sequential \", \" SEQUENTIAL \") allocate(character(0) :: source) do call read_whole_line(io, line, stat) if (stat > 0) exit source = source // line // TOML_NEWLINE if (stat < 0) then if (is_iostat_end(stat)) stat = 0 exit end if end do call new_lexer_from_string(lexer, source) end select if (len_trim(filename) > 0) lexer%filename = trim(filename) if (stat /= 0) then call make_error(error, \" Failed to read from unit \") end if end subroutine new_lexer_from_unit !> Create a new instance of a lexer by reading from a string. subroutine new_lexer_from_string(lexer, string) !> Instance of the lexer type(toml_lexer), intent(out) :: lexer !> String to read from character(*, tfc), intent(in) :: string integer :: length length = len(string) lexer%pos = 0 lexer%buffer = 0 allocate(character(length) :: lexer%chunk) lexer%chunk(:length) = string call resize(lexer%stack) end subroutine new_lexer_from_string !> Advance the lexer to the next token. subroutine next(lexer, token) !> Instance of the lexer class(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token if (lexer%buffer >= lexer%context%top) then call fill_buffer(lexer) end if lexer%buffer = lexer%buffer + 1 token = lexer%context%token(lexer%buffer) end subroutine next !> Fill the buffer with tokens, this routine will attempt to create as many tokens as !> necessary to determine whether all opened groups are closed properly. !> !> The state of the buffer can be changed while this routine is running, therefore !> accessing the buffer concurrently is not allowed. subroutine fill_buffer(lexer) !> Instance of the lexer class(toml_lexer), intent(inout) :: lexer type(toml_token) :: token integer :: stack_top, it lexer%buffer = 0 lexer%context%top = 0 stack_top = lexer%top ! Tokenization will cover always a complete scope do while(lexer%top >= stack_top .and. token%kind /= token_kind%eof) call next_token(lexer, token) call lexer%context%push_back(token) end do ! Flag all incomplete inline table and array scopes for the parser if (lexer%top > stack_top) then do it = lexer%top, stack_top + 1, -1 select case(lexer%stack(it)%scope) case(lexer_scope%table, lexer_scope%array) lexer%context%token(lexer%stack(it)%token)%kind = token_kind%unclosed end select end do end if end subroutine fill_buffer !> Actually generate the next token, unbuffered version subroutine next_token(lexer, token) !> Instance of the lexer class(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token integer :: prev, pos ! Consume current token lexer%pos = lexer%pos + token%last - token%first + 1 prev = lexer%pos pos = lexer%pos ! If lexer is exhausted, return EOF as early as possible if (pos > len(lexer%chunk)) then call pop(lexer, lexer_scope%equal) token = toml_token(token_kind%eof, prev, pos) return end if select case(peek(lexer, pos)) case(char_kind%hash) do while(all(peek(lexer, pos+1) /= [char_kind%carriage_return, char_kind%newline]) & & .and. pos <= len(lexer%chunk)) pos = pos + 1 end do token = toml_token(token_kind%comment, prev, pos) case(char_kind%space, char_kind%tab) do while(any(match(lexer, pos+1, [char_kind%space, char_kind%tab])) & & .and. pos <= len(lexer%chunk)) pos = pos + 1 end do token = toml_token(token_kind%whitespace, prev, pos) case(char_kind%newline) call pop(lexer, lexer_scope%equal) token = toml_token(token_kind%newline, prev, pos) case(char_kind%carriage_return) if (match(lexer, pos+1, char_kind%newline)) then pos = pos + 1 call pop(lexer, lexer_scope%equal) token = toml_token(token_kind%newline, prev, pos) else token = toml_token(token_kind%invalid, prev, pos) end if case(char_kind%dot) if (view_scope(lexer) == lexer_scope%table) then token = toml_token(token_kind%dot, prev, pos) else token = toml_token(token_kind%invalid, prev, pos) end if case(char_kind%comma) call pop(lexer, lexer_scope%equal) token = toml_token(token_kind%comma, prev, pos) case(char_kind%equal) token = toml_token(token_kind%equal, prev, pos) call push_back(lexer, lexer_scope%equal, lexer%context%top + 1) case(char_kind%lbrace) token = toml_token(token_kind%lbrace, prev, pos) call push_back(lexer, lexer_scope%table, lexer%context%top + 1) case(char_kind%rbrace) call pop(lexer, lexer_scope%equal) call pop(lexer, lexer_scope%table) token = toml_token(token_kind%rbrace, prev, pos) case(char_kind%lbracket) token = toml_token(token_kind%lbracket, prev, pos) if (any(view_scope(lexer) == [lexer_scope%equal, lexer_scope%array])) then call push_back(lexer, lexer_scope%array, lexer%context%top + 1) end if case(char_kind%rbracket) call pop(lexer, lexer_scope%array) token = toml_token(token_kind%rbracket, prev, pos) case(char_kind%squote) call next_sstring(lexer, token) case(char_kind%dquote) call next_dstring(lexer, token) case default if (view_scope(lexer) == lexer_scope%table) then call next_keypath(lexer, token) else call next_literal(lexer, token) end if end select end subroutine next_token !> Process next literal string token, can produce normal literals and multiline literals subroutine next_sstring(lexer, token) !> Instance of the lexer type(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token character(1, tfc) :: ch integer :: prev, pos, it logical :: valid prev = lexer%pos pos = lexer%pos if (all(match(lexer, [pos+1, pos+2], char_kind%squote))) then pos = pos + 3 pos = strstr(lexer%chunk(pos:), char_kind%squote3) + pos - 1 if (pos < prev + 3) then token = toml_token(token_kind%invalid, prev, len(lexer%chunk)) return end if do it = 1, 2 if (match(lexer, pos+3, char_kind%squote)) pos = pos + 1 end do valid = .true. do it = prev + 3, pos - 1 ch = peek(lexer, it) valid = valid .and. valid_string(ch) end do token = toml_token(merge(token_kind%mliteral, token_kind%invalid, valid), prev, pos+2) return end if valid = .true. do while(pos < len(lexer%chunk)) pos = pos + 1 ch = peek(lexer, pos) valid = valid .and. valid_string(ch) if (ch == char_kind%squote) exit if (ch == char_kind%newline) then pos = pos - 1 valid = .false. exit end if end do valid = valid .and. peek(lexer, pos) == char_kind%squote .and. pos /= prev token = toml_token(merge(token_kind%literal, token_kind%invalid, valid), prev, pos) end subroutine next_sstring !> Process next string token, can produce normal string and multiline string tokens subroutine next_dstring(lexer, token) !> Instance of the lexer type(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token character(1, tfc) :: ch character(*, tfc), parameter :: hexnum = \" 0123456789 ABCDEF \", valid_escape = \" btnfr \\ \"\"\" integer :: prev, pos, expect, it, hex logical :: escape, valid, space prev = lexer%pos pos = lexer%pos hex = 0 if (all(match(lexer, [pos+1, pos+2], char_kind%dquote))) then pos = pos + 3 do it = strstr(lexer%chunk(pos:), char_kind%dquote3) pos = it + pos - 1 if (pos < prev + 3 .or. it == 0) then token = toml_token(token_kind%invalid, prev, len(lexer%chunk)) return end if if (match(lexer, pos-1, char_kind%backslash)) then pos = pos + 1 cycle end if do it = 1, 2 if (match(lexer, pos+3, char_kind%dquote)) pos = pos + 1 end do exit end do valid = .true. escape = .false. space = .false. expect = 0 do it = prev + 3, pos - 1 ch = peek(lexer, it) if (escape) then space = verify(ch, char_kind%space//char_kind%tab//& & char_kind%carriage_return//char_kind%newline) == 0 end if if (space) then escape = .false. if (ch == char_kind%newline) then if (expect > 0) expect = expect - 1 space = .false. cycle end if if (verify(ch, char_kind%space//char_kind%tab) == 0 .and. expect == 0) cycle if (ch == char_kind%carriage_return) then expect = 1 cycle end if valid = .false. space = .false. expect = 0 cycle end if valid = valid .and. valid_string(ch) if (escape) then escape = .false. space = .false. if (verify(ch, valid_escape) == 0) cycle if (ch == \" u \") then expect = 4 hex = pos + 1 cycle end if if (ch == \" U \") then expect = 8 hex = pos + 1 cycle end if valid = .false. cycle end if if (expect > 0) then expect = expect - 1 valid = valid .and. verify(ch, hexnum) == 0 if (expect == 0) valid = valid .and. verify_ucs(lexer%chunk(hex:pos)) cycle end if escape = ch == char_kind%backslash end do ! Check for any unfinished escape sequences valid = valid .and. expect == 0 .and. .not.(escape.or.space) token = toml_token(merge(token_kind%mstring, token_kind%invalid, valid), prev, pos+2) return end if valid = .true. escape = .false. expect = 0 do while(pos < len(lexer%chunk)) pos = pos + 1 ch = peek(lexer, pos) valid = valid .and. valid_string(ch) if (escape) then escape = .false. if (verify(ch, valid_escape) == 0) cycle if (ch == \" u \") then expect = 4 hex = pos + 1 cycle end if if (ch == \" U \") then expect = 8 hex = pos + 1 cycle end if valid = .false. cycle end if if (expect > 0) then expect = expect - 1 valid = valid .and. verify(ch, hexnum) == 0 if (expect == 0) valid = valid .and. verify_ucs(lexer%chunk(hex:pos)) cycle end if escape = ch == char_kind%backslash if (ch == char_kind%dquote) exit if (ch == char_kind%newline) then pos = pos - 1 valid = .false. exit end if end do valid = valid .and. peek(lexer, pos) == char_kind%dquote .and. pos /= prev token = toml_token(merge(token_kind%string, token_kind%invalid, valid), prev, pos) end subroutine next_dstring !> Validate characters in string, non-printable characters are invalid in this context pure function valid_string(ch) result(valid) character(1, tfc), intent(in) :: ch logical :: valid character(1, tfc), parameter :: x00 = achar(int(z\" 00 \")), x08 = achar(int(z\" 08 \")), & & x0b = achar(int(z\" 0 b \")), x1f = achar(int(z\" 1 f \")), x7f = achar(int(z\" 7 f \")) valid = & & .not.(x00 <= ch .and. ch <= x08) .and. & & .not.(x0b <= ch .and. ch <= x1f) .and. & & ch /= x7f end function !> Process next bare key token, produces keypath tokens. subroutine next_keypath(lexer, token) !> Instance of the lexer type(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token logical :: valid integer :: prev, pos character(1, tfc) :: ch prev = lexer%pos pos = lexer%pos ch = peek(lexer, pos) valid = (tfc_\" A \" <= ch .and. ch <= tfc_\" Z \") & & .or. (tfc_\" a \" <= ch .and. ch <= tfc_\" z \") & & .or. (verify(ch, char_kind%literal) == 0) do while(verify(peek(lexer, pos+1), terminated//char_kind%dot) > 0) pos = pos + 1 ch = peek(lexer, pos) if (tfc_\" A \" <= ch .and. ch <= tfc_\" Z \") cycle if (tfc_\" a \" <= ch .and. ch <= tfc_\" z \") cycle if (verify(ch, char_kind%literal) == 0) cycle valid = .false. cycle end do token = toml_token(merge(token_kind%keypath, token_kind%invalid, valid), prev, pos) end subroutine next_keypath !> Identify literal values, produces integer, float, boolean, and datetime tokens. subroutine next_literal(lexer, token) !> Instance of the lexer type(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token integer :: prev, pos integer, parameter :: offset(*) = [0, 1, 2, 3, 4, 5] character(1, tfc), parameter :: & & true(4) = [\" t \", \" r \", \" u \", \" e \"], false(5) = [\" f \", \" a \", \" l \", \" s \", \" e \"] prev = lexer%pos pos = lexer%pos select case(peek(lexer, pos)) case(\" t \") if (match_all(lexer, pos+offset(:4), true) .and. & & verify(peek(lexer, pos+4), terminated) == 0) then token = toml_token(token_kind%bool, prev, pos+3) return end if case(\" f \") if (match_all(lexer, pos+offset(:5), false) .and. & & verify(peek(lexer, pos+5), terminated) == 0) then token = toml_token(token_kind%bool, prev, pos+4) return end if case default call next_datetime(lexer, token) if (token%kind == token_kind%datetime) return call next_integer(lexer, token) if (token%kind == token_kind%int) return call next_float(lexer, token) if (token%kind == token_kind%float) return end select ! If the current token is invalid, advance to the next terminator do while(verify(peek(lexer, pos+1), terminated) > 0) pos = pos + 1 end do token = toml_token(token_kind%invalid, prev, pos) end subroutine next_literal !> Process integer tokens and binary, octal, and hexadecimal literals. subroutine next_integer(lexer, token) !> Instance of the lexer type(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token character(*, tfc), parameter :: toml_base(4) = [& & \" 0123456789 abcdefABCDEF \", & & \" 0123456789000000000000 \", & & \" 0123456700000000000000 \", & & \" 0100000000000000000000 \"] integer, parameter :: b10 = 2, b16 = 1, b8 = 3, b2 = 4 character(1, tfc) :: ch integer :: prev, pos, base logical :: underscore, okay prev = lexer%pos pos = lexer%pos okay = .true. underscore = .true. base = b10 if (any(match(lexer, pos, [\" + \", \" - \"]))) then pos = pos + 1 end if if (match(lexer, pos, \" 0 \")) then select case(peek(lexer, pos+1)) case(\" x \") okay = pos == prev base = b16 pos = pos + 2 case(\" o \") okay = pos == prev base = b8 pos = pos + 2 case(\" b \") okay = pos == prev base = b2 pos = pos + 2 case(char_kind%space, char_kind%tab, char_kind%newline, char_kind%carriage_return, & & char_kind%hash, char_kind%rbrace, char_kind%rbracket, char_kind%comma) token = toml_token(token_kind%int, prev, pos) return case default do while(verify(peek(lexer, pos), terminated) > 0) pos = pos + 1 end do token = toml_token(token_kind%invalid, prev, pos-1) return end select end if do while(pos <= len(lexer%chunk)) ch = peek(lexer, pos) if (ch == \" _ \") then if (underscore) then token = toml_token(token_kind%invalid, prev, pos) return end if underscore = .true. pos = pos + 1 cycle end if if (verify(ch, toml_base(base)) == 0) then pos = pos + 1 underscore = .false. cycle end if okay = okay .and. verify(ch, terminated) == 0 exit end do okay = .not.underscore .and. okay token = toml_token(merge(token_kind%int, token_kind%invalid, okay), prev, pos-1) end subroutine next_integer !> Process float tokens. subroutine next_float(lexer, token) !> Instance of the lexer type(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token integer :: prev, pos logical :: plus_minus, underscore, point, expo, okay, zero, first character(1, tfc) :: ch integer, parameter :: offset(*) = [0, 1, 2] character(1, tfc), parameter :: nan(3) = [\" n \", \" a \", \" n \"], inf(3) = [\" i \", \" n \", \" f \"] prev = lexer%pos pos = lexer%pos point = .false. expo = .false. zero = .false. first = .true. underscore = .true. plus_minus = any(match(lexer, pos, [\" + \", \" - \"])) if (plus_minus) pos = pos + 1 if (match_all(lexer, pos+offset, nan) .and. & & verify(peek(lexer, pos+3), terminated) == 0) then token = toml_token(token_kind%float, prev, pos+2) return end if if (match_all(lexer, pos+offset, inf) .and. & & verify(peek(lexer, pos+3), terminated) == 0) then token = toml_token(token_kind%float, prev, pos+2) return end if do while(pos <= len(lexer%chunk)) ch = peek(lexer, pos) if (ch == \" _ \") then if (underscore) then token = toml_token(token_kind%invalid, prev, pos) return end if underscore = .true. pos = pos + 1 cycle end if if (ch == \" . \") then if (point .or. expo .or. underscore) then token = toml_token(token_kind%invalid, prev, pos) return end if zero = .false. underscore = .true. point = .true. pos = pos + 1 cycle end if if (ch == \" e \" .or. ch == \" E \") then if (expo .or. underscore) then token = toml_token(token_kind%invalid, prev, pos) return end if zero = .false. underscore = .true. expo = .true. pos = pos + 1 cycle end if if (ch == \" + \" .or. ch == \" - \") then if (.not.any(match(lexer, pos-1, [\" e \", \" E \"]))) then token = toml_token(token_kind%invalid, prev, pos) return end if underscore = .true. pos = pos + 1 cycle end if if (verify(ch, \" 0123456789 \") == 0) then if (zero) then token = toml_token(token_kind%invalid, prev, pos) return end if zero = first .and. ch == \" 0 \" first = .false. pos = pos + 1 underscore = .false. cycle end if exit end do okay = .not.underscore .and. (expo .or. point) token = toml_token(merge(token_kind%float, token_kind%invalid, okay), prev, pos-1) end subroutine next_float !> Find the next datetime expression subroutine next_datetime(lexer, token) !> Instance of the lexer type(toml_lexer), intent(inout) :: lexer !> Current lexeme type(toml_token), intent(inout) :: token logical :: has_date, has_time, has_millisec, has_local, okay integer :: prev, pos, it integer, parameter :: offset(*) = [(it, it = 0, 10)], & & offset_date = 10, offset_time = 8, offset_local = 6 character(*, tfc), parameter :: num = \" 0123456789 \" prev = lexer%pos pos = lexer%pos has_date = valid_date(peek(lexer, pos+offset(:offset_date))) if (has_date) then if (verify(peek(lexer, pos+offset_date), \" Tt \") == 0 & & .and. pos + offset_date < len(lexer%chunk) & & .and. verify(peek(lexer, pos+offset_date+1), num) == 0) then pos = pos + offset_date + 1 end if end if has_time = valid_time(peek(lexer, pos+offset(:offset_time))) if (has_time) then pos = pos + offset_time - 1 if (match(lexer, pos+1, char_kind%dot)) then it = 1 do while(verify(peek(lexer, pos+it+1), num) == 0) it = it + 1 end do has_millisec = it > 1 if (.not.has_millisec) then token = toml_token(token_kind%invalid, prev, prev) return end if pos = pos + it end if has_local = valid_local(peek(lexer, pos+offset(:offset_local)+1)) if (has_local) then if (.not.has_date) then token = toml_token(token_kind%invalid, prev, prev) return end if pos = pos + offset_local else if (verify(peek(lexer, pos+1), \" zZ \") == 0) then pos = pos + 1 end if end if if (.not.(has_time.or.has_date)) then token = toml_token(token_kind%invalid, prev, prev) return end if if (.not.has_time.and.has_date) pos = pos + offset_date - 1 okay = verify(peek(lexer, pos+1), terminated) == 0 .and. pos <= len(lexer%chunk) token = toml_token(merge(token_kind%datetime, token_kind%invalid, okay), prev, pos) end subroutine next_datetime !> Validate a string as date pure function valid_date(string) result(valid) !> Input string, 10 characters character(1, tfc), intent(in) :: string(:) !> Valid date logical :: valid integer :: it, val character(*, tfc), parameter :: num = \" 0123456789 \" integer :: year, month, day, mday logical :: leap valid = .false. if (any(string([5, 8]) /= \" - \")) return year = 0 do it = 1, 4 val = scan(num, string(it)) - 1 if (val < 0) return year = year * 10 + val end do month = 0 do it = 6, 7 val = scan(num, string(it)) - 1 if (val < 0) return month = month * 10 + val end do day = 0 do it = 9, 10 val = scan(num, string(it)) - 1 if (val < 0) return day = day * 10 + val end do mday = 0 select case(month) case(1, 3, 5, 7, 8, 10, 12) mday = 31 case(2) leap = mod(year, 4) == 0 .and. (mod(year, 100) /= 0 .or. mod(year, 400) == 0) mday = merge(29, 28, leap) case(4, 6, 9, 11) mday = 30 end select valid = day >= 1 .and. day <= mday end function valid_date !> Validate a string as time function valid_time(string) result(valid) !> Input string, 8 characters character(1, tfc), intent(in) :: string(:) !> Valid time logical :: valid integer :: it, val character(*, tfc), parameter :: num = \" 0123456789 \" integer :: hour, minute, second valid = .false. if (any(string([3, 6]) /= \" : \")) return hour = 0 do it = 1, 2 val = scan(num, string(it)) - 1 if (val < 0) return hour = hour * 10 + val end do minute = 0 do it = 4, 5 val = scan(num, string(it)) - 1 if (val < 0) return minute = minute * 10 + val end do second = 0 do it = 7, 8 val = scan(num, string(it)) - 1 if (val < 0) return second = second * 10 + val end do valid = second >= 0 .and. second < 60 & & .and. minute >= 0 .and. minute < 60 & & .and. hour >= 0 .and. hour < 24 end function valid_time !> Validate a string as timezone function valid_local(string) result(valid) !> Input string, 6 characters character(1, tfc), intent(in) :: string(:) !> Valid timezone logical :: valid integer :: it, val character(*, tfc), parameter :: num = \" 0123456789 \" integer :: hour, minute valid = .false. if (string(4) /= \" : \" .or. all(string(1) /= [\" + \", \" - \"])) return hour = 0 do it = 2, 3 val = scan(num, string(it)) - 1 if (val < 0) return hour = hour * 10 + val end do minute = 0 do it = 5, 6 val = scan(num, string(it)) - 1 if (val < 0) return minute = minute * 10 + val end do valid = minute >= 0 .and. minute < 60 & & .and. hour >= 0 .and. hour < 24 end function valid_local !> Show current character elemental function peek(lexer, pos) result(ch) !> Instance of the lexer type(toml_lexer), intent(in) :: lexer !> Position to fetch character from integer, intent(in) :: pos !> Character found character(1, tfc) :: ch if (pos <= len(lexer%chunk)) then ch = lexer%chunk(pos:pos) else ch = char_kind%space end if end function peek !> Compare a character elemental function match(lexer, pos, kind) !> Instance of the lexer type(toml_lexer), intent(in) :: lexer !> Position to fetch character from integer, intent(in) :: pos !> Character to compare against character(1, tfc), intent(in) :: kind !> Characters match logical :: match match = peek(lexer, pos) == kind end function match !> Compare a set of characters pure function match_all(lexer, pos, kind) result(match) !> Instance of the lexer type(toml_lexer), intent(in) :: lexer !> Position to fetch character from integer, intent(in) :: pos(:) !> Character to compare against character(1, tfc), intent(in) :: kind(:) !> Characters match logical :: match match = all(peek(lexer, pos) == kind) end function match_all pure function strstr(string, pattern) result(res) character(*, tfc), intent(in) :: string character(*, tfc), intent(in) :: pattern integer :: lps_array(len(pattern)) integer :: res, s_i, p_i, length_string, length_pattern res = 0 length_string = len(string) length_pattern = len(pattern) if (length_pattern > 0 .and. length_pattern <= length_string) then lps_array = compute_lps(pattern) s_i = 1 p_i = 1 do while(s_i <= length_string) if (string(s_i:s_i) == pattern(p_i:p_i)) then if (p_i == length_pattern) then res = s_i - length_pattern + 1 exit end if s_i = s_i + 1 p_i = p_i + 1 else if (p_i > 1) then p_i = lps_array(p_i - 1) + 1 else s_i = s_i + 1 end if end do end if contains pure function compute_lps(string) result(lps_array) character(*, tfc), intent(in) :: string integer :: lps_array(len(string)) integer :: i, j, length_string length_string = len(string) if (length_string > 0) then lps_array(1) = 0 i = 2 j = 1 do while (i <= length_string) if (string(j:j) == string(i:i)) then lps_array(i) = j i = i + 1 j = j + 1 else if (j > 1) then j = lps_array(j - 1) + 1 else lps_array(i) = 0 i = i + 1 end if end do end if end function compute_lps end function strstr !> Extract string value of token, works for keypath, string, multiline string, literal, !> and mulitline literal tokens. subroutine extract_string(lexer, token, string) !> Instance of the lexer class(toml_lexer), intent(in) :: lexer !> Token to extract string value from type(toml_token), intent(in) :: token !> String value of token character(len=:), allocatable, intent(out) :: string integer :: it, length logical :: escape, leading_newline character(1, tfc) :: ch length = token%last - token%first + 1 select case(token%kind) case(token_kind%string) string = \"\" escape = .false. it = token%first + 1 do while(it <= token%last - 1) ch = peek(lexer, it) if (escape) then escape = .false. select case(ch) case(\"\"\"\", \" \\ \");  string = string // ch case(\" b \"); string = string // TOML_BACKSPACE case(\" t \"); string = string // TOML_TABULATOR case(\" n \"); string = string // TOML_NEWLINE case(\" r \"); string = string // TOML_CARRIAGE_RETURN case(\" f \"); string = string // TOML_FORMFEED case(\" u \"); string = string // convert_ucs(lexer%chunk(it+1:it+4)); it = it + 5 case(\" U \"); string = string // convert_ucs(lexer%chunk(it+1:it+8)); it = it + 9 end select else escape = ch == char_kind%backslash if (.not.escape) string = string // ch end if it = it + 1 end do case(token_kind%mstring) leading_newline = peek(lexer, token%first+3) == char_kind%newline string = \"\" escape = .false. it = token%first + merge(4, 3, leading_newline) do while(it <= token%last - 3) ch = peek(lexer, it) if (escape) then escape = .false. select case(ch) case(\"\"\"\", \" \\ \");  string = string // ch case(\" b \"); string = string // TOML_BACKSPACE case(\" t \"); string = string // TOML_TABULATOR case(\" n \"); string = string // TOML_NEWLINE case(\" r \"); string = string // TOML_CARRIAGE_RETURN case(\" f \"); string = string // TOML_FORMFEED case(\" u \"); string = string // convert_ucs(lexer%chunk(it+1:it+4)); it = it + 5 case(\" U \"); string = string // convert_ucs(lexer%chunk(it+1:it+8)); it = it + 9 case(char_kind%space, char_kind%tab, char_kind%carriage_return) escape = .true. case(char_kind%newline) continue end select else escape = ch == char_kind%backslash if (.not.escape) string = string // ch end if it = it + 1 end do case(token_kind%literal) allocate(character(length - 2)::string) string = lexer%chunk(token%first+1:token%last-1) case(token_kind%mliteral) leading_newline = peek(lexer, token%first+3) == char_kind%newline allocate(character(length - merge(7, 6, leading_newline))::string) string = lexer%chunk(token%first+merge(4, 3, leading_newline):token%last-3) case(token_kind%keypath) allocate(character(length)::string) string = lexer%chunk(token%first:token%last) end select end subroutine extract_string !> Extract integer value of token subroutine extract_integer(lexer, token, val) !> Instance of the lexer class(toml_lexer), intent(in) :: lexer !> Token to extract integer value from type(toml_token), intent(in) :: token !> Integer value of token integer(tfi), intent(out) :: val integer :: first, base, it, tmp logical :: minus character(1, tfc) :: ch character(*, tfc), parameter :: num = \" 0123456789 abcdef \" if (token%kind /= token_kind%int) return val = 0 base = 10 first = token%first if (any(peek(lexer, first) == [\" + \", \" - \"])) first = first + 1 if (peek(lexer, first) == \" 0 \") then select case(peek(lexer, first + 1)) case(\" x \") first = first + 2 base = 16 case(\" o \") first = first + 2 base = 8 case(\" b \") first = first + 2 base = 2 case default return end select end if minus = match(lexer, token%first, char_kind%minus) do it = first, token%last ch = peek(lexer, it) if (\" A \" <= ch .and. ch <= \" Z \") ch = achar(iachar(ch) - iachar(\" A \") + iachar(\" a \")) tmp = scan(num(:abs(base)), ch) - 1 if (tmp < 0) cycle val = val * base + merge(-tmp, tmp, minus) end do end subroutine extract_integer !> Extract floating point value of token subroutine extract_float(lexer, token, val) ! Not useable since unsupported with GFortran on some platforms (MacOS/ppc) ! use, intrinsic :: ieee_arithmetic, only : ieee_value, ieee_quite_nan, & !    & ieee_positive_inf, ieee_negative_inf !> Instance of the lexer class(toml_lexer), intent(in) :: lexer !> Token to extract floating point value from type(toml_token), intent(in) :: token !> Floating point value of token real(tfr), intent(out) :: val integer :: first, it, ic character(len=token%last - token%first + 1) :: buffer character(1, tfc) :: ch if (token%kind /= token_kind%float) return first = token%first if (any(peek(lexer, first) == [\" + \", \" - \"])) first = first + 1 if (match(lexer, first, \" n \")) then ! val = ieee_value(val, ieee_quite_nan) buffer = \" NaN \" read(buffer, *, iostat=ic) val return end if if (match(lexer, first, \" i \")) then ! val = ieee_value(val, ieee_positive_inf) buffer = \" Inf \" read(buffer, *, iostat=ic) val if (match(lexer, token%first, char_kind%minus)) val = -val return end if !   ival = 0 !   idot = 0 ! !   do it = first, token%last !      ch = peek(lexer, it) !      if (any(ch == [\" . \", \" e \", \" E \"])) exit !      tmp = scan(num(:base), ch) - 1 !      if (tmp < 0) cycle !      ival = ival * base + tmp !   end do !   first = it ! !   if (ch == \" . \") then !      idot = 0 !      do it = first, token%last !         ch = peek(lexer, it) !         if (any(ch == [\" e \", \" E \"])) exit !         tmp = scan(num(:base), ch) - 1 !         if (tmp < 0) cycle !         idot = idot + 1 !         ival = ival * base + tmp !      end do !      first = it !   end if ! !   expo = 0 !   if (any(ch == [\" e \", \" E \"])) then !      first = first + 1 !      do it = first, token%last !         ch = peek(lexer, it) !         tmp = scan(num(:base), ch) - 1 !         if (tmp < 0) cycle !         expo = expo * base + tmp !      end do !      if (match(lexer, first, char_kind%minus)) expo = -expo !   end if !   expo = expo - idot !   val = ival * 10.0_tfr ** expo  ! FIXME ! !   if (match(lexer, token%first, char_kind%minus)) val = -val ic = 0 do it = token%first, token%last ch = peek(lexer, it) if (ch == \" _ \") cycle ic = ic + 1 buffer(ic:ic) = ch end do read(buffer(:ic), *, iostat=it) val end subroutine extract_float !> Extract boolean value of token subroutine extract_bool(lexer, token, val) !> Instance of the lexer class(toml_lexer), intent(in) :: lexer !> Token to extract boolean value from type(toml_token), intent(in) :: token !> Boolean value of token logical, intent(out) :: val if (token%kind /= token_kind%bool) return val = peek(lexer, token%first) == \" t \" end subroutine extract_bool !> Extract datetime value of token subroutine extract_datetime(lexer, token, val) !> Instance of the lexer class(toml_lexer), intent(in) :: lexer !> Token to extract datetime value from type(toml_token), intent(in) :: token !> Datetime value of token type(toml_datetime), intent(out) :: val if (token%kind /= token_kind%datetime) return val = toml_datetime(lexer%chunk(token%first:token%last)) end subroutine extract_datetime !> Push a new scope onto the lexer stack and record the token pure subroutine push_back(lexer, scope, token) type(toml_lexer), intent(inout) :: lexer integer, intent(in) :: scope integer, intent(in) :: token lexer%top = lexer%top + 1 if (lexer%top > size(lexer%stack)) call resize(lexer%stack) lexer%stack(lexer%top) = stack_item(scope, token) end subroutine push_back !> Pop a scope from the lexer stack in case the topmost scope matches the requested scope subroutine pop(lexer, scope) type(toml_lexer), intent(inout) :: lexer integer, intent(in) :: scope if (lexer%top > 0) then if (lexer%stack(lexer%top)%scope == scope) lexer%top = lexer%top - 1 end if end subroutine pop !> Peek at the topmost scope on the lexer stack pure function view_scope(lexer) result(scope) type(toml_lexer), intent(in) :: lexer integer :: scope if (lexer%top > 0) then scope = lexer%stack(lexer%top)%scope else scope = lexer_scope%table end if end function view_scope !> Reallocate list of scopes pure subroutine resize_scope(var, n) !> Instance of the array to be resized type(stack_item), allocatable, intent(inout) :: var(:) !> Dimension of the final array size integer, intent(in), optional :: n type(stack_item), allocatable :: tmp(:) integer :: this_size, new_size integer, parameter :: initial_size = 8 if (allocated(var)) then this_size = size(var, 1) call move_alloc(var, tmp) else this_size = initial_size end if if (present(n)) then new_size = n else new_size = this_size + this_size/2 + 1 end if allocate(var(new_size)) if (allocated(tmp)) then this_size = min(size(tmp, 1), size(var, 1)) var(:this_size) = tmp(:this_size) deallocate(tmp) end if end subroutine resize_scope !> Extract information about the source subroutine get_info(lexer, meta, output) !> Instance of the lexer class(toml_lexer), intent(in) :: lexer !> Query about the source character(*, tfc), intent(in) :: meta !> Metadata about the source character(:, tfc), allocatable, intent(out) :: output select case(meta) case(\" source \") output = lexer%chunk // TOML_NEWLINE case(\" filename \") if (allocated(lexer%filename)) output = lexer%filename end select end subroutine get_info function hex_to_int(hex) result(val) character(*, tfc), intent(in) :: hex integer(tfi) :: val integer :: i character(1, tfc) :: ch character(*, tfc), parameter :: hex_digits = \" 0123456789 abcdef \" val = 0_tfi do i = 1, len(hex) ch = hex(i:i) if (\" A \" <= ch .and. ch <= \" Z \") ch = achar(iachar(ch) - iachar(\" A \") + iachar(\" a \")) val = val * 16 + max(index(hex_digits, ch) - 1, 0) end do end function hex_to_int function verify_ucs(escape) result(valid) character(*, tfc), intent(in) :: escape logical :: valid integer(tfi) :: code code = hex_to_int(escape) valid = code > 0 .and. code < int(z\" 7 FFFFFFF \", tfi) & & .and. (code < int(z\" d800 \", tfi) .or. code > int(z\" dfff \", tfi)) & & .and. (code < int(z\" fffe \", tfi) .or. code > int(z\" ffff \", tfi)) end function verify_ucs function convert_ucs(escape) result(str) character(*, tfc), intent(in) :: escape character(:, tfc), allocatable :: str integer(tfi) :: code code = hex_to_int(escape) select case(code) case(int(z\" 00000000 \", tfi):int(z\" 0000007 f \", tfi)) str = achar(code, kind=tfc) case(int(z\" 00000080 \", tfi):int(z\" 000007 ff \", tfi)) str = & achar(ior(int(z\" c0 \", tfi), ishft(code, -6)), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(code, int(z\" 3 f \", tfi))), kind=tfc) case(int(z\" 00000800 \", tfi):int(z\" 0000 ffff \", tfi)) str = & achar(ior(int(z\" e0 \", tfi), ishft(code, -12)), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -6), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(code, int(z\" 3 f \", tfi))), kind=tfc) case(int(z\" 00010000 \", tfi):int(z\" 001 fffff \", tfi)) str = & achar(ior(int(z\" f0 \", tfi), ishft(code, -18)), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -12), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -6), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(code, int(z\" 3 f \", tfi))), kind=tfc) case(int(z\" 00200000 \", tfi):int(z\" 03 ffffff \", tfi)) str = & achar(ior(int(z\" f8 \", tfi), ishft(code, -24)), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -18), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -12), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -6), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(code, int(z\" 3 f \", tfi))), kind=tfc) case(int(z\" 04000000 \", tfi):int(z\" 7 fffffff \", tfi)) str = & achar(ior(int(z\" fc \", tfi), ishft(code, -30)), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -24), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -18), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -12), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(ishft(code, -6), int(z\" 3 f \", tfi))), kind=tfc) // & achar(ior(int(z\" 80 \", tfi), iand(code, int(z\" 3 f \" , tfi ))), kind = tfc ) end select end function convert_ucs end module tomlf_de_lexer","tags":"","url":"sourcefile/lexer.f90.html"},{"title":"diagnostic.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Diagnostic message support for TOML Fortran module tomlf_diagnostic use tomlf_terminal , only : toml_terminal , ansi_code , operator ( // ), operator ( + ) implicit none private public :: render public :: toml_diagnostic , toml_label interface render module procedure render_diagnostic module procedure render_text module procedure render_text_with_label module procedure render_text_with_labels end interface render !> Enumerator for diagnostic levels type :: level_enum integer :: error = 0 integer :: warning = 1 integer :: help = 2 integer :: note = 3 integer :: info = 4 end type level_enum !> Actual enumerator values type ( level_enum ), parameter , public :: toml_level = level_enum () type toml_label !> Level of message integer :: level !> Primary message logical :: primary !> First and last character of message integer :: first , last !> Message text character ( len = :), allocatable :: text !> Identifier of context character ( len = :), allocatable :: source end type toml_label interface toml_label module procedure new_label end interface toml_label !> Definition of diagnostic message type :: toml_diagnostic !> Level of message integer :: level !> Primary message character ( len = :), allocatable :: message !> Context of the diagnostic source character ( len = :), allocatable :: source !> Messages associated with this diagnostic type ( toml_label ), allocatable :: label (:) end type toml_diagnostic interface toml_diagnostic module procedure new_diagnostic end interface toml_diagnostic type :: line_token integer :: first , last end type line_token character ( len =* ), parameter :: nl = new_line ( 'a' ) contains pure function new_label ( level , first , last , text , primary ) result ( new ) integer , intent ( in ) :: level integer , intent ( in ) :: first , last character ( len =* ), intent ( in ), optional :: text logical , intent ( in ), optional :: primary type ( toml_label ) :: new if ( present ( text )) new % text = text new % level = level new % first = first new % last = last if ( present ( primary )) then new % primary = primary else new % primary = . false . end if end function new_label !> Create new diagnostic message pure function new_diagnostic ( level , message , source , label ) result ( new ) !> Level of message integer , intent ( in ) :: level !> Primary message character ( len =* ), intent ( in ), optional :: message !> Context of the diagnostic source character ( len =* ), intent ( in ), optional :: source !> Messages associated with this diagnostic type ( toml_label ), intent ( in ), optional :: label (:) type ( toml_diagnostic ) :: new new % level = level if ( present ( message )) new % message = message if ( present ( source )) new % source = source if ( present ( label )) new % label = label end function new_diagnostic pure function line_tokens ( input ) result ( token ) character ( len =* ), intent ( in ) :: input type ( line_token ), allocatable :: token (:) integer :: first , last first = 1 last = 1 allocate ( token ( 0 )) do while ( first <= len ( input )) if ( input ( last : last ) /= nl ) then last = last + 1 cycle end if token = [ token , line_token ( first , last - 1 )] first = last + 1 last = first end do end function line_tokens recursive pure function render_diagnostic ( diag , input , color ) result ( string ) character ( len =* ), intent ( in ) :: input type ( toml_diagnostic ), intent ( in ) :: diag type ( toml_terminal ), intent ( in ) :: color character ( len = :), allocatable :: string string = & render_message ( diag % level , diag % message , color ) if ( allocated ( diag % label )) then string = string // nl // & render_text_with_labels ( input , diag % label , color , source = diag % source ) end if end function render_diagnostic pure function render_message ( level , message , color ) result ( string ) integer , intent ( in ) :: level character ( len =* ), intent ( in ), optional :: message type ( toml_terminal ), intent ( in ) :: color character ( len = :), allocatable :: string if ( present ( message )) then string = & level_name ( level , color ) // color % bold // \": \" // message // color % reset else string = & level_name ( level , color ) end if end function render_message pure function level_name ( level , color ) result ( string ) integer , intent ( in ) :: level type ( toml_terminal ), intent ( in ) :: color character ( len = :), allocatable :: string select case ( level ) case ( toml_level % error ) string = color % bold + color % red // \"error\" // color % reset case ( toml_level % warning ) string = color % bold + color % yellow // \"warning\" // color % reset case ( toml_level % help ) string = color % bold + color % cyan // \"help\" // color % reset case ( toml_level % note ) string = color % bold + color % blue // \"note\" // color % reset case ( toml_level % info ) string = color % bold + color % magenta // \"info\" // color % reset case default string = color % bold + color % blue // \"unknown\" // color % reset end select end function level_name pure function render_source ( source , offset , color ) result ( string ) character ( len =* ), intent ( in ) :: source integer , intent ( in ) :: offset type ( toml_terminal ), intent ( in ) :: color character ( len = :), allocatable :: string string = & & repeat ( \" \" , offset ) // ( color % bold + color % blue ) // \"-->\" // color % reset // \" \" // source end function render_source function render_text ( input , color , source ) result ( string ) character ( len =* ), intent ( in ) :: input type ( toml_terminal ), intent ( in ) :: color character ( len =* ), intent ( in ), optional :: source character ( len = :), allocatable :: string integer :: it , offset type ( line_token ), allocatable :: token (:) allocate ( token ( 0 )) ! avoid compiler warning token = line_tokens ( input ) offset = integer_width ( size ( token )) if ( present ( source )) then string = render_source ( source , offset , color ) // nl // & & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset else string = & & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset end if do it = 1 , size ( token ) string = string // nl // & & render_line ( input ( token ( it )% first : token ( it )% last ), to_string ( it , offset ), color ) end do string = string // nl // & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset end function render_text function render_text_with_label ( input , label , color , source ) result ( string ) character ( len =* ), intent ( in ) :: input type ( toml_label ), intent ( in ) :: label type ( toml_terminal ), intent ( in ) :: color character ( len =* ), intent ( in ), optional :: source character ( len = :), allocatable :: string integer :: it , offset , first , last , line , shift type ( line_token ), allocatable :: token (:) allocate ( token ( 0 )) ! avoid compiler warning token = line_tokens ( input ) line = count ( token % first < label % first ) shift = token ( line )% first - 1 first = max ( 1 , line - 1 ) last = min ( size ( token ), line + 1 ) offset = integer_width ( last ) if ( present ( source )) then string = render_source ( source , offset , color ) // \":\" // & & to_string ( line ) // \":\" // & & to_string ( label % first ) if ( label % first /= label % last ) then string = string // \"-\" // to_string ( label % last ) end if end if string = string // nl // & & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset do it = first , last string = string // nl // & & render_line ( input ( token ( it )% first : token ( it )% last ), & & to_string ( it , offset ), color ) if ( it == line ) then string = string // nl // & & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset // & & render_label ( label , shift , color ) end if end do string = string // nl // & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset end function render_text_with_label pure function render_text_with_labels ( input , label , color , source ) result ( string ) character ( len =* ), intent ( in ) :: input type ( toml_label ), intent ( in ) :: label (:) type ( toml_terminal ), intent ( in ) :: color character ( len =* ), intent ( in ), optional :: source character ( len = :), allocatable :: string integer :: it , il , offset , first , last , line ( size ( label )), shift ( size ( label )) type ( line_token ), allocatable :: token (:) logical , allocatable :: display (:) allocate ( token ( 0 )) ! avoid compiler warning allocate ( character ( len = 0 ) :: string ) ! Allocate to avoid referencing an unallocated variable token = line_tokens ( input ) line (:) = [( count ( token % first <= label ( it )% first ), it = 1 , size ( label ))] shift (:) = token ( line )% first - 1 first = max ( 1 , minval ( line )) last = min ( size ( token ), maxval ( line )) offset = integer_width ( last ) it = 1 ! Without a primary we use the first label do il = 1 , size ( label ) if ( label ( il )% primary ) then it = il exit end if end do if ( present ( source )) then string = render_source ( source , offset , color ) // \":\" // & & to_string ( line ( it )) // \":\" // & & to_string ( label ( it )% first - shift ( it )) if ( label ( it )% first /= label ( it )% last ) then string = string // \"-\" // to_string ( label ( it )% last - shift ( it )) end if end if string = string // nl // & & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset allocate ( display ( first : last ), source = . false .) do il = 1 , size ( label ) ! display(max(first, line(il) - 1):min(last, line(il) + 1)) = .true. display ( line ( il )) = . true . end do do it = first , last if (. not . display ( it )) then if ( display ( it - 1 ) . and . count ( display ( it :)) > 0 ) then string = string // nl // & & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \":\" // color % reset end if cycle end if string = string // nl // & & render_line ( input ( token ( it )% first : token ( it )% last ), & & to_string ( it , offset ), color ) if ( any ( it == line )) then do il = 1 , size ( label ) if ( line ( il ) /= it ) cycle string = string // nl // & & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset // & & render_label ( label ( il ), shift ( il ), color ) end do end if end do string = string // nl // & repeat ( \" \" , offset + 1 ) // ( color % bold + color % blue ) // \"|\" // color % reset end function render_text_with_labels pure function render_label ( label , shift , color ) result ( string ) type ( toml_label ), intent ( in ) :: label integer , intent ( in ) :: shift type ( toml_terminal ), intent ( in ) :: color character ( len = :), allocatable :: string integer :: width character :: marker type ( ansi_code ) :: this_color marker = merge ( \"&#94;\" , \"-\" , label % primary ) width = label % last - label % first + 1 this_color = level_color ( label % level , color ) string = & & repeat ( \" \" , label % first - shift ) // this_color // repeat ( marker , width ) // color % reset if ( allocated ( label % text )) then string = string // & & \" \" // this_color // label % text // color % reset end if end function render_label pure function level_color ( level , color ) result ( this_color ) integer , intent ( in ) :: level type ( toml_terminal ), intent ( in ) :: color type ( ansi_code ) :: this_color select case ( level ) case ( toml_level % error ) this_color = color % bold + color % red case ( toml_level % warning ) this_color = color % bold + color % yellow case ( toml_level % help ) this_color = color % bold + color % cyan case ( toml_level % info ) this_color = color % bold + color % magenta case default this_color = color % bold + color % blue end select end function level_color pure function render_line ( input , line , color ) result ( string ) character ( len =* ), intent ( in ) :: input character ( len =* ), intent ( in ) :: line type ( toml_terminal ), intent ( in ) :: color character ( len = :), allocatable :: string string = & & line // \" \" // ( color % bold + color % blue ) // \"|\" // color % reset // \" \" // input end function render_line pure function integer_width ( input ) result ( width ) integer , intent ( in ) :: input integer :: width integer :: val val = input width = 0 do while ( val /= 0 ) val = val / 10 width = width + 1 end do end function integer_width !> Represent an integer as character sequence. pure function to_string ( val , width ) result ( string ) integer , intent ( in ) :: val integer , intent ( in ), optional :: width character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( val ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer :: n character ( len = 1 ), parameter :: numbers ( 0 : 9 ) = & [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" ] if ( val == 0 ) then string = numbers ( 0 ) return end if n = abs ( val ) buffer = \"\" pos = buffer_len + 1 do while ( n > 0 ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10 )) n = n / 10 end do if ( val < 0 ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if if ( present ( width )) then string = repeat ( \" \" , max ( width - ( buffer_len + 1 - pos ), 0 )) // buffer ( pos :) else string = buffer ( pos :) end if end function to_string end module tomlf_diagnostic","tags":"","url":"sourcefile/diagnostic.f90.html"},{"title":"array_list.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a basic storage structure as pointer list of pointers. !> !> This implementation does purposely not use pointer attributes in the !> datastructure to make it safer to work with. module tomlf_structure_array_list use tomlf_constants , only : tfc use tomlf_structure_list , only : toml_list_structure use tomlf_structure_node , only : toml_node , resize use tomlf_type_value , only : toml_value , toml_key implicit none private public :: toml_array_list , new_array_list !> Stores TOML values in a list of pointers type , extends ( toml_list_structure ) :: toml_array_list !> Current number of stored TOML values integer :: n = 0 !> List of TOML values type ( toml_node ), allocatable :: lst (:) contains !> Get number of TOML values in the structure procedure :: get_len !> Get TOML value at a given index procedure :: get !> Push back a TOML value to the structure procedure :: push_back !> Remove the first element from the structure procedure :: shift !> Remove the last element from the structure procedure :: pop !> Destroy the data structure procedure :: destroy end type toml_array_list !> Initial storage capacity of the datastructure integer , parameter :: initial_size = 16 contains !> Constructor for the storage data structure subroutine new_array_list ( self , n ) !> Instance of the structure type ( toml_array_list ), intent ( out ) :: self !> Initial storage capacity integer , intent ( in ), optional :: n self % n = 0 if ( present ( n )) then allocate ( self % lst ( min ( 1 , n ))) else allocate ( self % lst ( initial_size )) end if end subroutine new_array_list !> Get number of TOML values in the structure pure function get_len ( self ) result ( length ) !> Instance of the structure class ( toml_array_list ), intent ( in ), target :: self !> Current length of the ordered structure integer :: length length = self % n end function get_len !> Get TOML value at a given index subroutine get ( self , idx , ptr ) !> Instance of the structure class ( toml_array_list ), intent ( inout ), target :: self !> Position in the ordered structure integer , intent ( in ) :: idx !> Pointer to the stored value at given index class ( toml_value ), pointer , intent ( out ) :: ptr nullify ( ptr ) if ( idx > 0 . and . idx <= self % n ) then if ( allocated ( self % lst ( idx )% val )) then ptr => self % lst ( idx )% val end if end if end subroutine get !> Push back a TOML value to the structure subroutine push_back ( self , val ) !> Instance of the structure class ( toml_array_list ), intent ( inout ), target :: self !> TOML value to be stored class ( toml_value ), allocatable , intent ( inout ) :: val integer :: m if (. not . allocated ( self % lst )) then call resize ( self % lst , initial_size ) end if m = size ( self % lst ) if ( self % n >= m ) then call resize ( self % lst , m + m / 2 + 1 ) end if self % n = self % n + 1 call move_alloc ( val , self % lst ( self % n )% val ) end subroutine push_back !> Remove the first element from the data structure subroutine shift ( self , val ) !> Instance of the structure class ( toml_array_list ), intent ( inout ), target :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val integer :: i if ( self % n > 0 ) then call move_alloc ( self % lst ( 1 )% val , val ) do i = 2 , self % n call move_alloc ( self % lst ( i )% val , self % lst ( i - 1 )% val ) end do self % n = self % n - 1 end if end subroutine shift !> Remove the last element from the data structure subroutine pop ( self , val ) !> Instance of the structure class ( toml_array_list ), intent ( inout ), target :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val if ( self % n > 0 ) then call move_alloc ( self % lst ( self % n )% val , val ) self % n = self % n - 1 end if end subroutine pop !> Deconstructor for data structure subroutine destroy ( self ) !> Instance of the structure class ( toml_array_list ), intent ( inout ), target :: self integer :: i do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then call self % lst ( i )% val % destroy end if end do deallocate ( self % lst ) self % n = 0 end subroutine destroy end module tomlf_structure_array_list","tags":"","url":"sourcefile/array_list.f90.html"},{"title":"path.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Support for retrieving and setting values using a key path. module tomlf_build_path use tomlf_build_table , only : get_value , set_value use tomlf_constants , only : tfc , tfi , tfr , tf_i1 , tf_i2 , tf_i4 , tf_i8 , & & tf_sp , tf_dp use tomlf_datetime , only : toml_datetime use tomlf_error , only : toml_stat use tomlf_type , only : toml_table , toml_array , toml_keyval , toml_key implicit none private public :: toml_path , get_value , set_value !> Setter functions to manipulate TOML tables interface set_value module procedure :: set_path_value_float_sp module procedure :: set_path_value_float_dp module procedure :: set_path_value_integer_i1 module procedure :: set_path_value_integer_i2 module procedure :: set_path_value_integer_i4 module procedure :: set_path_value_integer_i8 module procedure :: set_path_value_bool module procedure :: set_path_value_datetime module procedure :: set_path_value_string end interface set_value !> Getter functions to manipulate TOML tables interface get_value module procedure :: get_path_table module procedure :: get_path_array module procedure :: get_path_keyval module procedure :: get_path_value_float_sp module procedure :: get_path_value_float_dp module procedure :: get_path_value_integer_i1 module procedure :: get_path_value_integer_i2 module procedure :: get_path_value_integer_i4 module procedure :: get_path_value_integer_i8 module procedure :: get_path_value_bool module procedure :: get_path_value_datetime module procedure :: get_path_value_string end interface get_value !> Wrapper for storing key paths type :: toml_path !> Path components type ( toml_key ), allocatable :: path (:) end type toml_path !> Convenience constructors for building key paths from strings instead of keys interface toml_path module procedure :: new_path2 module procedure :: new_path3 module procedure :: new_path4 end interface toml_path contains !> Create a new path with two components pure function new_path2 ( key1 , key2 ) result ( path ) !> First key to retrieve character ( * ), intent ( in ) :: key1 !> Second key to retrieve character ( * ), intent ( in ) :: key2 !> New path type ( toml_path ) :: path allocate ( path % path ( 2 )) path % path (:) = [ toml_key ( key1 ), toml_key ( key2 )] end function new_path2 !> Create a new path with three components pure function new_path3 ( key1 , key2 , key3 ) result ( path ) !> First key to retrieve character ( * , tfc ), intent ( in ) :: key1 !> Second key to retrieve character ( * , tfc ), intent ( in ) :: key2 !> Third key to retrieve character ( * , tfc ), intent ( in ) :: key3 !> New path type ( toml_path ) :: path allocate ( path % path ( 3 )) path % path (:) = [ toml_key ( key1 ), toml_key ( key2 ), toml_key ( key3 )] end function new_path3 !> Create a new path with three components pure function new_path4 ( key1 , key2 , key3 , key4 ) result ( path ) !> First key to retrieve character ( * , tfc ), intent ( in ) :: key1 !> Second key to retrieve character ( * , tfc ), intent ( in ) :: key2 !> Third key to retrieve character ( * , tfc ), intent ( in ) :: key3 !> Forth key to retrieve character ( * , tfc ), intent ( in ) :: key4 !> New path type ( toml_path ) :: path allocate ( path % path ( 4 )) path % path (:) = [ toml_key ( key1 ), toml_key ( key2 ), toml_key ( key3 ), toml_key ( key4 )] end function new_path4 subroutine get_path_table ( table , path , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ), target :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Pointer to child table type ( toml_table ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child logical :: is_requested is_requested = . true . if ( present ( requested )) is_requested = requested nullify ( ptr ) call walk_path ( table , path , child , is_requested , stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), ptr , is_requested , stat , origin ) else if (. not . is_requested . and . present ( stat )) stat = toml_stat % success end if end subroutine get_path_table subroutine get_path_array ( table , path , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Pointer to child array type ( toml_array ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child logical :: is_requested is_requested = . true . if ( present ( requested )) is_requested = requested nullify ( ptr ) call walk_path ( table , path , child , is_requested , stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), ptr , is_requested , stat , origin ) else if (. not . is_requested . and . present ( stat )) stat = toml_stat % success end if end subroutine get_path_array subroutine get_path_keyval ( table , path , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Pointer to child value type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child logical :: is_requested is_requested = . true . if ( present ( requested )) is_requested = requested nullify ( ptr ) call walk_path ( table , path , child , is_requested , stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), ptr , is_requested , stat , origin ) else if (. not . is_requested . and . present ( stat )) stat = toml_stat % success end if end subroutine get_path_keyval !> Retrieve TOML value as single precision float (might lose accuracy) subroutine get_path_value_float_sp ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Real value real ( tf_sp ), intent ( out ) :: val !> Default real value real ( tf_sp ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_float_sp !> Retrieve TOML value as double precision float subroutine get_path_value_float_dp ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Real value real ( tf_dp ), intent ( out ) :: val !> Default real value real ( tf_dp ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_float_dp !> Retrieve TOML value as one byte integer (might loose precision) subroutine get_path_value_integer_i1 ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Integer value integer ( tf_i1 ), intent ( out ) :: val !> Default integer value integer ( tf_i1 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_integer_i1 !> Retrieve TOML value as two byte integer (might loose precision) subroutine get_path_value_integer_i2 ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Integer value integer ( tf_i2 ), intent ( out ) :: val !> Default integer value integer ( tf_i2 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_integer_i2 !> Retrieve TOML value as four byte integer (might loose precision) subroutine get_path_value_integer_i4 ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Integer value integer ( tf_i4 ), intent ( out ) :: val !> Default integer value integer ( tf_i4 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_integer_i4 !> Retrieve TOML value as eight byte integer subroutine get_path_value_integer_i8 ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Integer value integer ( tf_i8 ), intent ( out ) :: val !> Default integer value integer ( tf_i8 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_integer_i8 !> Retrieve TOML value as logical subroutine get_path_value_bool ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Boolean value logical , intent ( out ) :: val !> Default boolean value logical , intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_bool !> Retrieve TOML value as datetime subroutine get_path_value_datetime ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Datetime value type ( toml_datetime ), intent ( out ) :: val !> Default datetime value type ( toml_datetime ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_datetime !> Retrieve TOML value as deferred-length character subroutine get_path_value_string ( table , path , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> String value character ( kind = tfc , len = :), allocatable , intent ( out ) :: val !> Default string value character ( kind = tfc , len =* ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , present ( default ), stat , origin ) if ( associated ( child )) then call get_value ( child , path % path ( size ( path % path )), val , default , stat , origin ) end if end subroutine get_path_value_string !> Set TOML value to single precision float subroutine set_path_value_float_sp ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Real value real ( tf_sp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_float_sp !> Set TOML value to double precision float subroutine set_path_value_float_dp ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Real value real ( tf_dp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_float_dp !> Set TOML value to one byte integer subroutine set_path_value_integer_i1 ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Integer value integer ( tf_i1 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_integer_i1 !> Set TOML value to two byte integer subroutine set_path_value_integer_i2 ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Integer value integer ( tf_i2 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_integer_i2 !> Set TOML value to four byte integer subroutine set_path_value_integer_i4 ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Integer value integer ( tf_i4 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_integer_i4 !> Set TOML value to eight byte integer subroutine set_path_value_integer_i8 ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Integer value integer ( tf_i8 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_integer_i8 !> Set TOML value to logical subroutine set_path_value_bool ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Boolean value logical , intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_bool !> Set TOML value to datetime subroutine set_path_value_datetime ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Datetime value type ( toml_datetime ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_datetime !> Set TOML value to deferred-length character subroutine set_path_value_string ( table , path , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> String value character ( kind = tfc , len =* ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_table ), pointer :: child call walk_path ( table , path , child , . true ., stat , origin ) if ( associated ( child )) then call set_value ( child , path % path ( size ( path % path )), val , stat , origin ) end if end subroutine set_path_value_string subroutine walk_path ( table , path , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ), target :: table !> Path in this TOML table type ( toml_path ), intent ( in ) :: path !> Pointer to child table type ( toml_table ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it type ( toml_table ), pointer :: current , next nullify ( ptr ) if (. not . allocated ( path % path )) then if ( present ( stat )) stat = toml_stat % fatal if ( present ( origin )) origin = table % origin return end if current => table do it = 1 , size ( path % path ) - 1 call get_value ( current , path % path ( it )% key , next , requested , stat , origin ) if (. not . associated ( next )) then if ( present ( stat )) stat = toml_stat % fatal if ( present ( origin )) origin = current % origin return end if current => next end do ptr => current end subroutine walk_path end module tomlf_build_path","tags":"","url":"sourcefile/path.f90.html"},{"title":"table.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of the TOML table data type. !> !> Every TOML document contains at least one (root) table which holds key-value !> pairs, arrays and other tables. module tomlf_type_table use tomlf_constants , only : tfc use tomlf_error , only : toml_stat use tomlf_type_value , only : toml_value , toml_visitor , toml_key use tomlf_structure , only : toml_map_structure , new_map_structure implicit none private public :: toml_table , new_table , new , initialized !> TOML table type , extends ( toml_value ) :: toml_table !> Table was implictly created logical :: implicit = . false . !> Is an inline table and is therefore non-extendable logical :: inline = . false . !> Storage unit for TOML values of this table class ( toml_map_structure ), allocatable , private :: map contains !> Get the TOML value associated with the respective key procedure :: get !> Get list of all keys in this table procedure :: get_keys !> Check if key is already present in this table instance procedure :: has_key !> Append value to table (checks automatically for key) procedure :: push_back !> Remove TOML value at a given key and return it procedure :: pop !> Delete TOML value at a given key procedure :: delete !> Release allocation hold by TOML table procedure :: destroy end type toml_table !> Create standard constructor interface toml_table module procedure :: new_table_func end interface toml_table !> Overloaded constructor for TOML values interface new module procedure :: new_table end interface !> Check whether data structure is initialized properly interface initialized module procedure :: table_initialized end interface initialized contains !> Constructor to create a new TOML table and allocate the internal storage subroutine new_table ( self ) !> Instance of the TOML table type ( toml_table ), intent ( out ) :: self call new_map_structure ( self % map ) end subroutine new_table !> Default constructor for TOML table type function new_table_func () result ( self ) !> Instance of the TOML table type ( toml_table ) :: self call new_table ( self ) end function new_table_func !> Check whether data structure is initialized properly pure function table_initialized ( self ) result ( okay ) !> Instance of the TOML table type ( toml_table ), intent ( in ) :: self !> Data structure is initialized logical :: okay okay = allocated ( self % map ) end function table_initialized !> Get the TOML value associated with the respective key subroutine get ( self , key , ptr ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the TOML value class ( toml_value ), pointer , intent ( out ) :: ptr call self % map % get ( key , ptr ) end subroutine get !> Get list of all keys in this table subroutine get_keys ( self , list ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> List of all keys type ( toml_key ), allocatable , intent ( out ) :: list (:) call self % map % get_keys ( list ) end subroutine get_keys !> Check if a key is present in the table function has_key ( self , key ) result ( found ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> TOML value is present in table logical :: found class ( toml_value ), pointer :: ptr call self % map % get ( key , ptr ) found = associated ( ptr ) end function has_key !> Push back a TOML value to the table subroutine push_back ( self , val , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> TOML value to append to table class ( toml_value ), allocatable , intent ( inout ) :: val !> Status of operation integer , intent ( out ) :: stat class ( toml_value ), pointer :: ptr if (. not . allocated ( val )) then stat = merge ( self % origin , toml_stat % fatal , self % origin > 0 ) return end if if (. not . allocated ( val % key )) then stat = merge ( val % origin , toml_stat % fatal , val % origin > 0 ) return end if call self % get ( val % key , ptr ) if ( associated ( ptr )) then stat = merge ( ptr % origin , toml_stat % duplicate_key , ptr % origin > 0 ) return end if call self % map % push_back ( val ) stat = toml_stat % success end subroutine push_back !> Remove TOML value at a given key and return it subroutine pop ( self , key , val ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Removed TOML value to return class ( toml_value ), allocatable , intent ( out ) :: val call self % map % pop ( key , val ) end subroutine pop !> Delete TOML value at a given key subroutine delete ( self , key ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key call self % map % delete ( key ) end subroutine delete !> Deconstructor to cleanup allocations (optional) subroutine destroy ( self ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: self if ( allocated ( self % key )) then deallocate ( self % key ) end if if ( allocated ( self % map )) then call self % map % destroy deallocate ( self % map ) end if end subroutine destroy end module tomlf_type_table","tags":"","url":"sourcefile/table.f90.html"},{"title":"terminal.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a terminal to provide ANSI escape sequences !> !> ANSI escape codes for producing terminal colors. The `ansi_code` derived !> type is used to store ANSI escape codes and can be combined with other !> codes or applied to strings by concatenation. The default or uninitialized !> `ansi_code` is a stub and does not produce escape sequences when applied !> to a string. !> !> Available colors are !> !> color          | foreground            | background !> -------------- | --------------------- | ------------------------ !> black          | `black` (30)          | `bg_black` (40) !> red            | `red` (31)            | `bg_red` (41) !> green          | `green` (32)          | `bg_green` (42) !> yellow         | `yellow` (33)         | `bg_yellow` (43) !> blue           | `blue` (34)           | `bg_blue` (44) !> magenta        | `magenta` (35)        | `bg_magenta` (45) !> cyan           | `cyan` (36)           | `bg_cyan` (46) !> white          | `white` (37)          | `bg_white` (47) !> gray           | `gray` (90)           | `bg_gray` (100) !> bright red     | `bright_red` (91)     | `bg_bright_red` (101) !> bright green   | `bright_green` (92)   | `bg_bright_green` (102) !> bright yellow  | `bright_yellow` (93)  | `bg_bright_yellow` (103) !> bright blue    | `bright_blue` (94)    | `bg_bright_blue` (104) !> bright magenta | `bright_magenta` (95) | `bg_bright_magenta` (105) !> bright cyan    | `bright_cyan` (96)    | `bg_bright_cyan` (106) !> bright white   | `bright_white` (97)   | `bg_bright_white` (107) !> !> Available styles are !> !> style       | !> ------------| --------------- !> reset       | `reset` (0) !> bold        | `bold` (1) !> dim         | `dim` (2) !> italic      | `italic` (3) !> underline   | `underline` (4) !> blink       | `blink` (5) !> blink rapid | `blink_rapid` (6) !> reverse     | `reverse` (7) !> hidden      | `hidden` (8) !> crossed     | `crossed` (9) module tomlf_terminal use tomlf_utils , only : to_string implicit none private public :: toml_terminal public :: ansi_code , escape , operator ( + ), operator ( // ) !> Char length for integers integer , parameter :: i1 = selected_int_kind ( 2 ) !> Container for terminal escape code type :: ansi_code private !> Style descriptor integer ( i1 ) :: style = - 1_i1 !> Background color descriptor integer ( i1 ) :: bg = - 1_i1 !> Foreground color descriptor integer ( i1 ) :: fg = - 1_i1 end type interface operator ( + ) module procedure :: add end interface operator ( + ) interface operator ( // ) module procedure :: concat_left module procedure :: concat_right end interface operator ( // ) interface escape module procedure :: escape end interface escape type ( ansi_code ), public , parameter :: & reset = ansi_code ( style = 0_i1 ), & bold = ansi_code ( style = 1_i1 ), & dim = ansi_code ( style = 2_i1 ), & italic = ansi_code ( style = 3_i1 ), & underline = ansi_code ( style = 4_i1 ), & blink = ansi_code ( style = 5_i1 ), & blink_rapid = ansi_code ( style = 6_i1 ), & reverse = ansi_code ( style = 7_i1 ), & hidden = ansi_code ( style = 8_i1 ), & crossed = ansi_code ( style = 9_i1 ) type ( ansi_code ), public , parameter :: & black = ansi_code ( fg = 30_i1 ), & red = ansi_code ( fg = 31_i1 ), & green = ansi_code ( fg = 32_i1 ), & yellow = ansi_code ( fg = 33_i1 ), & blue = ansi_code ( fg = 34_i1 ), & magenta = ansi_code ( fg = 35_i1 ), & cyan = ansi_code ( fg = 36_i1 ), & white = ansi_code ( fg = 37_i1 ), & gray = ansi_code ( fg = 90_i1 ), & bright_red = ansi_code ( fg = 91_i1 ), & bright_green = ansi_code ( fg = 92_i1 ), & bright_yellow = ansi_code ( fg = 93_i1 ), & bright_blue = ansi_code ( fg = 94_i1 ), & bright_magenta = ansi_code ( fg = 95_i1 ), & bright_cyan = ansi_code ( fg = 96_i1 ), & bright_white = ansi_code ( fg = 97_i1 ) type ( ansi_code ), public , parameter :: & bg_black = ansi_code ( bg = 40_i1 ), & bg_red = ansi_code ( bg = 41_i1 ), & bg_green = ansi_code ( bg = 42_i1 ), & bg_yellow = ansi_code ( bg = 43_i1 ), & bg_blue = ansi_code ( bg = 44_i1 ), & bg_magenta = ansi_code ( bg = 45_i1 ), & bg_cyan = ansi_code ( bg = 46_i1 ), & bg_white = ansi_code ( bg = 47_i1 ), & bg_gray = ansi_code ( bg = 100_i1 ), & bg_bright_red = ansi_code ( bg = 101_i1 ), & bg_bright_green = ansi_code ( bg = 102_i1 ), & bg_bright_yellow = ansi_code ( bg = 103_i1 ), & bg_bright_blue = ansi_code ( bg = 104_i1 ), & bg_bright_magenta = ansi_code ( bg = 105_i1 ), & bg_bright_cyan = ansi_code ( bg = 106_i1 ), & bg_bright_white = ansi_code ( bg = 107_i1 ) !> Terminal wrapper to handle color escape sequences, must be initialized with !> color support to provide colorful output. Default and uninitialized instances !> will remain usable but provide only stubs and do not produce colorful output. !> This behavior is useful for creating applications which can toggle color support. type :: toml_terminal type ( ansi_code ) :: & reset = ansi_code (), & bold = ansi_code (), & dim = ansi_code (), & italic = ansi_code (), & underline = ansi_code (), & blink = ansi_code (), & blink_rapid = ansi_code (), & reverse = ansi_code (), & hidden = ansi_code (), & crossed = ansi_code () type ( ansi_code ) :: & black = ansi_code (), & red = ansi_code (), & green = ansi_code (), & yellow = ansi_code (), & blue = ansi_code (), & magenta = ansi_code (), & cyan = ansi_code (), & white = ansi_code (), & gray = ansi_code (), & bright_red = ansi_code (), & bright_green = ansi_code (), & bright_yellow = ansi_code (), & bright_blue = ansi_code (), & bright_magenta = ansi_code (), & bright_cyan = ansi_code (), & bright_white = ansi_code () type ( ansi_code ) :: & bg_black = ansi_code (), & bg_red = ansi_code (), & bg_green = ansi_code (), & bg_yellow = ansi_code (), & bg_blue = ansi_code (), & bg_magenta = ansi_code (), & bg_cyan = ansi_code (), & bg_white = ansi_code (), & bg_gray = ansi_code (), & bg_bright_red = ansi_code (), & bg_bright_green = ansi_code (), & bg_bright_yellow = ansi_code (), & bg_bright_blue = ansi_code (), & bg_bright_magenta = ansi_code (), & bg_bright_cyan = ansi_code (), & bg_bright_white = ansi_code () end type toml_terminal !> Constructor to create new terminal interface toml_terminal module procedure :: new_terminal end interface toml_terminal contains !> Create new terminal pure function new_terminal ( use_color ) result ( new ) !> Enable color support in terminal logical , intent ( in ) :: use_color !> New terminal instance type ( toml_terminal ) :: new if ( use_color ) then new % reset = reset new % bold = bold new % dim = dim new % italic = italic new % underline = underline new % blink = blink new % blink_rapid = blink_rapid new % reverse = reverse new % hidden = hidden new % crossed = crossed new % black = black new % red = red new % green = green new % yellow = yellow new % blue = blue new % magenta = magenta new % cyan = cyan new % white = white new % gray = gray new % bright_red = bright_red new % bright_green = bright_green new % bright_yellow = bright_yellow new % bright_blue = bright_blue new % bright_magenta = bright_magenta new % bright_cyan = bright_cyan new % bright_white = bright_white new % bg_black = bg_black new % bg_red = bg_red new % bg_green = bg_green new % bg_yellow = bg_yellow new % bg_blue = bg_blue new % bg_magenta = bg_magenta new % bg_cyan = bg_cyan new % bg_white = bg_white new % bg_gray = bg_gray new % bg_bright_red = bg_bright_red new % bg_bright_green = bg_bright_green new % bg_bright_yellow = bg_bright_yellow new % bg_bright_blue = bg_bright_blue new % bg_bright_magenta = bg_bright_magenta new % bg_bright_cyan = bg_bright_cyan new % bg_bright_white = bg_bright_white end if end function new_terminal !> Add two escape sequences, attributes in the right value override the left value ones. pure function add ( lval , rval ) result ( code ) !> First escape code type ( ansi_code ), intent ( in ) :: lval !> Second escape code type ( ansi_code ), intent ( in ) :: rval !> Combined escape code type ( ansi_code ) :: code code % style = merge ( rval % style , lval % style , rval % style >= 0 ) code % fg = merge ( rval % fg , lval % fg , rval % fg >= 0 ) code % bg = merge ( rval % bg , lval % bg , rval % bg >= 0 ) end function add !> Concatenate an escape code with a string and turn it into an actual escape sequence pure function concat_left ( lval , code ) result ( str ) !> String to add the escape code to character ( len =* ), intent ( in ) :: lval !> Escape sequence type ( ansi_code ), intent ( in ) :: code !> Concatenated string character ( len = :), allocatable :: str str = lval // escape ( code ) end function concat_left !> Concatenate an escape code with a string and turn it into an actual escape sequence pure function concat_right ( code , rval ) result ( str ) !> String to add the escape code to character ( len =* ), intent ( in ) :: rval !> Escape sequence type ( ansi_code ), intent ( in ) :: code !> Concatenated string character ( len = :), allocatable :: str str = escape ( code ) // rval end function concat_right !> Transform a color code into an actual ANSI escape sequence pure function escape ( code ) result ( str ) !> Color code to be used type ( ansi_code ), intent ( in ) :: code !> ANSI escape sequence representing the color code character ( len = :), allocatable :: str if ( anycolor ( code )) then str = achar ( 27 ) // \"[0\" ! Always reset the style if ( code % style > 0 ) str = str // \";\" // to_string ( code % style ) if ( code % fg >= 0 ) str = str // \";\" // to_string ( code % fg ) if ( code % bg >= 0 ) str = str // \";\" // to_string ( code % bg ) str = str // \"m\" else str = \"\" end if end function escape !> Check whether the code describes any color or is just a stub pure function anycolor ( code ) !> Escape sequence type ( ansi_code ), intent ( in ) :: code !> Any color / style is active logical :: anycolor anycolor = code % fg >= 0 . or . code % bg >= 0 . or . code % style >= 0 end function anycolor end module tomlf_terminal","tags":"","url":"sourcefile/terminal.f90.html"},{"title":"version.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Version information on TOML-Fortran module tomlf_version implicit none private public :: get_tomlf_version public :: tomlf_version_string , tomlf_version_compact !> String representation of the TOML-Fortran version character ( len =* ), parameter :: tomlf_version_string = \"0.4.3\" !> Major version number of the above TOML-Fortran version integer , parameter :: tomlf_major = 0 !> Minor version number of the above TOML-Fortran version integer , parameter :: tomlf_minor = 4 !> Patch version number of the above TOML-Fortran version integer , parameter :: tomlf_patch = 3 !> Compact numeric representation of the TOML-Fortran version integer , parameter :: tomlf_version_compact = & & tomlf_major * 10000 + tomlf_minor * 100 + tomlf_patch contains !> Getter function to retrieve TOML-Fortran version subroutine get_tomlf_version ( major , minor , patch , string ) !> Major version number of the TOML-Fortran version integer , intent ( out ), optional :: major !> Minor version number of the TOML-Fortran version integer , intent ( out ), optional :: minor !> Patch version number of the TOML-Fortran version integer , intent ( out ), optional :: patch !> String representation of the TOML-Fortran version character ( len = :), allocatable , intent ( out ), optional :: string if ( present ( major )) then major = tomlf_major end if if ( present ( minor )) then minor = tomlf_minor end if if ( present ( patch )) then patch = tomlf_patch end if if ( present ( string )) then string = tomlf_version_string end if end subroutine get_tomlf_version end module tomlf_version","tags":"","url":"sourcefile/version.f90.html"},{"title":"type.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Collection of the central datatypes to define TOML data structures !> !> All TOML data types should inherit from an abstract value allowing to generate !> a generic interface to deal with all more specialized TOML data types, while !> the abstract value is interesting for developing algorithms in TOML-Fortran, !> the user of TOML-Fortran will usually only care about TOML tables and possibly !> arrays. !> !> The TOML types defined here should implement the TOML data structures (mostly) !> without taking the actual implementation of the data structures into account. !> This is done by providing a bare minimum interface using type bound procedures !> to minimize the interdependencies between the datatypes. !> !> To make the data types extendable a visitor pattern allows access to the TOML !> data types and can be used to implement further algorithms. module tomlf_type use tomlf_constants , only : tfc use tomlf_error , only : toml_stat use tomlf_type_array , only : toml_array , new_array , new , initialized , len use tomlf_type_keyval , only : toml_keyval , new_keyval , new use tomlf_type_table , only : toml_table , new_table , new , initialized use tomlf_type_value , only : toml_value , toml_visitor , toml_key implicit none private public :: toml_value , toml_visitor , toml_table , toml_array , toml_keyval public :: toml_key public :: new , new_table , new_array , new_keyval , initialized , len public :: add_table , add_array , add_keyval public :: is_array_of_tables public :: cast_to_table , cast_to_array , cast_to_keyval !> Interface to build new tables interface add_table module procedure :: add_table_to_table module procedure :: add_table_to_table_key module procedure :: add_table_to_array end interface add_table !> Interface to build new arrays interface add_array module procedure :: add_array_to_table module procedure :: add_array_to_table_key module procedure :: add_array_to_array end interface add_array !> Interface to build new key-value pairs interface add_keyval module procedure :: add_keyval_to_table module procedure :: add_keyval_to_table_key module procedure :: add_keyval_to_array end interface add_keyval contains !> Create a new TOML table inside an existing table subroutine add_table_to_table ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the newly created table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_table_ ( val ) val % key = key call table % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call table % get ( key , tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_table ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_table_to_table !> Create a new TOML table inside an existing table subroutine add_table_to_table_key ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new table type ( toml_key ), intent ( in ) :: key !> Pointer to the newly created table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat call add_table ( table , key % key , ptr , stat ) if ( associated ( ptr )) ptr % origin = key % origin end subroutine add_table_to_table_key !> Create a new TOML array inside an existing table subroutine add_array_to_table ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new array character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the newly created array type ( toml_array ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_array_ ( val ) val % key = key call table % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call table % get ( key , tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_array ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_array_to_table !> Create a new TOML array inside an existing table subroutine add_array_to_table_key ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new array type ( toml_key ), intent ( in ) :: key !> Pointer to the newly created array type ( toml_array ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat call add_array ( table , key % key , ptr , stat ) if ( associated ( ptr )) ptr % origin = key % origin end subroutine add_array_to_table_key !> Create a new key-value pair inside an existing table subroutine add_keyval_to_table ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new key-value pair character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the newly created key-value pair type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_keyval_ ( val ) val % key = key call table % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call table % get ( key , tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_keyval ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_keyval_to_table !> Create a new key-value pair inside an existing table subroutine add_keyval_to_table_key ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new key-value pair type ( toml_key ), intent ( in ) :: key !> Pointer to the newly created key-value pair type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat call add_keyval ( table , key % key , ptr , stat ) if ( associated ( ptr )) ptr % origin = key % origin end subroutine add_keyval_to_table_key !> Create a new TOML table inside an existing array subroutine add_table_to_array ( array , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Pointer to the newly created table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_table_ ( val ) call array % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call array % get ( len ( array ), tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_table ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_table_to_array !> Create a new TOML array inside an existing array subroutine add_array_to_array ( array , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Pointer to the newly created array type ( toml_array ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) allocate ( toml_array :: val ) call new_array_ ( val ) call array % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call array % get ( len ( array ), tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_array ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_array_to_array !> Create a new key-value pair inside an existing array subroutine add_keyval_to_array ( array , ptr , stat ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Pointer to the newly created key-value pair type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), allocatable :: val class ( toml_value ), pointer :: tmp integer :: istat nullify ( ptr ) call new_keyval_ ( val ) call array % push_back ( val , istat ) if ( allocated ( val )) then call val % destroy if ( present ( stat )) stat = toml_stat % fatal return end if if ( istat == toml_stat % success ) then call array % get ( len ( array ), tmp ) if (. not . associated ( tmp )) then if ( present ( stat )) stat = toml_stat % fatal return end if select type ( tmp ) type is ( toml_keyval ) ptr => tmp class default istat = toml_stat % fatal end select end if if ( present ( stat )) stat = istat end subroutine add_keyval_to_array !> Wrapped constructor to create a new TOML table on an abstract TOML value subroutine new_table_ ( self ) !> Newly created TOML table class ( toml_value ), allocatable , intent ( out ) :: self type ( toml_table ), allocatable :: val allocate ( val ) call new_table ( val ) call move_alloc ( val , self ) end subroutine new_table_ !> Wrapped constructor to create a new TOML array on an abstract TOML value subroutine new_array_ ( self ) !> Newly created TOML array class ( toml_value ), allocatable , intent ( out ) :: self type ( toml_array ), allocatable :: val allocate ( val ) call new_array ( val ) call move_alloc ( val , self ) end subroutine new_array_ !> Wrapped constructor to create a new TOML array on an abstract TOML value subroutine new_keyval_ ( self ) !> Newly created key-value pair class ( toml_value ), allocatable , intent ( out ) :: self type ( toml_keyval ), allocatable :: val allocate ( val ) call new_keyval ( val ) call move_alloc ( val , self ) end subroutine new_keyval_ !> Determine if array contains only tables function is_array_of_tables ( array ) result ( only_tables ) !> TOML value to visit class ( toml_array ), intent ( inout ) :: array !> Array contains only tables logical :: only_tables class ( toml_value ), pointer :: ptr integer :: i , n n = len ( array ) only_tables = n > 0 do i = 1 , n call array % get ( i , ptr ) select type ( ptr ) type is ( toml_table ) cycle class default only_tables = . false . exit end select end do end function is_array_of_tables !> Cast an abstract TOML value to a TOML array function cast_to_array ( ptr ) result ( array ) !> TOML value to be casted class ( toml_value ), intent ( in ), target :: ptr !> TOML array view, nullified if the value is not an array type ( toml_array ), pointer :: array nullify ( array ) select type ( ptr ) type is ( toml_array ) array => ptr end select end function cast_to_array !> Cast an abstract TOML value to a TOML table function cast_to_table ( ptr ) result ( table ) !> TOML value to be casted class ( toml_value ), intent ( in ), target :: ptr !> TOML table view, nullified if the value is not a table type ( toml_table ), pointer :: table nullify ( table ) select type ( ptr ) type is ( toml_table ) table => ptr end select end function cast_to_table !> Cast an abstract TOML value to a TOML key-value pair function cast_to_keyval ( ptr ) result ( kval ) !> TOML value to be casted class ( toml_value ), intent ( in ), target :: ptr !> TOML key-value view, nullified if the value is not a table type ( toml_keyval ), pointer :: kval nullify ( kval ) select type ( ptr ) type is ( toml_keyval ) kval => ptr end select end function cast_to_keyval end module tomlf_type","tags":"","url":"sourcefile/type.f90.html"},{"title":"ordered_map.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a basic storage structure as pointer list of pointers. !> !> This implementation does purposely not use pointer attributes in the !> datastructure to make it safer to work with. module tomlf_structure_ordered_map use tomlf_constants , only : tfc use tomlf_structure_map , only : toml_map_structure use tomlf_structure_node , only : toml_node , resize use tomlf_type_value , only : toml_value , toml_key implicit none private public :: toml_ordered_map , new_ordered_map !> Stores TOML values in a list of pointers type , extends ( toml_map_structure ) :: toml_ordered_map !> Current number of stored TOML values integer :: n = 0 !> List of TOML values type ( toml_node ), allocatable :: lst (:) contains !> Get TOML value at a given key procedure :: get !> Push back a TOML value to the structure procedure :: push_back !> Remove TOML value at a given key and return it procedure :: pop !> Get list of all keys in the structure procedure :: get_keys !> Delete TOML value at a given key procedure :: delete !> Destroy the data structure procedure :: destroy end type toml_ordered_map !> Initial storage capacity of the datastructure integer , parameter :: initial_size = 16 contains !> Constructor for the storage data structure subroutine new_ordered_map ( self , n ) !> Instance of the structure type ( toml_ordered_map ), intent ( out ) :: self !> Initial storage capacity integer , intent ( in ), optional :: n self % n = 0 if ( present ( n )) then allocate ( self % lst ( min ( 1 , n ))) else allocate ( self % lst ( initial_size )) end if end subroutine new_ordered_map !> Get TOML value at a given key subroutine get ( self , key , ptr ) !> Instance of the structure class ( toml_ordered_map ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to the stored value at given key class ( toml_value ), pointer , intent ( out ) :: ptr integer :: i nullify ( ptr ) do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then if ( self % lst ( i )% val % match_key ( key )) then ptr => self % lst ( i )% val exit end if end if end do end subroutine get !> Push back a TOML value to the structure subroutine push_back ( self , val ) !> Instance of the structure class ( toml_ordered_map ), intent ( inout ), target :: self !> TOML value to be stored class ( toml_value ), allocatable , intent ( inout ) :: val integer :: m if (. not . allocated ( self % lst )) then call resize ( self % lst , initial_size ) end if m = size ( self % lst ) if ( self % n >= m ) then call resize ( self % lst , m + m / 2 + 1 ) end if self % n = self % n + 1 call move_alloc ( val , self % lst ( self % n )% val ) end subroutine push_back !> Get list of all keys in the structure subroutine get_keys ( self , list ) !> Instance of the structure class ( toml_ordered_map ), intent ( inout ), target :: self !> List of all keys type ( toml_key ), allocatable , intent ( out ) :: list (:) integer :: i allocate ( list ( self % n )) do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then if ( allocated ( self % lst ( i )% val % key )) then list ( i )% key = self % lst ( i )% val % key list ( i )% origin = self % lst ( i )% val % origin end if end if end do end subroutine get_keys !> Remove TOML value at a given key and return it subroutine pop ( self , key , val ) !> Instance of the structure class ( toml_ordered_map ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key !> Removed TOML value class ( toml_value ), allocatable , intent ( out ) :: val integer :: idx , i idx = 0 do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then if ( self % lst ( i )% val % match_key ( key )) then idx = i exit end if end if end do if ( idx > 0 ) then call move_alloc ( self % lst ( idx )% val , val ) do i = idx + 1 , self % n call move_alloc ( self % lst ( i )% val , self % lst ( i - 1 )% val ) end do self % n = self % n - 1 end if end subroutine pop !> Delete TOML value at a given key subroutine delete ( self , key ) !> Instance of the structure class ( toml_ordered_map ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key class ( toml_value ), allocatable :: val call self % pop ( key , val ) if ( allocated ( val )) then call val % destroy () end if end subroutine delete !> Deconstructor for data structure subroutine destroy ( self ) !> Instance of the structure class ( toml_ordered_map ), intent ( inout ), target :: self integer :: i do i = 1 , self % n if ( allocated ( self % lst ( i )% val )) then call self % lst ( i )% val % destroy end if end do deallocate ( self % lst ) self % n = 0 end subroutine destroy end module tomlf_structure_ordered_map","tags":"","url":"sourcefile/ordered_map.f90.html"},{"title":"io.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Utilities for handling input and output operations module tomlf_utils_io use tomlf_constants , only : tfc implicit none private public :: read_whole_file , read_whole_line contains !> Read a whole file into an array of characters subroutine read_whole_file ( filename , string , stat ) !> File to read character ( * , tfc ), intent ( in ) :: filename !> Array of characters representing the file character (:, tfc ), allocatable , intent ( out ) :: string !> Error status integer , intent ( out ) :: stat integer :: io , length open ( file = filename , & & status = \"old\" , & & access = \"stream\" , & & position = \"append\" , & & newunit = io , & & iostat = stat ) if ( stat == 0 ) then inquire ( unit = io , pos = length ) allocate ( character ( length - 1 , tfc ) :: string , stat = stat ) end if if ( stat == 0 ) then read ( io , pos = 1 , iostat = stat ) string (: length - 1 ) end if if ( stat == 0 ) then close ( io ) end if end subroutine read_whole_file !> Read a whole line from a formatted unit into a deferred length character variable subroutine read_whole_line ( io , string , stat ) !> Formatted IO unit integer , intent ( in ) :: io !> Line to read character (:, tfc ), allocatable , intent ( out ) :: string !> Status of operation integer , intent ( out ) :: stat integer , parameter :: bufsize = 4096 character ( bufsize , tfc ) :: buffer , msg integer :: chunk logical :: opened if ( io /= - 1 ) then inquire ( unit = io , opened = opened ) else opened = . false . end if if ( opened ) then open ( unit = io , pad = \"yes\" , iostat = stat ) else stat = 1 msg = \"Unit is not connected\" end if string = \"\" do while ( stat == 0 ) read ( io , '(a)' , advance = 'no' , iostat = stat , size = chunk ) buffer if ( stat > 0 ) exit string = string // buffer (: chunk ) end do if ( is_iostat_eor ( stat )) stat = 0 end subroutine read_whole_line end module tomlf_utils_io","tags":"","url":"sourcefile/io.f90.html"},{"title":"array.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Functions to build TOML arrays. !> !> This build module defines a high level interface to work with TOML arrays !> and construct them in a convenient way. !> !> The access to the array elements happens by position in the array, the indexing !> is one based, following the language convention of Fortran. All functions !> will only allow access of elements within the bounds of the array, specifying !> indices out-of-bounds should be save, as it only sets the status of operation. !> The getter functions allow access to other tables and arrays as well as !> convenient wrappers to retrieve value data !> !> The setter functions are somewhat weaker compared to the setter functions !> available for TOML tables. To limit the potential havoc this routines can !> cause they can only access the array within its bounds. Setting a value to !> another value will overwrite it, while setting a value to a table or an array !> will fail, for safety reasons. !> !> To (re)build an array appending to it is the best choice, tables and arrays !> should always be create by using the corresponding `add_table` and `add_array` !> function. While this can become cumbersome for values, the setter routines !> allow out-of-bound access to for the next element in an array and will indeed !> just append a new value to it. module tomlf_build_array use tomlf_build_keyval , only : get_value , set_value use tomlf_constants , only : tfc , tfi , tfr , tf_i1 , tf_i2 , tf_i4 , tf_i8 , & & tf_sp , tf_dp use tomlf_datetime , only : toml_datetime use tomlf_error , only : toml_stat use tomlf_type , only : toml_value , toml_table , toml_array , toml_keyval , & & new_table , new_array , new_keyval , add_table , add_array , add_keyval , & & cast_to_table , cast_to_array , cast_to_keyval , initialized , len implicit none private public :: get_value , set_value !> Setter functions to manipulate TOML arrays interface set_value module procedure :: set_elem_value_string module procedure :: set_elem_value_float_sp module procedure :: set_elem_value_float_dp module procedure :: set_elem_value_int_i1 module procedure :: set_elem_value_int_i2 module procedure :: set_elem_value_int_i4 module procedure :: set_elem_value_int_i8 module procedure :: set_elem_value_bool module procedure :: set_elem_value_datetime module procedure :: set_array_value_float_sp module procedure :: set_array_value_float_dp module procedure :: set_array_value_int_i1 module procedure :: set_array_value_int_i2 module procedure :: set_array_value_int_i4 module procedure :: set_array_value_int_i8 module procedure :: set_array_value_bool module procedure :: set_array_value_datetime end interface set_value !> Getter functions to manipulate TOML arrays interface get_value module procedure :: get_elem_table module procedure :: get_elem_array module procedure :: get_elem_keyval module procedure :: get_elem_value_string module procedure :: get_elem_value_float_sp module procedure :: get_elem_value_float_dp module procedure :: get_elem_value_int_i1 module procedure :: get_elem_value_int_i2 module procedure :: get_elem_value_int_i4 module procedure :: get_elem_value_int_i8 module procedure :: get_elem_value_bool module procedure :: get_elem_value_datetime module procedure :: get_array_value_float_sp module procedure :: get_array_value_float_dp module procedure :: get_array_value_int_i1 module procedure :: get_array_value_int_i2 module procedure :: get_array_value_int_i4 module procedure :: get_array_value_int_i8 module procedure :: get_array_value_bool module procedure :: get_array_value_datetime end interface get_value contains subroutine get_elem_table ( array , pos , ptr , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Pointer to child table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin class ( toml_value ), pointer :: tmp if (. not . initialized ( array )) call new_array ( array ) nullify ( ptr ) call array % get ( pos , tmp ) if ( associated ( tmp )) then ptr => cast_to_table ( tmp ) if ( present ( stat )) then if ( associated ( ptr )) then stat = toml_stat % success else stat = toml_stat % type_mismatch end if end if if ( present ( origin )) origin = tmp % origin else if ( present ( stat )) stat = toml_stat % fatal if ( present ( origin )) origin = array % origin end if end subroutine get_elem_table subroutine get_elem_array ( array , pos , ptr , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Pointer to child array type ( toml_array ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin class ( toml_value ), pointer :: tmp if (. not . initialized ( array )) call new_array ( array ) nullify ( ptr ) call array % get ( pos , tmp ) if ( associated ( tmp )) then ptr => cast_to_array ( tmp ) if ( present ( stat )) then if ( associated ( ptr )) then stat = toml_stat % success else stat = toml_stat % type_mismatch end if end if if ( present ( origin )) origin = tmp % origin else if ( present ( stat )) stat = toml_stat % fatal if ( present ( origin )) origin = array % origin end if end subroutine get_elem_array subroutine get_elem_keyval ( array , pos , ptr , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Pointer to child value type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin class ( toml_value ), pointer :: tmp if (. not . initialized ( array )) call new_array ( array ) nullify ( ptr ) call array % get ( pos , tmp ) if ( associated ( tmp )) then ptr => cast_to_keyval ( tmp ) if ( present ( stat )) then if ( associated ( ptr )) then stat = toml_stat % success else stat = toml_stat % type_mismatch end if end if if ( present ( origin )) origin = tmp % origin else if ( present ( stat )) stat = toml_stat % fatal if ( present ( origin )) origin = array % origin end if end subroutine get_elem_keyval !> Retrieve TOML value as deferred-length character subroutine get_elem_value_string ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> String value character ( kind = tfc , len = :), allocatable , intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_string !> Retrieve TOML value as single precision floating point number subroutine get_elem_value_float_sp ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Floating point value real ( tf_sp ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_float_sp !> Retrieve TOML value as double precision floating point number subroutine get_elem_value_float_dp ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Floating point value real ( tf_dp ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_float_dp !> Retrieve TOML value as integer value subroutine get_elem_value_int_i1 ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i1 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_int_i1 !> Retrieve TOML value as integer value subroutine get_elem_value_int_i2 ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i2 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_int_i2 !> Retrieve TOML value as integer value subroutine get_elem_value_int_i4 ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i4 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_int_i4 !> Retrieve TOML value as integer value subroutine get_elem_value_int_i8 ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i8 ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_int_i8 !> Retrieve TOML value as boolean subroutine get_elem_value_bool ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value logical , intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_bool !> Retrieve TOML value as datetime subroutine get_elem_value_datetime ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value type ( toml_datetime ), intent ( out ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if ( associated ( ptr )) then call get_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine get_elem_value_datetime !> Retrieve TOML value as deferred-length character subroutine set_elem_value_string ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> String value character ( kind = tfc , len =* ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_string !> Retrieve TOML value as single precision floating point number subroutine set_elem_value_float_sp ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Floating point value real ( tf_sp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_float_sp !> Retrieve TOML value as double precision floating point number subroutine set_elem_value_float_dp ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Floating point value real ( tf_dp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_float_dp !> Retrieve TOML value as integer value subroutine set_elem_value_int_i1 ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i1 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_int_i1 !> Retrieve TOML value as integer value subroutine set_elem_value_int_i2 ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i2 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_int_i2 !> Retrieve TOML value as integer value subroutine set_elem_value_int_i4 ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i4 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_int_i4 !> Retrieve TOML value as integer value subroutine set_elem_value_int_i8 ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Integer value integer ( tf_i8 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_int_i8 !> Retrieve TOML value as boolean value subroutine set_elem_value_bool ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Boolean value logical , intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_bool !> Retrieve TOML value as datetime value subroutine set_elem_value_datetime ( array , pos , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Position in the array integer , intent ( in ) :: pos !> Datetime value type ( toml_datetime ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( array , pos , ptr , stat , origin ) if (. not . associated ( ptr )) then if ( pos == len ( array ) + 1 ) then call add_keyval ( array , ptr , stat ) end if end if if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) stat = toml_stat % fatal end if end subroutine set_elem_value_datetime !> Retrieve TOML value as single precision floating point number subroutine get_array_value_float_sp ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Floating point value real ( tf_sp ), allocatable , intent ( out ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it , info info = 0 allocate ( val ( len ( array ))) do it = 1 , size ( val ) call get_value ( array , it , val ( it ), info , origin ) if ( info /= 0 ) exit end do if ( info /= 0 ) deallocate ( val ) if ( present ( stat )) stat = info if ( present ( origin ) . and . info == 0 ) origin = array % origin end subroutine get_array_value_float_sp !> Retrieve TOML value as double precision floating point number subroutine get_array_value_float_dp ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Floating point value real ( tf_dp ), allocatable , intent ( out ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it , info info = 0 allocate ( val ( len ( array ))) do it = 1 , size ( val ) call get_value ( array , it , val ( it ), info , origin ) if ( info /= 0 ) exit end do if ( info /= 0 ) deallocate ( val ) if ( present ( stat )) stat = info if ( present ( origin ) . and . info == 0 ) origin = array % origin end subroutine get_array_value_float_dp !> Retrieve TOML value as integer value subroutine get_array_value_int_i1 ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value integer ( tf_i1 ), allocatable , intent ( out ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it , info info = 0 allocate ( val ( len ( array ))) do it = 1 , size ( val ) call get_value ( array , it , val ( it ), info , origin ) if ( info /= 0 ) exit end do if ( info /= 0 ) deallocate ( val ) if ( present ( stat )) stat = info if ( present ( origin ) . and . info == 0 ) origin = array % origin end subroutine get_array_value_int_i1 !> Retrieve TOML value as integer value subroutine get_array_value_int_i2 ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value integer ( tf_i2 ), allocatable , intent ( out ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it , info info = 0 allocate ( val ( len ( array ))) do it = 1 , size ( val ) call get_value ( array , it , val ( it ), info , origin ) if ( info /= 0 ) exit end do if ( info /= 0 ) deallocate ( val ) if ( present ( stat )) stat = info if ( present ( origin ) . and . info == 0 ) origin = array % origin end subroutine get_array_value_int_i2 !> Retrieve TOML value as integer value subroutine get_array_value_int_i4 ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value integer ( tf_i4 ), allocatable , intent ( out ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it , info info = 0 allocate ( val ( len ( array ))) do it = 1 , size ( val ) call get_value ( array , it , val ( it ), info , origin ) if ( info /= 0 ) exit end do if ( info /= 0 ) deallocate ( val ) if ( present ( stat )) stat = info if ( present ( origin ) . and . info == 0 ) origin = array % origin end subroutine get_array_value_int_i4 !> Retrieve TOML value as integer value subroutine get_array_value_int_i8 ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value integer ( tf_i8 ), allocatable , intent ( out ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it , info info = 0 allocate ( val ( len ( array ))) do it = 1 , size ( val ) call get_value ( array , it , val ( it ), info , origin ) if ( info /= 0 ) exit end do if ( info /= 0 ) deallocate ( val ) if ( present ( stat )) stat = info if ( present ( origin ) . and . info == 0 ) origin = array % origin end subroutine get_array_value_int_i8 !> Retrieve TOML value as boolean subroutine get_array_value_bool ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value logical , allocatable , intent ( out ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it , info info = 0 allocate ( val ( len ( array ))) do it = 1 , size ( val ) call get_value ( array , it , val ( it ), info , origin ) if ( info /= 0 ) exit end do if ( info /= 0 ) deallocate ( val ) if ( present ( stat )) stat = info if ( present ( origin ) . and . info == 0 ) origin = array % origin end subroutine get_array_value_bool !> Retrieve TOML value as datetime subroutine get_array_value_datetime ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value type ( toml_datetime ), allocatable , intent ( out ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it , info info = 0 allocate ( val ( len ( array ))) do it = 1 , size ( val ) call get_value ( array , it , val ( it ), info , origin ) if ( info /= 0 ) exit end do if ( info /= 0 ) deallocate ( val ) if ( present ( stat )) stat = info if ( present ( origin ) . and . info == 0 ) origin = array % origin end subroutine get_array_value_datetime !> Retrieve TOML value as single precision floating point number subroutine set_array_value_float_sp ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Floating point value real ( tf_sp ), intent ( in ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it class ( toml_value ), allocatable :: ptr do while ( len ( array ) > size ( val )) call array % pop ( ptr ) end do do it = 1 , size ( val ) call set_value ( array , it , val ( it ), stat , origin ) end do if ( present ( origin )) origin = array % origin end subroutine set_array_value_float_sp !> Retrieve TOML value as double precision floating point number subroutine set_array_value_float_dp ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Floating point value real ( tf_dp ), intent ( in ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it class ( toml_value ), allocatable :: ptr do while ( len ( array ) > size ( val )) call array % pop ( ptr ) end do do it = 1 , size ( val ) call set_value ( array , it , val ( it ), stat , origin ) end do if ( present ( origin )) origin = array % origin end subroutine set_array_value_float_dp !> Retrieve TOML value as integer value subroutine set_array_value_int_i1 ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value integer ( tf_i1 ), intent ( in ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it class ( toml_value ), allocatable :: ptr do while ( len ( array ) > size ( val )) call array % pop ( ptr ) end do do it = 1 , size ( val ) call set_value ( array , it , val ( it ), stat , origin ) end do if ( present ( origin )) origin = array % origin end subroutine set_array_value_int_i1 !> Retrieve TOML value as integer value subroutine set_array_value_int_i2 ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value integer ( tf_i2 ), intent ( in ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it class ( toml_value ), allocatable :: ptr do while ( len ( array ) > size ( val )) call array % pop ( ptr ) end do do it = 1 , size ( val ) call set_value ( array , it , val ( it ), stat , origin ) end do if ( present ( origin )) origin = array % origin end subroutine set_array_value_int_i2 !> Retrieve TOML value as integer value subroutine set_array_value_int_i4 ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value integer ( tf_i4 ), intent ( in ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it class ( toml_value ), allocatable :: ptr do while ( len ( array ) > size ( val )) call array % pop ( ptr ) end do do it = 1 , size ( val ) call set_value ( array , it , val ( it ), stat , origin ) end do if ( present ( origin )) origin = array % origin end subroutine set_array_value_int_i4 !> Retrieve TOML value as integer value subroutine set_array_value_int_i8 ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Integer value integer ( tf_i8 ), intent ( in ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it class ( toml_value ), allocatable :: ptr do while ( len ( array ) > size ( val )) call array % pop ( ptr ) end do do it = 1 , size ( val ) call set_value ( array , it , val ( it ), stat , origin ) end do if ( present ( origin )) origin = array % origin end subroutine set_array_value_int_i8 !> Retrieve TOML value as boolean value subroutine set_array_value_bool ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Boolean value logical , intent ( in ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it class ( toml_value ), allocatable :: ptr do while ( len ( array ) > size ( val )) call array % pop ( ptr ) end do do it = 1 , size ( val ) call set_value ( array , it , val ( it ), stat , origin ) end do if ( present ( origin )) origin = array % origin end subroutine set_array_value_bool !> Retrieve TOML value as datetime value subroutine set_array_value_datetime ( array , val , stat , origin ) !> Instance of the TOML array class ( toml_array ), intent ( inout ) :: array !> Datetime value type ( toml_datetime ), intent ( in ) :: val (:) !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin integer :: it class ( toml_value ), allocatable :: ptr do while ( len ( array ) > size ( val )) call array % pop ( ptr ) end do do it = 1 , size ( val ) call set_value ( array , it , val ( it ), stat , origin ) end do if ( present ( origin )) origin = array % origin end subroutine set_array_value_datetime end module tomlf_build_array","tags":"","url":"sourcefile/array.f90~2.html"},{"title":"tomlf.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Minimal public API for TOML-Fortran module tomlf use tomlf_build , only : get_value , set_value , toml_path use tomlf_datetime , only : toml_datetime , to_string use tomlf_de , only : toml_parse , toml_load , toml_loads , & & toml_context , toml_parser_config , toml_level use tomlf_error , only : toml_error , toml_stat use tomlf_ser , only : toml_serializer , toml_serialize , toml_dump , toml_dumps use tomlf_terminal , only : toml_terminal use tomlf_type , only : toml_table , toml_array , toml_keyval , toml_key , toml_value , & & is_array_of_tables , new_table , add_table , add_array , add_keyval , len use tomlf_utils_sort , only : sort use tomlf_version , only : tomlf_version_string , tomlf_version_compact , & & get_tomlf_version implicit none public end module tomlf","tags":"","url":"sourcefile/tomlf.f90.html"},{"title":"all.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Complete reexport of the public API of TOML-Fortran module tomlf_all use tomlf_build use tomlf_constants use tomlf_datetime use tomlf_de use tomlf_error use tomlf_ser use tomlf_structure use tomlf_type use tomlf_utils use tomlf_version implicit none public end module tomlf_all","tags":"","url":"sourcefile/all.f90.html"},{"title":"keyval.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> TOML key-value pair module tomlf_type_keyval use tomlf_constants , only : tfc , tfr , tfi , toml_type use tomlf_datetime , only : toml_datetime use tomlf_type_value , only : toml_value , toml_visitor implicit none private public :: toml_keyval , new_keyval , new !> Generic TOML value type , abstract :: generic_value end type generic_value !> TOML real value type , extends ( generic_value ) :: float_value real ( tfr ) :: raw end type float_value !> TOML integer value type , extends ( generic_value ) :: integer_value integer ( tfi ) :: raw end type integer_value !> TOML boolean value type , extends ( generic_value ) :: boolean_value logical :: raw end type boolean_value !> TOML datetime value type , extends ( generic_value ) :: datetime_value type ( toml_datetime ) :: raw end type datetime_value !> TOML string value type , extends ( generic_value ) :: string_value character (:, tfc ), allocatable :: raw end type string_value !> TOML key-value pair type , extends ( toml_value ) :: toml_keyval !> Actual TOML value class ( generic_value ), allocatable :: val !> Origin of value integer :: origin_value = 0 contains !> Get the value stored in the key-value pair generic :: get => get_float , get_integer , get_boolean , get_datetime , get_string procedure :: get_float procedure :: get_integer procedure :: get_boolean procedure :: get_datetime procedure :: get_string !> Set the value for the key-value pair generic :: set => set_float , set_integer , set_boolean , set_datetime , set_string procedure :: set_float procedure :: set_integer procedure :: set_boolean procedure :: set_datetime procedure :: set_string !> Get the type of the value stored in the key-value pair procedure :: get_type !> Release allocation hold by TOML key-value pair procedure :: destroy end type toml_keyval !> Overloaded constructor for TOML values interface new module procedure :: new_keyval end interface contains !> Constructor to create a new TOML key-value pair subroutine new_keyval ( self ) !> Instance of the TOML key-value pair type ( toml_keyval ), intent ( out ) :: self associate ( self => self ); end associate end subroutine new_keyval !> Deconstructor to cleanup allocations (optional) subroutine destroy ( self ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( inout ) :: self if ( allocated ( self % key )) then deallocate ( self % key ) end if if ( allocated ( self % val )) then deallocate ( self % val ) end if end subroutine destroy !> Obtain real value from TOML key-value pair subroutine get_float ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( in ) :: self !> Value to be assigned real ( tfr ), pointer , intent ( out ) :: val val => cast_float ( self % val ) end subroutine get_float !> Obtain integer value from TOML key-value pair subroutine get_integer ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( in ) :: self !> Value to be assigned integer ( tfi ), pointer , intent ( out ) :: val val => cast_integer ( self % val ) end subroutine get_integer !> Obtain boolean value from TOML key-value pair subroutine get_boolean ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( in ) :: self !> Value to be assigned logical , pointer , intent ( out ) :: val val => cast_boolean ( self % val ) end subroutine get_boolean !> Obtain datetime value from TOML key-value pair subroutine get_datetime ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( in ) :: self !> Value to be assigned type ( toml_datetime ), pointer , intent ( out ) :: val val => cast_datetime ( self % val ) end subroutine get_datetime !> Obtain datetime value from TOML key-value pair subroutine get_string ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( in ) :: self !> Value to be assigned character (:, tfc ), pointer , intent ( out ) :: val val => cast_string ( self % val ) end subroutine get_string !> Obtain real value from TOML key-value pair subroutine set_float ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Value to be assigned real ( tfr ), intent ( in ) :: val type ( float_value ), allocatable :: tmp allocate ( tmp ) tmp % raw = val call move_alloc ( tmp , self % val ) end subroutine set_float !> Obtain integer value from TOML key-value pair subroutine set_integer ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Value to be assigned integer ( tfi ), intent ( in ) :: val type ( integer_value ), allocatable :: tmp allocate ( tmp ) tmp % raw = val call move_alloc ( tmp , self % val ) end subroutine set_integer !> Obtain boolean value from TOML key-value pair subroutine set_boolean ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Value to be assigned logical , intent ( in ) :: val type ( boolean_value ), allocatable :: tmp allocate ( tmp ) tmp % raw = val call move_alloc ( tmp , self % val ) end subroutine set_boolean !> Obtain datetime value from TOML key-value pair subroutine set_datetime ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Value to be assigned type ( toml_datetime ), intent ( in ) :: val type ( datetime_value ), allocatable :: tmp allocate ( tmp ) tmp % raw = val call move_alloc ( tmp , self % val ) end subroutine set_datetime !> Obtain datetime value from TOML key-value pair subroutine set_string ( self , val ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( inout ) :: self !> Value to be assigned character ( * , tfc ), intent ( in ) :: val type ( string_value ), allocatable :: tmp allocate ( tmp ) tmp % raw = val call move_alloc ( tmp , self % val ) end subroutine set_string !> Get the type of the value stored in the key-value pair pure function get_type ( self ) result ( value_type ) !> Instance of the TOML key-value pair class ( toml_keyval ), intent ( in ) :: self !> Value type integer :: value_type select type ( val => self % val ) class default value_type = toml_type % invalid type is ( float_value ) value_type = toml_type % float type is ( integer_value ) value_type = toml_type % int type is ( boolean_value ) value_type = toml_type % boolean type is ( datetime_value ) value_type = toml_type % datetime type is ( string_value ) value_type = toml_type % string end select end function get_type function cast_float ( val ) result ( ptr ) class ( generic_value ), intent ( in ), target :: val real ( tfr ), pointer :: ptr nullify ( ptr ) select type ( val ) type is ( float_value ) ptr => val % raw end select end function cast_float function cast_integer ( val ) result ( ptr ) class ( generic_value ), intent ( in ), target :: val integer ( tfi ), pointer :: ptr nullify ( ptr ) select type ( val ) type is ( integer_value ) ptr => val % raw end select end function cast_integer function cast_boolean ( val ) result ( ptr ) class ( generic_value ), intent ( in ), target :: val logical , pointer :: ptr nullify ( ptr ) select type ( val ) type is ( boolean_value ) ptr => val % raw end select end function cast_boolean function cast_datetime ( val ) result ( ptr ) class ( generic_value ), intent ( in ), target :: val type ( toml_datetime ), pointer :: ptr nullify ( ptr ) select type ( val ) type is ( datetime_value ) ptr => val % raw end select end function cast_datetime function cast_string ( val ) result ( ptr ) class ( generic_value ), intent ( in ), target :: val character (:, tfc ), pointer :: ptr nullify ( ptr ) select type ( val ) type is ( string_value ) ptr => val % raw end select end function cast_string end module tomlf_type_keyval","tags":"","url":"sourcefile/keyval.f90~2.html"},{"title":"table.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Functions to build TOML tables !> !> The build module defines a high level interface to work with TOML tables !> and construct them in a convenient way. !> !> The getter functions allow to both retrieve and set values, to easily !> support default values when reading from a TOML data structure. !> Using the getter function with a default value specified will request !> the respective setter function to add it to the table if it was not !> found in the first place. !> !> This allows to build a TOML table using only the getter functions, which !> represents the finally read values for the applications. !> !> Note that neither setter nor getter functions can overwrite existing !> TOML values for safety reasons, request the deletion on the respective !> key from the TOML table and than set it. The deletion of a subtable or !> array will recursively destroy the contained data nodes. module tomlf_build_table use tomlf_build_keyval , only : get_value , set_value use tomlf_constants , only : tfc , tfi , tfr , tf_i1 , tf_i2 , tf_i4 , tf_i8 , & & tf_sp , tf_dp use tomlf_datetime , only : toml_datetime use tomlf_error , only : toml_stat use tomlf_type , only : toml_value , toml_table , toml_array , toml_keyval , & & new_table , new_array , new_keyval , add_table , add_array , add_keyval , & & toml_key , cast_to_table , cast_to_array , cast_to_keyval , initialized , & & len implicit none private public :: get_value , set_value !> Setter functions to manipulate TOML tables interface set_value module procedure :: set_child_value_float_sp module procedure :: set_child_value_float_dp module procedure :: set_child_value_integer_i1 module procedure :: set_child_value_integer_i2 module procedure :: set_child_value_integer_i4 module procedure :: set_child_value_integer_i8 module procedure :: set_child_value_bool module procedure :: set_child_value_datetime module procedure :: set_child_value_string module procedure :: set_key_value_float_sp module procedure :: set_key_value_float_dp module procedure :: set_key_value_integer_i1 module procedure :: set_key_value_integer_i2 module procedure :: set_key_value_integer_i4 module procedure :: set_key_value_integer_i8 module procedure :: set_key_value_bool module procedure :: set_key_value_datetime module procedure :: set_key_value_string end interface set_value !> Getter functions to manipulate TOML tables interface get_value module procedure :: get_child_table module procedure :: get_child_array module procedure :: get_child_keyval module procedure :: get_child_value_float_sp module procedure :: get_child_value_float_dp module procedure :: get_child_value_integer_i1 module procedure :: get_child_value_integer_i2 module procedure :: get_child_value_integer_i4 module procedure :: get_child_value_integer_i8 module procedure :: get_child_value_bool module procedure :: get_child_value_datetime module procedure :: get_child_value_string module procedure :: get_key_table module procedure :: get_key_array module procedure :: get_key_keyval module procedure :: get_key_value_float_sp module procedure :: get_key_value_float_dp module procedure :: get_key_value_integer_i1 module procedure :: get_key_value_integer_i2 module procedure :: get_key_value_integer_i4 module procedure :: get_key_value_integer_i8 module procedure :: get_key_value_bool module procedure :: get_key_value_datetime module procedure :: get_key_value_string end interface get_value contains subroutine get_key_table ( table , key , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Pointer to child table type ( toml_table ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , ptr , requested , stat , origin ) end subroutine get_key_table subroutine get_key_array ( table , key , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Pointer to child array type ( toml_array ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , ptr , requested , stat , origin ) end subroutine get_key_array subroutine get_key_keyval ( table , key , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Pointer to child value type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , ptr , requested , stat , origin ) end subroutine get_key_keyval !> Retrieve TOML value as single precision float (might lose accuracy) subroutine get_key_value_float_sp ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Real value real ( tf_sp ), intent ( out ) :: val !> Default real value real ( tf_sp ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_float_sp !> Retrieve TOML value as double precision float subroutine get_key_value_float_dp ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Real value real ( tf_dp ), intent ( out ) :: val !> Default real value real ( tf_dp ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_float_dp !> Retrieve TOML value as one byte integer (might loose precision) subroutine get_key_value_integer_i1 ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Integer value integer ( tf_i1 ), intent ( out ) :: val !> Default integer value integer ( tf_i1 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_integer_i1 !> Retrieve TOML value as two byte integer (might loose precision) subroutine get_key_value_integer_i2 ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Integer value integer ( tf_i2 ), intent ( out ) :: val !> Default integer value integer ( tf_i2 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_integer_i2 !> Retrieve TOML value as four byte integer (might loose precision) subroutine get_key_value_integer_i4 ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Integer value integer ( tf_i4 ), intent ( out ) :: val !> Default integer value integer ( tf_i4 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_integer_i4 !> Retrieve TOML value as eight byte integer subroutine get_key_value_integer_i8 ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Integer value integer ( tf_i8 ), intent ( out ) :: val !> Default integer value integer ( tf_i8 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_integer_i8 !> Retrieve TOML value as logical subroutine get_key_value_bool ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Boolean value logical , intent ( out ) :: val !> Default boolean value logical , intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_bool !> Retrieve TOML value as datetime subroutine get_key_value_datetime ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Datetime value type ( toml_datetime ), intent ( out ) :: val !> Default datetime value type ( toml_datetime ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_datetime !> Retrieve TOML value as deferred-length character subroutine get_key_value_string ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> String value character ( kind = tfc , len = :), allocatable , intent ( out ) :: val !> Default string value character ( kind = tfc , len =* ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call get_value ( table , key % key , val , default , stat , origin ) end subroutine get_key_value_string !> Set TOML value to single precision float subroutine set_key_value_float_sp ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Real value real ( tf_sp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_float_sp !> Set TOML value to double precision float subroutine set_key_value_float_dp ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Real value real ( tf_dp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_float_dp !> Set TOML value to one byte integer subroutine set_key_value_integer_i1 ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Integer value integer ( tf_i1 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_integer_i1 !> Set TOML value to two byte integer subroutine set_key_value_integer_i2 ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Integer value integer ( tf_i2 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_integer_i2 !> Set TOML value to four byte integer subroutine set_key_value_integer_i4 ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Integer value integer ( tf_i4 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_integer_i4 !> Set TOML value to eight byte integer subroutine set_key_value_integer_i8 ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Integer value integer ( tf_i8 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_integer_i8 !> Set TOML value to logical subroutine set_key_value_bool ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Boolean value logical , intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_bool !> Set TOML value to datetime subroutine set_key_value_datetime ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> Datetime value type ( toml_datetime ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_datetime !> Set TOML value to deferred-length character subroutine set_key_value_string ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table type ( toml_key ), intent ( in ) :: key !> String value character ( kind = tfc , len =* ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin call set_value ( table , key % key , val , stat , origin ) end subroutine set_key_value_string subroutine get_child_table ( table , key , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to child table type ( toml_table ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin class ( toml_value ), pointer :: tmp logical :: is_requested if (. not . initialized ( table )) call new_table ( table ) if ( present ( requested )) then is_requested = requested else is_requested = . true . end if nullify ( ptr ) call table % get ( key , tmp ) if ( associated ( tmp )) then ptr => cast_to_table ( tmp ) if ( present ( stat )) then if ( associated ( ptr )) then stat = toml_stat % success else stat = toml_stat % type_mismatch end if end if if ( present ( origin )) origin = tmp % origin else if ( is_requested ) then call add_table ( table , key , ptr , stat ) else if ( present ( stat )) stat = toml_stat % success end if if ( present ( origin )) origin = table % origin end if end subroutine get_child_table subroutine get_child_array ( table , key , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to child array type ( toml_array ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin class ( toml_value ), pointer :: tmp logical :: is_requested if (. not . initialized ( table )) call new_table ( table ) if ( present ( requested )) then is_requested = requested else is_requested = . true . end if nullify ( ptr ) call table % get ( key , tmp ) if ( associated ( tmp )) then ptr => cast_to_array ( tmp ) if ( present ( stat )) then if ( associated ( ptr )) then stat = toml_stat % success else stat = toml_stat % type_mismatch end if end if if ( present ( origin )) origin = tmp % origin else if ( is_requested ) then call add_array ( table , key , ptr , stat ) else if ( present ( stat )) stat = toml_stat % success end if if ( present ( origin )) origin = table % origin end if end subroutine get_child_array subroutine get_child_keyval ( table , key , ptr , requested , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Pointer to child value type ( toml_keyval ), pointer , intent ( out ) :: ptr !> Child value must be present logical , intent ( in ), optional :: requested !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin class ( toml_value ), pointer :: tmp logical :: is_requested if (. not . initialized ( table )) call new_table ( table ) if ( present ( requested )) then is_requested = requested else is_requested = . true . end if nullify ( ptr ) call table % get ( key , tmp ) if ( associated ( tmp )) then ptr => cast_to_keyval ( tmp ) if ( present ( stat )) then if ( associated ( ptr )) then stat = toml_stat % success else stat = toml_stat % type_mismatch end if end if if ( present ( origin )) origin = tmp % origin else if ( is_requested ) then call add_keyval ( table , key , ptr , stat ) else if ( present ( stat )) stat = toml_stat % success end if if ( present ( origin )) origin = table % origin end if end subroutine get_child_keyval !> Retrieve TOML value as single precision float (might lose accuracy) subroutine get_child_value_float_sp ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Real value real ( tf_sp ), intent ( out ) :: val !> Default real value real ( tf_sp ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_float_sp !> Retrieve TOML value as double precision float subroutine get_child_value_float_dp ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Real value real ( tf_dp ), intent ( out ) :: val !> Default real value real ( tf_dp ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_float_dp !> Retrieve TOML value as one byte integer (might loose precision) subroutine get_child_value_integer_i1 ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i1 ), intent ( out ) :: val !> Default integer value integer ( tf_i1 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_integer_i1 !> Retrieve TOML value as two byte integer (might loose precision) subroutine get_child_value_integer_i2 ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i2 ), intent ( out ) :: val !> Default integer value integer ( tf_i2 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_integer_i2 !> Retrieve TOML value as four byte integer (might loose precision) subroutine get_child_value_integer_i4 ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i4 ), intent ( out ) :: val !> Default integer value integer ( tf_i4 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_integer_i4 !> Retrieve TOML value as eight byte integer subroutine get_child_value_integer_i8 ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i8 ), intent ( out ) :: val !> Default integer value integer ( tf_i8 ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_integer_i8 !> Retrieve TOML value as logical subroutine get_child_value_bool ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Boolean value logical , intent ( out ) :: val !> Default boolean value logical , intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_bool !> Retrieve TOML value as datetime subroutine get_child_value_datetime ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Datetime value type ( toml_datetime ), intent ( out ) :: val !> Default datetime value type ( toml_datetime ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_datetime !> Retrieve TOML value as deferred-length character subroutine get_child_value_string ( table , key , val , default , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> String value character ( kind = tfc , len = :), allocatable , intent ( out ) :: val !> Default string value character ( kind = tfc , len =* ), intent ( in ), optional :: default !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , present ( default ), stat , origin ) if ( associated ( ptr )) then if ( allocated ( ptr % val )) then call get_value ( ptr , val , stat , origin ) else if ( present ( default )) then call set_value ( ptr , default ) call get_value ( ptr , val , stat = stat ) else if ( present ( stat )) stat = toml_stat % fatal end if end if else if (. not . present ( default )) then if ( present ( stat )) stat = merge ( toml_stat % missing_key , stat , stat == toml_stat % success ) end if end subroutine get_child_value_string !> Set TOML value to single precision float subroutine set_child_value_float_sp ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Real value real ( tf_sp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_float_sp !> Set TOML value to double precision float subroutine set_child_value_float_dp ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Real value real ( tf_dp ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_float_dp !> Set TOML value to one byte integer subroutine set_child_value_integer_i1 ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i1 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_integer_i1 !> Set TOML value to two byte integer subroutine set_child_value_integer_i2 ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i2 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_integer_i2 !> Set TOML value to four byte integer subroutine set_child_value_integer_i4 ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i4 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_integer_i4 !> Set TOML value to eight byte integer subroutine set_child_value_integer_i8 ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Integer value integer ( tf_i8 ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_integer_i8 !> Set TOML value to logical subroutine set_child_value_bool ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Boolean value logical , intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_bool !> Set TOML value to datetime subroutine set_child_value_datetime ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> Datetime value type ( toml_datetime ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_datetime !> Set TOML value to deferred-length character subroutine set_child_value_string ( table , key , val , stat , origin ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key in this TOML table character ( kind = tfc , len =* ), intent ( in ) :: key !> String value character ( kind = tfc , len =* ), intent ( in ) :: val !> Status of operation integer , intent ( out ), optional :: stat !> Origin in the data structure integer , intent ( out ), optional :: origin type ( toml_keyval ), pointer :: ptr call get_value ( table , key , ptr , . true ., stat , origin ) if ( associated ( ptr )) then call set_value ( ptr , val , stat , origin ) else if ( present ( stat )) then if ( stat == toml_stat % success ) stat = toml_stat % fatal end if end if end subroutine set_child_value_string end module tomlf_build_table","tags":"","url":"sourcefile/table.f90~2.html"},{"title":"constants.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module tomlf_constants use , intrinsic :: iso_fortran_env , only : output_unit implicit none private !> Single precision real numbers integer , public , parameter :: tf_sp = selected_real_kind ( 6 ) !> Double precision real numbers integer , public , parameter :: tf_dp = selected_real_kind ( 15 ) !> Char length for integers integer , public , parameter :: tf_i1 = selected_int_kind ( 2 ) !> Short length for integers integer , public , parameter :: tf_i2 = selected_int_kind ( 4 ) !> Length of default integers integer , public , parameter :: tf_i4 = selected_int_kind ( 9 ) !> Long length for integers integer , public , parameter :: tf_i8 = selected_int_kind ( 18 ) !> Default character kind integer , public , parameter :: tfc = selected_char_kind ( 'DEFAULT' ) !> Default float precision, IEEE 754 binary64 values expected integer , public , parameter :: tfr = tf_dp !> Default integer precision, 64 bit (signed long) range expected integer , public , parameter :: tfi = tf_i8 !> Default output channel integer , public , parameter :: tfout = output_unit !> Possible escape characters in TOML type :: enum_escape !> Backslash is used to escape other characters character ( kind = tfc , len = 1 ) :: backslash = tfc_ '\\' !> Double quotes signal strings with escape characters enabled character(kind=tfc, len=1) :: dquote = tfc_' \"' !> Single quotes signal strings without escape characters enabled character(kind=tfc, len=1) :: squote = tfc_'''' !> Newline character character(kind=tfc, len=1) :: newline = achar(10, kind=tfc) !> Formfeed character is allowed in strings character(kind=tfc, len=1) :: formfeed = achar(12, kind=tfc) !> Carriage return is allowed as part of the newline and in strings character(kind=tfc, len=1) :: carriage_return = achar(13, kind=tfc) !> Backspace is allowed in strings character(kind=tfc, len=1) :: bspace = achar(8, kind=tfc) !> Tabulators are allowed as whitespace and in strings character(kind=tfc, len=1) :: tabulator = achar(9, kind=tfc) end type enum_escape !> Actual enumerator with TOML escape characters type(enum_escape), public, parameter :: toml_escape = enum_escape() !> Possible kinds of TOML values in key-value pairs type :: enum_type !> Invalid type integer :: invalid = 100 !> String type integer :: string = 101 !> Boolean type integer :: boolean = 102 !> Integer type integer :: int = 103 !> Float type integer :: float = 104 !> Datetime type integer :: datetime = 105 end type enum_type !> Actual enumerator with TOML value types type(enum_type), public, parameter :: toml_type = enum_type() !> Single quotes denote literal strings character(kind=tfc, len=*), public, parameter :: TOML_SQUOTE = \" '\" !> Double quotes denote strings (with escape character possible) character(kind=tfc, len=*), public, parameter :: TOML_DQUOTE = ' \" ' character(kind=tfc, len=*), public, parameter :: TOML_NEWLINE = new_line(' a ') ! \\n character(kind=tfc, len=*), public, parameter :: TOML_TABULATOR = achar(9) ! \\t character(kind=tfc, len=*), public, parameter :: TOML_FORMFEED = achar(12) ! \\f character(kind=tfc, len=*), public, parameter :: TOML_CARRIAGE_RETURN = achar(13) ! \\r character(kind=tfc, len=*), public, parameter :: TOML_BACKSPACE = achar(8) ! \\b character(kind=tfc, len=*), public, parameter :: TOML_LOWERCASE = & & ' abcdefghijklmnopqrstuvwxyz ' character(kind=tfc, len=*), public, parameter :: TOML_UPPERCASE = & & ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' character(kind=tfc, len=*), public, parameter :: TOML_LETTERS = & & TOML_LOWERCASE//TOML_UPPERCASE !> Whitespace in TOML are blanks and tabs. character(kind=tfc, len=*), public, parameter :: TOML_WHITESPACE = & & ' '//toml_escape%tabulator character(kind=tfc, len=*), public, parameter :: TOML_DIGITS = ' 0123456789 ' character(kind=tfc, len=*), public, parameter :: TOML_BINDIGITS = & & ' 01 ' character(kind=tfc, len=*), public, parameter :: TOML_OCTDIGITS = & & ' 01234567 ' character(kind=tfc, len=*), public, parameter :: TOML_HEXDIGITS = & & ' 0123456789 ABCDEFabcdef ' character(kind=tfc, len=*), public, parameter :: TOML_TIMESTAMP = & & TOML_DIGITS//' .: +- T Zz ' !> Allowed characters in TOML bare keys. character(kind=tfc, len=*), public, parameter :: TOML_BAREKEY = & & TOML_LETTERS//TOML_DIGITS//' _ - ' character(kind=tfc, len=*), public, parameter :: TOML_LITERALS = & & TOML_LETTERS//TOML_DIGITS//' _ -+ . ' end module tomlf_constants","tags":"","url":"sourcefile/constants.f90.html"},{"title":"ser.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> TOML serializer implementation module tomlf_ser use tomlf_constants , only : tfc , tfi , tfr , tfout , toml_type use tomlf_datetime , only : toml_datetime , to_string use tomlf_error , only : toml_error , toml_stat , make_error use tomlf_type , only : toml_value , toml_visitor , toml_key , toml_table , & & toml_array , toml_keyval , is_array_of_tables , len use tomlf_utils , only : to_string , toml_escape_string implicit none private public :: toml_serializer , new_serializer , new public :: toml_dump , toml_dumps , toml_serialize interface toml_dumps module procedure :: toml_dump_to_string end interface toml_dumps interface toml_dump module procedure :: toml_dump_to_file module procedure :: toml_dump_to_unit end interface toml_dump !> Configuration for JSON serializer type :: toml_ser_config !> Indentation character ( len = :), allocatable :: indent end type toml_ser_config !> TOML serializer to produduce a TOML document from a datastructure type , extends ( toml_visitor ) :: toml_serializer private !> Output string character (:), allocatable :: output !> Configuration for serializer type ( toml_ser_config ) :: config = toml_ser_config () !> Special mode for printing array of tables logical , private :: array_of_tables = . false . !> Special mode for printing inline arrays logical , private :: inline_array = . false . !> Top of the key stack integer , private :: top = 0 !> Key stack to create table headers type ( toml_key ), allocatable , private :: stack (:) contains !> Visit a TOML value procedure :: visit end type toml_serializer !> Create standard constructor interface toml_serializer module procedure :: new_serializer_func end interface toml_serializer !> Overloaded constructor for TOML serializers interface new module procedure :: new_serializer end interface !> Initial size of the key path stack integer , parameter :: initial_size = 8 contains !> Serialize a JSON value to a string and return it. !> !> In case of an error this function will invoke an error stop. function toml_serialize ( val , config ) result ( string ) !> TOML value to visit class ( toml_value ), intent ( inout ) :: val !> Configuration for serializer type ( toml_ser_config ), intent ( in ), optional :: config !> Serialized JSON value character ( len = :), allocatable :: string type ( toml_error ), allocatable :: error call toml_dumps ( val , string , error , config = config ) if ( allocated ( error )) then print '(a)' , \"Error: \" // error % message error stop 1 end if end function toml_serialize !> Create a string representing the JSON value subroutine toml_dump_to_string ( val , string , error , config ) !> TOML value to visit class ( toml_value ), intent ( inout ) :: val !> Formatted unit to write to character (:), allocatable , intent ( out ) :: string !> Error handling type ( toml_error ), allocatable , intent ( out ) :: error !> Configuration for serializer type ( toml_ser_config ), intent ( in ), optional :: config type ( toml_serializer ) :: ser ser = toml_serializer ( config = config ) call val % accept ( ser ) string = ser % output end subroutine toml_dump_to_string !> Write string representation of JSON value to a connected formatted unit subroutine toml_dump_to_unit ( val , io , error , config ) !> TOML value to visit class ( toml_value ), intent ( inout ) :: val !> Formatted unit to write to integer , intent ( in ) :: io !> Error handling type ( toml_error ), allocatable , intent ( out ) :: error !> Configuration for serializer type ( toml_ser_config ), intent ( in ), optional :: config character ( len = :), allocatable :: string character ( 512 ) :: msg integer :: stat call toml_dumps ( val , string , error , config = config ) if ( allocated ( error )) return write ( io , '(a)' , iostat = stat , iomsg = msg ) string if ( stat /= 0 ) then call make_error ( error , trim ( msg )) return end if end subroutine toml_dump_to_unit !> Write string representation of JSON value to a file subroutine toml_dump_to_file ( val , filename , error , config ) !> TOML value to visit class ( toml_value ), intent ( inout ) :: val !> File name to write to character ( * ), intent ( in ) :: filename !> Error handling type ( toml_error ), allocatable , intent ( out ) :: error !> Configuration for serializer type ( toml_ser_config ), intent ( in ), optional :: config integer :: io integer :: stat character ( 512 ) :: msg open ( file = filename , newunit = io , iostat = stat , iomsg = msg ) if ( stat /= 0 ) then call make_error ( error , trim ( msg )) return end if call toml_dump ( val , io , error , config = config ) close ( unit = io , iostat = stat , iomsg = msg ) if (. not . allocated ( error ) . and . stat /= 0 ) then call make_error ( error , trim ( msg )) end if end subroutine toml_dump_to_file !> Constructor to create new serializer instance subroutine new_serializer ( self , config ) !> Instance of the TOML serializer type ( toml_serializer ), intent ( out ) :: self !> Configuration for serializer type ( toml_ser_config ), intent ( in ), optional :: config self % output = \"\" if ( present ( config )) self % config = config end subroutine new_serializer !> Default constructor for TOML serializer function new_serializer_func ( config ) result ( self ) !> Configuration for serializer type ( toml_ser_config ), intent ( in ), optional :: config !> Instance of the TOML serializer type ( toml_serializer ) :: self call new_serializer ( self , config ) end function new_serializer_func !> Visit a TOML value recursive subroutine visit ( self , val ) !> Instance of the TOML serializer class ( toml_serializer ), intent ( inout ) :: self !> TOML value to visit class ( toml_value ), intent ( inout ) :: val select type ( val ) class is ( toml_keyval ) call visit_keyval ( self , val ) class is ( toml_array ) call visit_array ( self , val ) class is ( toml_table ) call visit_table ( self , val ) end select end subroutine visit !> Visit a TOML key-value pair subroutine visit_keyval ( visitor , keyval ) !> Instance of the TOML serializer class ( toml_serializer ), intent ( inout ) :: visitor !> TOML value to visit type ( toml_keyval ), intent ( inout ) :: keyval character ( kind = tfc , len = :), allocatable :: key , str type ( toml_datetime ), pointer :: dval character (:, tfc ), pointer :: sval integer ( tfi ), pointer :: ival real ( tfr ), pointer :: rval logical , pointer :: lval call keyval % get_key ( key ) select case ( keyval % get_type ()) case ( toml_type % string ) call keyval % get ( sval ) call toml_escape_string ( sval , str ) case ( toml_type % int ) call keyval % get ( ival ) str = to_string ( ival ) case ( toml_type % float ) call keyval % get ( rval ) str = to_string ( rval ) case ( toml_type % boolean ) call keyval % get ( lval ) if ( lval ) then str = \"true\" else str = \"false\" end if case ( toml_type % datetime ) call keyval % get ( dval ) str = to_string ( dval ) end select if ( visitor % inline_array ) then visitor % output = visitor % output // \" \" end if visitor % output = visitor % output // key // \" = \" // str if (. not . visitor % inline_array ) then visitor % output = visitor % output // new_line ( 'a' ) end if end subroutine visit_keyval !> Visit a TOML array recursive subroutine visit_array ( visitor , array ) !> Instance of the TOML serializer class ( toml_serializer ), intent ( inout ) :: visitor !> TOML value to visit type ( toml_array ), intent ( inout ) :: array class ( toml_value ), pointer :: ptr character ( kind = tfc , len = :), allocatable :: key , str type ( toml_datetime ), pointer :: dval character (:, tfc ), pointer :: sval integer ( tfi ), pointer :: ival real ( tfr ), pointer :: rval logical , pointer :: lval integer :: i , n if ( visitor % inline_array ) visitor % output = visitor % output // \" [\" n = len ( array ) do i = 1 , n call array % get ( i , ptr ) select type ( ptr ) class is ( toml_keyval ) select case ( ptr % get_type ()) case ( toml_type % string ) call ptr % get ( sval ) call toml_escape_string ( sval , str ) case ( toml_type % int ) call ptr % get ( ival ) str = to_string ( ival ) case ( toml_type % float ) call ptr % get ( rval ) str = to_string ( rval ) case ( toml_type % boolean ) call ptr % get ( lval ) if ( lval ) then str = \"true\" else str = \"false\" end if case ( toml_type % datetime ) call ptr % get ( dval ) str = to_string ( dval ) end select visitor % output = visitor % output // \" \" // str if ( i /= n ) visitor % output = visitor % output // \",\" class is ( toml_array ) call ptr % accept ( visitor ) if ( i /= n ) visitor % output = visitor % output // \",\" class is ( toml_table ) if ( visitor % inline_array ) then visitor % output = visitor % output // \" {\" call ptr % accept ( visitor ) visitor % output = visitor % output // \" }\" if ( i /= n ) visitor % output = visitor % output // \",\" else visitor % array_of_tables = . true . if ( size ( visitor % stack , 1 ) <= visitor % top ) call resize ( visitor % stack ) visitor % top = visitor % top + 1 call array % get_key ( key ) visitor % stack ( visitor % top )% key = key call ptr % accept ( visitor ) deallocate ( visitor % stack ( visitor % top )% key ) visitor % top = visitor % top - 1 end if end select end do if ( visitor % inline_array ) visitor % output = visitor % output // \" ]\" end subroutine visit_array !> Visit a TOML table recursive subroutine visit_table ( visitor , table ) !> Instance of the TOML serializer class ( toml_serializer ), intent ( inout ) :: visitor !> TOML table to visit type ( toml_table ), intent ( inout ) :: table class ( toml_value ), pointer :: ptr type ( toml_key ), allocatable :: list (:) logical , allocatable :: defer (:) character ( kind = tfc , len = :), allocatable :: key integer :: i , n call table % get_keys ( list ) n = size ( list , 1 ) allocate ( defer ( n )) if (. not . allocated ( visitor % stack )) then call resize ( visitor % stack ) else if (. not .( visitor % inline_array . or . table % implicit )) then visitor % output = visitor % output // \"[\" if ( visitor % array_of_tables ) visitor % output = visitor % output // \"[\" do i = 1 , visitor % top - 1 visitor % output = visitor % output // visitor % stack ( i )% key // \".\" end do visitor % output = visitor % output // visitor % stack ( visitor % top )% key visitor % output = visitor % output // \"]\" if ( visitor % array_of_tables ) visitor % output = visitor % output // \"]\" visitor % output = visitor % output // new_line ( 'a' ) visitor % array_of_tables = . false . end if end if do i = 1 , n defer ( i ) = . false . call table % get ( list ( i )% key , ptr ) select type ( ptr ) class is ( toml_keyval ) call ptr % accept ( visitor ) if ( visitor % inline_array ) then if ( i /= n ) visitor % output = visitor % output // \",\" end if class is ( toml_array ) if ( visitor % inline_array ) then call ptr % get_key ( key ) visitor % output = visitor % output // \" \" // key // \" =\" call ptr % accept ( visitor ) if ( i /= n ) visitor % output = visitor % output // \",\" else if ( is_array_of_tables ( ptr )) then ! Array of tables open a new section ! -> cannot serialize them before all key-value pairs are done defer ( i ) = . true . else visitor % inline_array = . true . call ptr % get_key ( key ) visitor % output = visitor % output // key // \" =\" call ptr % accept ( visitor ) visitor % inline_array = . false . visitor % output = visitor % output // new_line ( 'a' ) end if end if class is ( toml_table ) ! Subtables open a new section ! -> cannot serialize them before all key-value pairs are done defer ( i ) = . true . end select end do do i = 1 , n if ( defer ( i )) then call table % get ( list ( i )% key , ptr ) select type ( ptr ) class is ( toml_keyval ) call ptr % accept ( visitor ) if ( visitor % inline_array ) then if ( i /= n ) visitor % output = visitor % output // \",\" end if class is ( toml_array ) if ( visitor % inline_array ) then call ptr % get_key ( key ) visitor % output = visitor % output // \" \" // key // \" =\" call ptr % accept ( visitor ) if ( i /= n ) visitor % output = visitor % output // \",\" else if ( is_array_of_tables ( ptr )) then call ptr % accept ( visitor ) else visitor % inline_array = . true . call ptr % get_key ( key ) visitor % output = visitor % output // key // \" =\" call ptr % accept ( visitor ) visitor % inline_array = . false . visitor % output = visitor % output // new_line ( 'a' ) end if end if class is ( toml_table ) if ( size ( visitor % stack , 1 ) <= visitor % top ) call resize ( visitor % stack ) visitor % top = visitor % top + 1 call ptr % get_key ( key ) visitor % stack ( visitor % top )% key = key call ptr % accept ( visitor ) deallocate ( visitor % stack ( visitor % top )% key ) visitor % top = visitor % top - 1 end select end if end do if (. not . visitor % inline_array . and . visitor % top == 0 ) then deallocate ( visitor % stack ) end if end subroutine visit_table !> Change size of the stack subroutine resize ( stack , n ) !> Stack of keys to be resized type ( toml_key ), allocatable , intent ( inout ) :: stack (:) !> New size of the stack integer , intent ( in ), optional :: n type ( toml_key ), allocatable :: tmp (:) integer :: m if ( present ( n )) then m = n else if ( allocated ( stack )) then m = size ( stack ) m = m + m / 2 + 1 else m = initial_size end if end if if ( allocated ( stack )) then call move_alloc ( stack , tmp ) allocate ( stack ( m )) m = min ( size ( tmp ), m ) stack (: m ) = tmp (: m ) deallocate ( tmp ) else allocate ( stack ( m )) end if end subroutine resize end module tomlf_ser","tags":"","url":"sourcefile/ser.f90.html"},{"title":"abc.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Defines the abstract base class which is implemented by the TOML lexer. module tomlf_de_abc use tomlf_constants , only : tfc , tfi , tfr use tomlf_datetime , only : toml_datetime use tomlf_de_token , only : toml_token implicit none private public :: abstract_lexer !> Abstract base class for TOML lexers. type , abstract :: abstract_lexer contains !> Obtain the next token procedure ( next ), deferred :: next !> Extract a token generic :: extract => & & extract_string , extract_integer , extract_float , extract_bool , extract_datetime !> Extract a string from a token procedure ( extract_string ), deferred :: extract_string !> Extract an integer from a token procedure ( extract_integer ), deferred :: extract_integer !> Extract a float from a token procedure ( extract_float ), deferred :: extract_float !> Extract a boolean from a token procedure ( extract_bool ), deferred :: extract_bool !> Extract a timestamp from a token procedure ( extract_datetime ), deferred :: extract_datetime !> Get information about the source procedure ( get_info ), deferred :: get_info end type abstract_lexer abstract interface !> Advance the lexer to the next token. subroutine next ( lexer , token ) import :: abstract_lexer , toml_token !> Instance of the lexer class ( abstract_lexer ), intent ( inout ) :: lexer !> Current lexeme type ( toml_token ), intent ( inout ) :: token end subroutine next !> Extract string value of token, works for keypath, string, multiline string, literal, !> and mulitline literal tokens. subroutine extract_string ( lexer , token , string ) import :: abstract_lexer , toml_token , tfc !> Instance of the lexer class ( abstract_lexer ), intent ( in ) :: lexer !> Token to extract string value from type ( toml_token ), intent ( in ) :: token !> String value of token character (:, tfc ), allocatable , intent ( out ) :: string end subroutine extract_string !> Extract integer value of token subroutine extract_integer ( lexer , token , val ) import :: abstract_lexer , toml_token , tfi !> Instance of the lexer class ( abstract_lexer ), intent ( in ) :: lexer !> Token to extract integer value from type ( toml_token ), intent ( in ) :: token !> Integer value of token integer ( tfi ), intent ( out ) :: val end subroutine extract_integer !> Extract floating point value of token subroutine extract_float ( lexer , token , val ) import :: abstract_lexer , toml_token , tfr !> Instance of the lexer class ( abstract_lexer ), intent ( in ) :: lexer !> Token to extract floating point value from type ( toml_token ), intent ( in ) :: token !> Floating point value of token real ( tfr ), intent ( out ) :: val end subroutine extract_float !> Extract boolean value of token subroutine extract_bool ( lexer , token , val ) import :: abstract_lexer , toml_token !> Instance of the lexer class ( abstract_lexer ), intent ( in ) :: lexer !> Token to extract boolean value from type ( toml_token ), intent ( in ) :: token !> Boolean value of token logical , intent ( out ) :: val end subroutine extract_bool !> Extract datetime value of token subroutine extract_datetime ( lexer , token , val ) import :: abstract_lexer , toml_token , toml_datetime !> Instance of the lexer class ( abstract_lexer ), intent ( in ) :: lexer !> Token to extract datetime value from type ( toml_token ), intent ( in ) :: token !> Datetime value of token type ( toml_datetime ), intent ( out ) :: val end subroutine extract_datetime !> Extract information about the source subroutine get_info ( lexer , meta , output ) import :: abstract_lexer , tfc !> Instance of the lexer class ( abstract_lexer ), intent ( in ) :: lexer !> Query about the source character ( * , tfc ), intent ( in ) :: meta !> Metadata about the source character (:, tfc ), allocatable , intent ( out ) :: output end subroutine get_info end interface end module tomlf_de_abc","tags":"","url":"sourcefile/abc.f90.html"},{"title":"utils.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. module tomlf_utils use tomlf_constants use tomlf_datetime , only : toml_datetime , toml_date , toml_time , to_string use tomlf_utils_io , only : read_whole_file , read_whole_line implicit none private public :: toml_escape_string public :: to_string public :: read_whole_file , read_whole_line interface to_string module procedure :: to_string_i1 module procedure :: to_string_i2 module procedure :: to_string_i4 module procedure :: to_string_i8 module procedure :: to_string_r8 end interface to_string contains !> Escape all special characters in a TOML string subroutine toml_escape_string ( raw , escaped , multiline ) !> Raw representation of TOML string character ( kind = tfc , len =* ), intent ( in ) :: raw !> Escaped view of the TOML string character ( kind = tfc , len = :), allocatable , intent ( out ) :: escaped !> Preserve newline characters logical , intent ( in ), optional :: multiline integer :: i logical :: preserve_newline preserve_newline = . false . if ( present ( multiline )) preserve_newline = multiline escaped = '\"' do i = 1 , len ( raw ) select case ( raw ( i : i )) case default ; escaped = escaped // raw ( i : i ) case ( '\\'); escaped = escaped // ' \\\\ ' case(' \"'); escaped = escaped // '\\\"' case(TOML_NEWLINE) if (preserve_newline) then escaped = escaped // raw(i:i) else escaped = escaped // '\\n' end if case(TOML_FORMFEED); escaped = escaped // '\\f' case(TOML_CARRIAGE_RETURN); escaped = escaped // '\\r' case(TOML_TABULATOR); escaped = escaped // '\\t' case(TOML_BACKSPACE); escaped = escaped // '\\b' end select end do escaped = escaped // '\" ' end subroutine toml_escape_string !> Represent an integer as character sequence. pure function to_string_i1(val) result(string) integer, parameter :: ik = tf_i1 !> Integer value to create string from integer(ik), intent(in) :: val !> String representation of integer character(len=:), allocatable :: string integer, parameter :: buffer_len = range(val)+2 character(len=buffer_len) :: buffer integer :: pos integer(ik) :: n character(len=1), parameter :: numbers(-9:0) = & [\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\", \"0\"] if (val == 0_ik) then string = numbers(0) return end if n = sign(val, -1_ik) buffer = \"\" pos = buffer_len + 1 do while (n < 0_ik) pos = pos - 1 buffer(pos:pos) = numbers(mod(n, 10_ik)) n = n/10_ik end do if (val < 0_ik) then pos = pos - 1 buffer(pos:pos) = ' - ' end if string = buffer(pos:) end function to_string_i1 !> Represent an integer as character sequence. pure function to_string_i2(val) result(string) integer, parameter :: ik = tf_i2 !> Integer value to create string from integer(ik), intent(in) :: val !> String representation of integer character(len=:), allocatable :: string integer, parameter :: buffer_len = range(val)+2 character(len=buffer_len) :: buffer integer :: pos integer(ik) :: n character(len=1), parameter :: numbers(-9:0) = & [\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\", \"0\"] if (val == 0_ik) then string = numbers(0) return end if n = sign(val, -1_ik) buffer = \"\" pos = buffer_len + 1 do while (n < 0_ik) pos = pos - 1 buffer(pos:pos) = numbers(mod(n, 10_ik)) n = n/10_ik end do if (val < 0_ik) then pos = pos - 1 buffer(pos:pos) = ' - ' end if string = buffer(pos:) end function to_string_i2 !> Represent an integer as character sequence. pure function to_string_i4(val) result(string) integer, parameter :: ik = tf_i4 !> Integer value to create string from integer(ik), intent(in) :: val !> String representation of integer character(len=:), allocatable :: string integer, parameter :: buffer_len = range(val)+2 character(len=buffer_len) :: buffer integer :: pos integer(ik) :: n character(len=1), parameter :: numbers(-9:0) = & [\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\", \"0\"] if (val == 0_ik) then string = numbers(0) return end if n = sign(val, -1_ik) buffer = \"\" pos = buffer_len + 1 do while (n < 0_ik) pos = pos - 1 buffer(pos:pos) = numbers(mod(n, 10_ik)) n = n/10_ik end do if (val < 0_ik) then pos = pos - 1 buffer(pos:pos) = ' - ' end if string = buffer(pos:) end function to_string_i4 !> Represent an integer as character sequence. pure function to_string_i8(val) result(string) integer, parameter :: ik = tf_i8 !> Integer value to create string from integer(ik), intent(in) :: val !> String representation of integer character(len=:), allocatable :: string integer, parameter :: buffer_len = range(val)+2 character(len=buffer_len) :: buffer integer :: pos integer(ik) :: n character(len=1), parameter :: numbers(-9:0) = & [\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\", \"0\"] if (val == 0_ik) then string = numbers(0) return end if n = sign(val, -1_ik) buffer = \"\" pos = buffer_len + 1 do while (n < 0_ik) pos = pos - 1 buffer(pos:pos) = numbers(mod(n, 10_ik)) n = n/10_ik end do if (val < 0_ik) then pos = pos - 1 buffer(pos:pos) = ' - ' end if string = buffer(pos:) end function to_string_i8 !> Represent an real as character sequence. pure function to_string_r8(val) result(string) integer, parameter :: rk = tfr !> Real value to create string from real(rk), intent(in) :: val !> String representation of integer character(len=:), allocatable :: string character(128, tfc) :: buffer if (val > huge(val)) then string = \"+inf\" else if (val < -huge(val)) then string = \"-inf\" else if (val /= val) then string = \"nan\" else if (abs(val) >= 1.0e+100_rk) then write(buffer, ' ( es24 . 1 6e3 ) ') val else if (abs(val) >= 1.0e+10_rk) then write(buffer, ' ( es24 . 1 6e2 ) ') val else if (abs(val) >= 1.0e+3_rk) then write(buffer, ' ( es24 . 1 6e1 ) ') val else write(buffer, ' ( f24 . 16 ) ' ) val end if string = trim ( adjustl ( buffer )) end if end function to_string_r8 end module tomlf_utils","tags":"","url":"sourcefile/utils.f90.html"},{"title":"parser.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Implementation of a parser for transforming a token stream to TOML datastructures. module tomlf_de_parser use tomlf_constants , only : tfc , tfr , tfi , TOML_NEWLINE use tomlf_datetime , only : toml_datetime use tomlf_de_context , only : toml_context use tomlf_de_abc , only : toml_lexer => abstract_lexer use tomlf_de_token , only : toml_token , token_kind , stringify use tomlf_diagnostic , only : render , toml_diagnostic , toml_label , toml_level use tomlf_terminal , only : toml_terminal use tomlf_error , only : toml_error , toml_stat use tomlf_type , only : toml_table , toml_array , toml_keyval , toml_value , toml_key , & & add_table , add_array , add_keyval , cast_to_table , cast_to_array , len implicit none private public :: toml_parser , toml_parser_config , parse !> Configuration of the TOML parser type :: toml_parser_config !> Use colorful output for diagnostics type ( toml_terminal ) :: color = toml_terminal () !> Record all tokens integer :: context_detail = 0 end type toml_parser_config interface toml_parser_config module procedure :: new_parser_config end interface toml_parser_config !> TOML parser type :: toml_parser !> Current token type ( toml_token ) :: token !> Table containing the document root type ( toml_table ), allocatable :: root !> Pointer to the currently processed table type ( toml_table ), pointer :: current !> Diagnostic produced while parsing type ( toml_diagnostic ), allocatable :: diagnostic !> Context for producing diagnostics type ( toml_context ) :: context !> Configuration of the parser type ( toml_parser_config ) :: config end type toml_parser contains !> Create a new instance of the TOML parser subroutine new_parser ( parser , config ) !> Instance of the parser type ( toml_parser ), intent ( out ), target :: parser !> Configuration of the parser type ( toml_parser_config ), intent ( in ), optional :: config parser % token = toml_token ( token_kind % newline , 0 , 0 ) parser % root = toml_table () parser % current => parser % root parser % config = toml_parser_config () if ( present ( config )) parser % config = config end subroutine new_parser !> Create new configuration for the TOML parser pure function new_parser_config ( color , context_detail ) result ( config ) !> Configuration of the parser type ( toml_parser_config ) :: config !> Color support for diagnostics logical , intent ( in ), optional :: color !> Record all tokens integer , intent ( in ), optional :: context_detail if ( present ( color )) config % color = toml_terminal ( color ) if ( present ( context_detail )) config % context_detail = context_detail end function new_parser_config !> Parse TOML document and return root table subroutine parse ( lexer , table , config , context , error ) !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> TOML data structure type ( toml_table ), allocatable , intent ( out ) :: table !> Configuration for the parser type ( toml_parser_config ), intent ( in ), optional :: config !> Context tracking the origin of the data structure to allow rich reports type ( toml_context ), intent ( out ), optional :: context !> Error handler type ( toml_error ), allocatable , intent ( out ), optional :: error type ( toml_parser ) :: parser call new_parser ( parser , config ) call parse_root ( parser , lexer ) if ( present ( error ) . and . allocated ( parser % diagnostic )) then call make_error ( error , parser % diagnostic , lexer , parser % config % color ) end if if ( allocated ( parser % diagnostic )) return call move_alloc ( parser % root , table ) if ( present ( context )) then context = parser % context call lexer % get_info ( \"filename\" , context % filename ) call lexer % get_info ( \"source\" , context % source ) end if end subroutine parse !> Parse the root table subroutine parse_root ( parser , lexer ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer do while (. not . allocated ( parser % diagnostic ) . and . parser % token % kind /= token_kind % eof ) select case ( parser % token % kind ) case ( token_kind % newline , token_kind % whitespace , token_kind % comment ) call next_token ( parser , lexer ) case ( token_kind % keypath , token_kind % string , token_kind % literal ) call parse_keyval ( parser , lexer , parser % current ) case ( token_kind % lbracket ) call parse_table_header ( parser , lexer ) case default call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Invalid syntax\" , & & \"unexpected \" // stringify ( parser % token )) end select end do end subroutine parse_root !> Parse a table or array of tables header subroutine parse_table_header ( parser , lexer ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer type ( toml_array ), pointer :: array type ( toml_table ), pointer :: table class ( toml_value ), pointer :: ptr type ( toml_key ) :: key logical :: array_of_tables integer , parameter :: initial_size = 8 integer :: top type ( toml_key ), allocatable :: stack (:) type ( toml_token ), allocatable :: leading_whitespace , trailing_whitespace call consume ( parser , lexer , token_kind % lbracket ) if ( allocated ( parser % diagnostic )) return if ( parser % token % kind == token_kind % whitespace ) then leading_whitespace = parser % token call next_token ( parser , lexer ) end if array_of_tables = parser % token % kind == token_kind % lbracket if ( array_of_tables ) then call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % whitespace ) then call next_token ( parser , lexer ) end if end if call fill_stack ( lexer , parser , top , stack ) if ( allocated ( parser % diagnostic )) return key = stack ( top ) top = top - 1 call walk_stack ( parser , top , stack ) if ( array_of_tables ) then call parser % current % get ( key % key , ptr ) if ( associated ( ptr )) then array => cast_to_array ( ptr ) if (. not . associated ( array )) then call duplicate_key_error ( parser % diagnostic , lexer , & & parser % context % token ( key % origin ), & & parser % context % token ( ptr % origin ), & & \"Key '\" // key % key // \"' already exists\" ) return end if if ( array % inline ) then call semantic_error ( parser % diagnostic , lexer , & & parser % context % token ( key % origin ), & & parser % context % token ( array % origin ), & & \"Array of tables cannot extend inline array\" , & & \"extended here\" , & & \"defined as inline\" ) return end if else call add_array ( parser % current , key , array ) array % inline = . false . end if call add_table ( array , table ) else call parser % current % get ( key % key , ptr ) if ( associated ( ptr )) then table => cast_to_table ( ptr ) if ( associated ( table )) then if (. not . table % implicit ) nullify ( table ) end if if (. not . associated ( table )) then call duplicate_key_error ( parser % diagnostic , lexer , & & parser % context % token ( key % origin ), & & parser % context % token ( ptr % origin ), & & \"Key '\" // key % key // \"' already exists\" ) return end if else call add_table ( parser % current , key , table ) end if end if parser % current => table call consume ( parser , lexer , token_kind % rbracket ) if ( allocated ( parser % diagnostic )) return if ( array_of_tables ) then if ( parser % token % kind == token_kind % whitespace ) then trailing_whitespace = parser % token call next_token ( parser , lexer ) end if call consume ( parser , lexer , token_kind % rbracket ) if ( allocated ( parser % diagnostic )) return end if if ( array_of_tables . and . allocated ( leading_whitespace )) then call syntax_error ( parser % diagnostic , lexer , leading_whitespace , & & \"Malformatted array of table header encountered\" , & & \"whitespace not allowed in header\" ) return end if if ( array_of_tables . and . allocated ( trailing_whitespace )) then call syntax_error ( parser % diagnostic , lexer , trailing_whitespace , & & \"Malformatted array of table header encountered\" , & & \"whitespace not allowed in header\" ) return end if do while ( parser % token % kind == token_kind % whitespace ) call next_token ( parser , lexer ) end do if ( parser % token % kind == token_kind % comment ) then call next_token ( parser , lexer ) end if if ( all ( parser % token % kind /= [ token_kind % newline , token_kind % eof ])) then call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Unexpected \" // stringify ( parser % token ) // \" after table header\" , & & \"expected newline\" ) end if contains !> Fill the stack with tokens subroutine fill_stack ( lexer , parser , top , stack ) class ( toml_lexer ), intent ( inout ) :: lexer type ( toml_parser ), intent ( inout ) :: parser !> Depth of the table key stack integer , intent ( out ) :: top !> Stack of all keys in the table header type ( toml_key ), allocatable , intent ( out ) :: stack (:) top = 0 allocate ( stack ( initial_size )) do if ( top >= size ( stack )) then call resize ( stack ) end if if ( all ( parser % token % kind /= [ token_kind % string , token_kind % literal , & & token_kind % keypath ])) then call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Missing key for table header\" , & & \"unexpected \" // stringify ( parser % token )) return end if top = top + 1 call extract_key ( parser , lexer , stack ( top )) call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % whitespace ) & & call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % rbracket ) exit call consume ( parser , lexer , token_kind % dot ) if ( allocated ( parser % diagnostic )) return if ( parser % token % kind == token_kind % whitespace ) & & call next_token ( parser , lexer ) end do if ( top <= 0 ) then call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Empty table header\" , & & \"expected table header\" ) end if end subroutine fill_stack !> Walk the key stack to fetch the correct table, create implicit tables as necessary subroutine walk_stack ( parser , top , stack ) type ( toml_parser ), intent ( inout ), target :: parser !> Depth of the table key stack integer , intent ( in ) :: top !> Stack of all keys in the table header type ( toml_key ), intent ( in ), target :: stack (:) type ( toml_table ), pointer :: table , tmp_tbl type ( toml_array ), pointer :: array type ( toml_key ), pointer :: key class ( toml_value ), pointer :: ptr integer :: it table => parser % root do it = 1 , top key => stack ( it ) if (. not . table % has_key ( key % key )) then call add_table ( table , key , tmp_tbl ) if ( associated ( tmp_tbl )) then tmp_tbl % implicit = . true . end if end if call table % get ( key % key , ptr ) table => cast_to_table ( ptr ) if (. not . associated ( table )) then array => cast_to_array ( ptr ) if ( associated ( array )) then call array % get ( len ( array ), ptr ) table => cast_to_table ( ptr ) end if if (. not . associated ( table )) then call duplicate_key_error ( parser % diagnostic , lexer , & & parser % context % token ( key % origin ), & & parser % context % token ( ptr % origin ), & & \"Key '\" // key % key // \"' already exists\" ) return end if end if if ( table % inline ) then call semantic_error ( parser % diagnostic , lexer , & & parser % context % token ( key % origin ), & & parser % context % token ( table % origin ), & & \"Inline table '\" // key % key // \"' cannot be used as a key\" , & & \"inline table cannot be extended\" , & & \"defined as inline first\" ) end if end do parser % current => table end subroutine walk_stack !> Change size of the stack subroutine resize ( stack , n ) !> Stack of keys to be resized type ( toml_key ), allocatable , intent ( inout ) :: stack (:) !> New size of the stack integer , intent ( in ), optional :: n type ( toml_key ), allocatable :: tmp (:) integer :: m if ( present ( n )) then m = n else if ( allocated ( stack )) then m = size ( stack ) m = m + m / 2 + 1 else m = initial_size end if end if if ( allocated ( stack )) then call move_alloc ( stack , tmp ) allocate ( stack ( m )) m = min ( size ( tmp ), m ) stack (: m ) = tmp (: m ) deallocate ( tmp ) else allocate ( stack ( m )) end if end subroutine resize end subroutine parse_table_header !> Parse key value pairs in a table body recursive subroutine parse_keyval ( parser , lexer , table ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> Current table type ( toml_table ), intent ( inout ) :: table class ( toml_value ), pointer :: ptr type ( toml_keyval ), pointer :: vptr type ( toml_array ), pointer :: aptr type ( toml_table ), pointer :: tptr type ( toml_key ) :: key call extract_key ( parser , lexer , key ) call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % whitespace ) & call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % dot ) then call get_table ( table , key , tptr ) if ( tptr % inline ) then call semantic_error ( parser % diagnostic , lexer , & & parser % context % token ( key % origin ), & & parser % context % token ( tptr % origin ), & & \"Cannot add keys to inline tables\" , & & \"inline table cannot be extended\" , & & \"defined as inline first\" ) return end if call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % whitespace ) & call next_token ( parser , lexer ) if ( any ( parser % token % kind == [ token_kind % keypath , token_kind % string , & & token_kind % literal ])) then call parse_keyval ( parser , lexer , tptr ) else call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Invalid syntax\" , & & \"expected key\" ) end if return end if call consume ( parser , lexer , token_kind % equal ) if ( allocated ( parser % diagnostic )) return if ( parser % token % kind == token_kind % whitespace ) & call next_token ( parser , lexer ) call table % get ( key % key , ptr ) if ( associated ( ptr )) then call duplicate_key_error ( parser % diagnostic , lexer , & & parser % context % token ( key % origin ), & & parser % context % token ( ptr % origin ), & & \"Key '\" // key % key // \"' already exists\" ) return end if select case ( parser % token % kind ) case default call add_keyval ( table , key , vptr ) call parse_value ( parser , lexer , vptr ) case ( token_kind % nil ) call next_token ( parser , lexer ) case ( token_kind % lbracket ) call add_array ( table , key , aptr ) call parse_inline_array ( parser , lexer , aptr ) case ( token_kind % lbrace ) call add_table ( table , key , tptr ) call parse_inline_table ( parser , lexer , tptr ) end select if ( allocated ( parser % diagnostic )) return if ( parser % token % kind == token_kind % whitespace ) & call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % comment ) & call next_token ( parser , lexer ) end subroutine parse_keyval recursive subroutine parse_inline_array ( parser , lexer , array ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> Current array type ( toml_array ), intent ( inout ) :: array type ( toml_keyval ), pointer :: vptr type ( toml_array ), pointer :: aptr type ( toml_table ), pointer :: tptr integer , parameter :: skip_tokens ( * ) = & [ token_kind % whitespace , token_kind % comment , token_kind % newline ] array % inline = . true . call consume ( parser , lexer , token_kind % lbracket ) inline_array : do while (. not . allocated ( parser % diagnostic )) do while ( any ( parser % token % kind == skip_tokens )) call next_token ( parser , lexer ) end do select case ( parser % token % kind ) case ( token_kind % rbracket ) exit inline_array case default call add_keyval ( array , vptr ) call parse_value ( parser , lexer , vptr ) case ( token_kind % nil ) call next_token ( parser , lexer ) case ( token_kind % lbracket ) call add_array ( array , aptr ) call parse_inline_array ( parser , lexer , aptr ) case ( token_kind % lbrace ) call add_table ( array , tptr ) call parse_inline_table ( parser , lexer , tptr ) end select if ( allocated ( parser % diagnostic )) exit inline_array do while ( any ( parser % token % kind == skip_tokens )) call next_token ( parser , lexer ) end do if ( parser % token % kind == token_kind % comma ) then call next_token ( parser , lexer ) cycle inline_array end if exit inline_array end do inline_array if ( allocated ( parser % diagnostic )) return call consume ( parser , lexer , token_kind % rbracket ) end subroutine parse_inline_array recursive subroutine parse_inline_table ( parser , lexer , table ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> Current table type ( toml_table ), intent ( inout ) :: table table % inline = . true . call consume ( parser , lexer , token_kind % lbrace ) if ( parser % token % kind == token_kind % whitespace ) & call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % rbrace ) then call next_token ( parser , lexer ) return end if inline_table : do while (. not . allocated ( parser % diagnostic )) if ( parser % token % kind == token_kind % whitespace ) & call next_token ( parser , lexer ) select case ( parser % token % kind ) case default call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Invalid character in inline table\" , & & \"unexpected \" // stringify ( parser % token )) case ( token_kind % keypath , token_kind % string , token_kind % literal ) call parse_keyval ( parser , lexer , table ) end select if ( allocated ( parser % diagnostic )) exit inline_table if ( parser % token % kind == token_kind % whitespace ) & call next_token ( parser , lexer ) if ( parser % token % kind == token_kind % comma ) then call next_token ( parser , lexer ) cycle inline_table end if if ( parser % token % kind == token_kind % rbrace ) exit inline_table end do inline_table if ( allocated ( parser % diagnostic )) return call consume ( parser , lexer , token_kind % rbrace ) end subroutine parse_inline_table subroutine parse_value ( parser , lexer , kval ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> Current key value pair type ( toml_keyval ), intent ( inout ) :: kval select case ( parser % token % kind ) case default call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Invalid expression for value\" , & & \"unexpected \" // stringify ( parser % token )) case ( token_kind % unclosed ) ! Handle runaway expressions separately call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Inline expression contains unclosed or runaway group\" , & & \"unclosed inline expression\" ) case ( token_kind % string , token_kind % mstring , token_kind % literal , token_kind % mliteral , & & token_kind % int , token_kind % float , token_kind % bool , token_kind % datetime ) call extract_value ( parser , lexer , kval ) call next_token ( parser , lexer ) end select end subroutine parse_value !> Check whether the current token is the expected one and advance the lexer subroutine consume ( parser , lexer , kind ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> Expected token kind integer , intent ( in ) :: kind if ( parser % token % kind /= kind ) then call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Invalid syntax in this context\" , & & \"expected \" // stringify ( toml_token ( kind ))) return end if call next_token ( parser , lexer ) end subroutine consume !> Create diagnostic for invalid syntax subroutine syntax_error ( diagnostic , lexer , token , message , label ) !> Diagnostic for the syntax error type ( toml_diagnostic ), allocatable , intent ( out ) :: diagnostic !> Instance of the lexer providing the context class ( toml_lexer ), intent ( inout ) :: lexer !> Token that caused the error type ( toml_token ), intent ( in ) :: token !> Message for the error character ( len =* ), intent ( in ) :: message !> Label for the token character ( len =* ), intent ( in ) :: label character (:, tfc ), allocatable :: filename call lexer % get_info ( \"filename\" , filename ) allocate ( diagnostic ) diagnostic = toml_diagnostic ( & & toml_level % error , & & message , & & filename , & & [ toml_label ( toml_level % error , token % first , token % last , label , . true .)]) end subroutine syntax_error !> Create diagnostic for incorrect semantics subroutine semantic_error ( diagnostic , lexer , token1 , token2 , message , label1 , label2 ) !> Diagnostic for the duplicate key error type ( toml_diagnostic ), allocatable , intent ( out ) :: diagnostic !> Instance of the lexer providing the context class ( toml_lexer ), intent ( inout ) :: lexer !> Token identifying the duplicate key type ( toml_token ), intent ( in ) :: token1 !> Token identifying the original key type ( toml_token ), intent ( in ) :: token2 !> Message for the error character ( len =* ), intent ( in ) :: message !> Label for the first token character ( len =* ), intent ( in ) :: label1 !> Label for the second token character ( len =* ), intent ( in ) :: label2 character (:, tfc ), allocatable :: filename call lexer % get_info ( \"filename\" , filename ) allocate ( diagnostic ) diagnostic = toml_diagnostic ( & & toml_level % error , & & message , & & filename , & & [ toml_label ( toml_level % error , token1 % first , token1 % last , label1 , . true .), & & toml_label ( toml_level % info , token2 % first , token2 % last , label2 , . false .)]) end subroutine semantic_error !> Create a diagnostic for a duplicate key entry subroutine duplicate_key_error ( diagnostic , lexer , token1 , token2 , message ) !> Diagnostic for the duplicate key error type ( toml_diagnostic ), allocatable , intent ( out ) :: diagnostic !> Instance of the lexer providing the context class ( toml_lexer ), intent ( inout ) :: lexer !> Token identifying the duplicate key type ( toml_token ), intent ( in ) :: token1 !> Token identifying the original key type ( toml_token ), intent ( in ) :: token2 !> Message for the error character ( len =* ), intent ( in ) :: message call semantic_error ( diagnostic , lexer , token1 , token2 , & & message , \"key already used\" , \"first defined here\" ) end subroutine duplicate_key_error !> Create an error from a diagnostic subroutine make_error ( error , diagnostic , lexer , color ) !> Error to be created type ( toml_error ), allocatable , intent ( out ) :: error !> Diagnostic to be used type ( toml_diagnostic ), intent ( in ) :: diagnostic !> Instance of the lexer providing the context class ( toml_lexer ), intent ( in ) :: lexer !> Use colorful error messages type ( toml_terminal ), intent ( in ) :: color character ( len = :), allocatable :: str allocate ( error ) call lexer % get_info ( \"source\" , str ) error % message = render ( diagnostic , str , color ) error % stat = toml_stat % fatal end subroutine make_error !> Wrapper around the lexer to retrieve the next token. !> Allows to record the tokens for keys and values in the parser context subroutine next_token ( parser , lexer ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer call lexer % next ( parser % token ) select case ( parser % token % kind ) case ( token_kind % keypath , token_kind % string , token_kind % literal , token_kind % int , & & token_kind % float , token_kind % bool , token_kind % datetime ) call parser % context % push_back ( parser % token ) case ( token_kind % newline , token_kind % dot , token_kind % comma , token_kind % equal , & & token_kind % lbrace , token_kind % rbrace , token_kind % lbracket , token_kind % rbracket ) if ( parser % config % context_detail > 0 ) & call parser % context % push_back ( parser % token ) case default if ( parser % config % context_detail > 1 ) & call parser % context % push_back ( parser % token ) end select end subroutine next_token !> Extract key from token subroutine extract_key ( parser , lexer , key ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> Key to be extracted type ( toml_key ), intent ( out ) :: key call lexer % extract ( parser % token , key % key ) key % origin = parser % context % top if ( scan ( key % key , TOML_NEWLINE ) > 0 ) then call syntax_error ( parser % diagnostic , lexer , parser % token , & & \"Invalid character in key\" , & & \"key cannot contain newline\" ) return end if end subroutine extract_key !> Extract value from token subroutine extract_value ( parser , lexer , kval ) !> Instance of the parser class ( toml_parser ), intent ( inout ) :: parser !> Instance of the lexer class ( toml_lexer ), intent ( inout ) :: lexer !> Value to be extracted type ( toml_keyval ), intent ( inout ) :: kval character (:, tfc ), allocatable :: sval real ( tfr ) :: rval integer ( tfi ) :: ival logical :: bval type ( toml_datetime ) :: dval kval % origin_value = parser % context % top select case ( parser % token % kind ) case ( token_kind % string , token_kind % literal , token_kind % mstring , token_kind % mliteral ) call lexer % extract_string ( parser % token , sval ) call kval % set ( sval ) case ( token_kind % int ) call lexer % extract_integer ( parser % token , ival ) call kval % set ( ival ) case ( token_kind % float ) call lexer % extract_float ( parser % token , rval ) call kval % set ( rval ) case ( token_kind % bool ) call lexer % extract_bool ( parser % token , bval ) call kval % set ( bval ) case ( token_kind % datetime ) call lexer % extract_datetime ( parser % token , dval ) call kval % set ( dval ) end select end subroutine extract_value !> Try to retrieve TOML table with key or create it subroutine get_table ( table , key , ptr , stat ) !> Instance of the TOML table class ( toml_table ), intent ( inout ) :: table !> Key for the new table type ( toml_key ), intent ( in ) :: key !> Pointer to the newly created table type ( toml_table ), pointer , intent ( out ) :: ptr !> Status of operation integer , intent ( out ), optional :: stat class ( toml_value ), pointer :: tmp nullify ( ptr ) call table % get ( key % key , tmp ) if ( associated ( tmp )) then ptr => cast_to_table ( tmp ) if ( present ( stat )) stat = merge ( toml_stat % success , toml_stat % fatal , associated ( ptr )) else call add_table ( table , key , ptr , stat ) end if end subroutine get_table end module tomlf_de_parser","tags":"","url":"sourcefile/parser.f90.html"},{"title":"list.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Abstract base class definitions for data structures to store TOML values module tomlf_structure_list use tomlf_constants , only : tfc use tomlf_type_value , only : toml_value , toml_key implicit none private public :: toml_list_structure !> Ordered data structure, allows iterations type , abstract :: toml_list_structure contains !> Get number of TOML values in the structure procedure ( get_len ), deferred :: get_len !> Push back a TOML value to the structure procedure ( push_back ), deferred :: push_back !> Remove the first element from the structure procedure ( shift ), deferred :: shift !> Remove the last element from the structure procedure ( pop ), deferred :: pop !> Get TOML value at a given index procedure ( get ), deferred :: get !> Destroy the data structure procedure ( destroy ), deferred :: destroy end type toml_list_structure abstract interface !> Get number of TOML values in the structure pure function get_len ( self ) result ( length ) import :: toml_list_structure !> Instance of the structure class ( toml_list_structure ), intent ( in ), target :: self !> Current length of the ordered structure integer :: length end function get_len !> Get TOML value at a given index subroutine get ( self , idx , ptr ) import :: toml_list_structure , toml_value !> Instance of the structure class ( toml_list_structure ), intent ( inout ), target :: self !> Position in the ordered structure integer , intent ( in ) :: idx !> Pointer to the stored value at given index class ( toml_value ), pointer , intent ( out ) :: ptr end subroutine get !> Push back a TOML value to the structure subroutine push_back ( self , val ) import :: toml_list_structure , toml_value !> Instance of the structure class ( toml_list_structure ), intent ( inout ), target :: self !> TOML value to be stored class ( toml_value ), allocatable , intent ( inout ) :: val end subroutine push_back !> Remove the first element from the data structure subroutine shift ( self , val ) import :: toml_list_structure , toml_value !> Instance of the structure class ( toml_list_structure ), intent ( inout ), target :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val end subroutine shift !> Remove the last element from the data structure subroutine pop ( self , val ) import :: toml_list_structure , toml_value !> Instance of the structure class ( toml_list_structure ), intent ( inout ), target :: self !> TOML value to be retrieved class ( toml_value ), allocatable , intent ( out ) :: val end subroutine pop !> Delete TOML value at a given key subroutine delete ( self , key ) import :: toml_list_structure , toml_value , tfc !> Instance of the structure class ( toml_list_structure ), intent ( inout ), target :: self !> Key to the TOML value character ( kind = tfc , len =* ), intent ( in ) :: key end subroutine delete !> Deconstructor for data structure subroutine destroy ( self ) import :: toml_list_structure !> Instance of the structure class ( toml_list_structure ), intent ( inout ), target :: self end subroutine destroy end interface end module tomlf_structure_list","tags":"","url":"sourcefile/list.f90.html"},{"title":"context.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Provides a container to store tokens for later use module tomlf_de_context use tomlf_constants , only : tfc use tomlf_de_token , only : toml_token , resize use tomlf_diagnostic , only : toml_diagnostic , toml_label , render , toml_level use tomlf_terminal , only : toml_terminal implicit none private public :: toml_context !> Container storing tokens type :: toml_context !> Filename of the input character (:, tfc ), allocatable :: filename !> Actual source character (:, tfc ), allocatable :: source !> Stack of stored tokens type ( toml_token ), allocatable :: token (:) !> Last stored token integer :: top = 0 contains !> Push a new token to the stack procedure :: push_back !> Create a report generic :: report => report1 , report2 !> Create a report with a single label procedure :: report1 !> Create a report with a two labels procedure :: report2 end type toml_context contains !> Push a new token to the stack subroutine push_back ( self , token ) !> Instance of the token storage class ( toml_context ), intent ( inout ) :: self !> New token to be added type ( toml_token ), intent ( in ) :: token if (. not . allocated ( self % token )) call resize ( self % token ) if ( self % top >= size ( self % token )) call resize ( self % token ) self % top = self % top + 1 self % token ( self % top ) = token end subroutine push_back !> Create a report with a single label pure function report1 ( self , message , origin , label , level , color ) result ( string ) !> Instance of the token storage class ( toml_context ), intent ( in ) :: self !> Message for the report character ( * , tfc ), intent ( in ) :: message !> Position to report at integer , intent ( in ) :: origin !> String for the label character ( * , tfc ), intent ( in ), optional :: label !> Highlight level integer , intent ( in ), optional :: level !> Color terminal type ( toml_terminal ), intent ( in ), optional :: color !> Final rendered report character (:, tfc ), allocatable :: string type ( toml_diagnostic ) :: diagnostic type ( toml_label ), allocatable :: labels (:) integer :: level_ level_ = toml_level % error if ( present ( level )) level_ = level if ( origin > 0 . and . origin <= self % top ) then allocate ( labels ( 1 )) labels ( 1 ) = toml_label ( level_ , & & self % token ( origin )% first , self % token ( origin )% last , label , . true .) end if diagnostic = toml_diagnostic ( & & level_ , & & message , & & self % filename , & & labels ) if (. not . present ( color )) then string = render ( diagnostic , self % source , toml_terminal (. false .)) else string = render ( diagnostic , self % source , color ) end if end function report1 !> Create a report with two labels pure function report2 ( self , message , origin1 , origin2 , label1 , label2 , level1 , level2 , color ) & & result ( string ) !> Instance of the token storage class ( toml_context ), intent ( in ) :: self !> Message for the report character ( * , tfc ), intent ( in ) :: message !> Position to report at integer , intent ( in ) :: origin1 , origin2 !> String for the label character ( * , tfc ), intent ( in ), optional :: label1 , label2 !> Highlight level integer , intent ( in ), optional :: level1 , level2 !> Color terminal type ( toml_terminal ), intent ( in ), optional :: color !> Final rendered report character (:, tfc ), allocatable :: string type ( toml_diagnostic ) :: diagnostic type ( toml_label ), allocatable :: labels (:) integer :: level1_ , level2_ level1_ = toml_level % error if ( present ( level1 )) level1_ = level1 level2_ = toml_level % info if ( present ( level2 )) level2_ = level2 if ( origin1 > 0 . and . origin1 <= self % top & & . and . origin2 > 0 . and . origin2 <= self % top ) then allocate ( labels ( 2 )) labels ( 1 ) = toml_label ( level1_ , & & self % token ( origin1 )% first , self % token ( origin1 )% last , label1 , . true .) labels ( 2 ) = toml_label ( level2_ , & & self % token ( origin2 )% first , self % token ( origin2 )% last , label2 , . false .) end if diagnostic = toml_diagnostic ( & & level1_ , & & message , & & self % filename , & & labels ) if (. not . present ( color )) then string = render ( diagnostic , self % source , toml_terminal (. false .)) else string = render ( diagnostic , self % source , color ) end if end function report2 end module tomlf_de_context","tags":"","url":"sourcefile/context.f90.html"},{"title":"sort.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Sorting algorithms to work with hash maps module tomlf_utils_sort use tomlf_type_value , only : toml_key implicit none private public :: sort , compare_less !> Create overloaded interface for export interface sort module procedure :: sort_keys end interface abstract interface !> Define order relation between two TOML keys pure function compare_less ( lhs , rhs ) result ( less ) import :: toml_key !> Left hand side TOML key in comparison type ( toml_key ), intent ( in ) :: lhs !> Right hand side TOML key in comparison type ( toml_key ), intent ( in ) :: rhs !> Comparison result logical :: less end function compare_less end interface contains !> Entry point for sorting algorithm pure subroutine sort_keys ( list , idx , compare ) !> List of TOML keys to be sorted type ( toml_key ), intent ( inout ) :: list (:) !> Optionally, mapping from unsorted list to sorted list integer , intent ( out ), optional :: idx (:) !> Function implementing the order relation between two TOML keys procedure ( compare_less ), optional :: compare integer :: low , high , i type ( toml_key ), allocatable :: sorted (:) integer , allocatable :: indexarray (:) low = 1 high = size ( list ) allocate ( sorted , source = list ) allocate ( indexarray ( high ), source = [( i , i = low , high )]) if ( present ( compare )) then call quicksort ( sorted , indexarray , low , high , compare ) else call quicksort ( sorted , indexarray , low , high , compare_keys_less ) end if do i = low , high list ( i ) = sorted ( indexarray ( i )) end do if ( present ( idx )) then idx = indexarray end if end subroutine sort_keys !> Actual quick sort implementation pure recursive subroutine quicksort ( list , idx , low , high , less ) type ( toml_key ), intent ( inout ) :: list (:) integer , intent ( inout ) :: idx (:) integer , intent ( in ) :: low , high procedure ( compare_less ) :: less integer :: i , last integer :: pivot if ( low < high ) then call swap ( idx ( low ), idx (( low + high ) / 2 )) last = low do i = low + 1 , high if ( less ( list ( idx ( i )), list ( idx ( low )))) then last = last + 1 call swap ( idx ( last ), idx ( i )) end if end do call swap ( idx ( low ), idx ( last )) pivot = last call quicksort ( list , idx , low , pivot - 1 , less ) call quicksort ( list , idx , pivot + 1 , high , less ) end if end subroutine quicksort !> Swap two integer values pure subroutine swap ( lhs , rhs ) integer , intent ( inout ) :: lhs integer , intent ( inout ) :: rhs integer :: tmp tmp = lhs lhs = rhs rhs = tmp end subroutine swap !> Default comparison between two TOML keys pure function compare_keys_less ( lhs , rhs ) result ( less ) type ( toml_key ), intent ( in ) :: lhs type ( toml_key ), intent ( in ) :: rhs logical :: less less = lhs % key < rhs % key end function compare_keys_less end module tomlf_utils_sort","tags":"","url":"sourcefile/sort.f90.html"},{"title":"de.f90 – TOML-Fortran","text":"Source Code ! This file is part of toml-f. ! SPDX-Identifier: Apache-2.0 OR MIT ! ! Licensed under either of Apache License, Version 2.0 or MIT license ! at your option; you may not use this file except in compliance with ! the License. ! ! Unless required by applicable law or agreed to in writing, software ! distributed under the License is distributed on an \"AS IS\" BASIS, ! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ! See the License for the specific language governing permissions and ! limitations under the License. !> Proxy module for providing loading and deserialization of TOML data structures module tomlf_de use tomlf_constants , only : tfc , TOML_NEWLINE use tomlf_de_context , only : toml_context use tomlf_de_lexer , only : toml_lexer , new_lexer_from_string , new_lexer_from_unit , & & new_lexer_from_file use tomlf_de_parser , only : parse , toml_parser_config use tomlf_diagnostic , only : toml_level use tomlf_error , only : toml_error use tomlf_type , only : toml_table implicit none private public :: toml_parse public :: toml_load , toml_loads public :: toml_context , toml_parser_config , toml_level !> Parse a TOML document. !> !> This interface is deprecated in favor of [[toml_load]] and [[toml_loads]] interface toml_parse module procedure :: toml_parse_unit module procedure :: toml_parse_string end interface toml_parse !> Load a TOML data structure from the provided source interface toml_load module procedure :: toml_load_file module procedure :: toml_load_unit end interface toml_load !> Load a TOML data structure from a string interface toml_loads module procedure :: toml_load_string end interface toml_loads contains !> Parse a TOML input from a given IO unit. !> !> @note This procedure is deprectated subroutine toml_parse_unit ( table , unit , error ) !> Instance of the TOML data structure, not allocated in case of error type ( toml_table ), allocatable , intent ( out ) :: table !> Unit to read from integer , intent ( in ) :: unit !> Error handling, provides detailed diagnostic in case of error type ( toml_error ), allocatable , intent ( out ), optional :: error call toml_load ( table , unit , error = error ) end subroutine toml_parse_unit !> Wrapper to parse a TOML string. !> !> @note This procedure is deprectated subroutine toml_parse_string ( table , string , error ) !> Instance of the TOML data structure, not allocated in case of error type ( toml_table ), allocatable , intent ( out ) :: table !> String containing TOML document character ( len =* ), intent ( in ), target :: string !> Error handling, provides detailed diagnostic in case of error type ( toml_error ), allocatable , intent ( out ), optional :: error call toml_loads ( table , string , error = error ) end subroutine toml_parse_string !> Load TOML data structure from file subroutine toml_load_file ( table , filename , config , context , error ) !> Instance of the TOML data structure, not allocated in case of error type ( toml_table ), allocatable , intent ( out ) :: table character ( * , tfc ), intent ( in ) :: filename !> Configuration for the parser type ( toml_parser_config ), intent ( in ), optional :: config !> Context tracking the origin of the data structure to allow rich reports type ( toml_context ), intent ( out ), optional :: context !> Error handling, provides detailed diagnostic in case of error type ( toml_error ), allocatable , intent ( out ), optional :: error type ( toml_lexer ) :: lexer type ( toml_error ), allocatable :: error_ call new_lexer_from_file ( lexer , filename , error_ ) if (. not . allocated ( error_ )) then call parse ( lexer , table , config , context , error ) else if ( present ( error )) call move_alloc ( error_ , error ) end if end subroutine toml_load_file !> Load TOML data structure from unit subroutine toml_load_unit ( table , io , config , context , error ) !> Instance of the TOML data structure, not allocated in case of error type ( toml_table ), allocatable , intent ( out ) :: table !> Unit to read from integer , intent ( in ) :: io !> Configuration for the parser type ( toml_parser_config ), intent ( in ), optional :: config !> Context tracking the origin of the data structure to allow rich reports type ( toml_context ), intent ( out ), optional :: context !> Error handling, provides detailed diagnostic in case of error type ( toml_error ), allocatable , intent ( out ), optional :: error type ( toml_lexer ) :: lexer type ( toml_error ), allocatable :: error_ call new_lexer_from_unit ( lexer , io , error_ ) if (. not . allocated ( error_ )) then call parse ( lexer , table , config , context , error ) else if ( present ( error )) call move_alloc ( error_ , error ) end if end subroutine toml_load_unit !> Load TOML data structure from string subroutine toml_load_string ( table , string , config , context , error ) !> Instance of the TOML data structure, not allocated in case of error type ( toml_table ), allocatable , intent ( out ) :: table !> String containing TOML document character ( * , tfc ), intent ( in ) :: string !> Configuration for the parser type ( toml_parser_config ), intent ( in ), optional :: config !> Context tracking the origin of the data structure to allow rich reports type ( toml_context ), intent ( out ), optional :: context !> Error handling, provides detailed diagnostic in case of error type ( toml_error ), allocatable , intent ( out ), optional :: error type ( toml_lexer ) :: lexer call new_lexer_from_string ( lexer , string ) call parse ( lexer , table , config , context , error ) end subroutine toml_load_string end module tomlf_de","tags":"","url":"sourcefile/de.f90.html"}]}